## 移动端开发面试

### 📌 一面

#### 自我介绍？

个人情况，学历，做的项目简单介绍

#### 讲讲Java集合有哪些形式？平时是怎么用的？

主要是Map，Set和queue，主要讲的项目应用场景的使用

#### 项目里数据库用的比较多，讲讲项目中用到的数据库？

es，mysql，minio，pg，mongodb，redis等

### 📌 二面

#### 自我介绍

#### 讲讲线程和进程之间的关系

进程是资源分配的基本单位，每个进程在创建的时候会有自己的独立空间，比如栈和代码段等。而线程则是CPU**调度**的基本单位，也会有自己的寄存器和内存空间。进程是可以创建多个线程。
两者的区别主要在于创建的开销以及通信方式的不同。

#### 什么是虚拟内存？为什么需要虚拟内存？

虚拟内存可以通过地址翻译，把进程需要使用的逻辑地址翻译为物理地址，由内存管理单元完成。

虚拟内存主要是用来提升系统效率，简化内存管理的。
虚拟内存可以让程序运行在比实际物理内存大地址空间上，可以通过swapping操作把不常用的内存页移到磁盘中。也可以把每个进程的逻辑地址映射到物理内存地址，实现进程隔离。有了虚拟内存，操作系统也可以更灵活地分配和回收内存，无需手动考虑物理内存的布局。

#### TCP的四次挥手

第一次是客户端主动关闭连接，向服务端发送FIN包，服务器接收后就不再接收数据了，可以继续发送数据。
第二次是服务器发送ACK包，确认收到FIN包。
第三次是服务器完成数据传输后发送FIN包，客户端收到FIN后准备关闭连接。
第四次是客户端发送最后的ACK包后管理连接。

#### 讲一讲Session和cookie的区别

Cookie是存在用户浏览器的小型数据文件，用于跟踪和保存用户状态。
Session是服务端保存用户状态的机制，每个用户会话会有一个SessionId，对应的SessionId会保存至客户端浏览器中。

#### 关系型数据库的三大范式是什么
第一范式是确保**不可分割**，是要数据库表的每一列都是不可分割的原子数据项
第二范式是确保**没有部分依赖**，也就是确保数据库表的每一列都和主键相关，不能只与主键的某一部分相关
第三范式是确保**没有传递依赖**，也就是任何非主属性不依赖于其他非属性，每一列数据都和主键直接相关，并非间接相关。

1NF -> 列不可拆 -> 2NF -> 消除部分依赖 -> 3NF -> 消除传递依赖

#### （算法题）有环链表

快慢指针/哈希表

#### （算法题）树节点（从前到后，列表中，左右都小于它的数），想到了栈和动规，具体的没答上来

从左到右遍历一遍，n处记录其左侧的最大值。
从右到左遍历一遍，n处记录其右侧的最小值。
再遍历一遍，若左侧最大值比他小，右侧最小值比他大，就符合条件了。

#### 从输入url到请求结束中间发生的过程有哪些

浏览器解析URL -> DNS解析 -> TCP或UDP层三次握手 -> IP -> MAC -> 网卡 -> 交换机 -> 路由器 -> 层层验证 -> 服务器处理 -> 浏览器渲染画面

#### 怎么看待实习

#### 公司部门状态，很生活不卷，业务类似于电商一点

## Java后端开发面试

面试官很尖锐也很现实，给我打醒了

#### 算法题输出

```java
private void change(List<String> list) {
    list = new ArrayList<>();
    list.add('B');
}

private void test() {
    List<String> list = new ArrayList<>();
    list.add('A');
    change(list);
    System.out.print(list.toString());
}
```
这段代码输出的是什么？如果去掉change函数里的第一行，会输出什么？

变量（栈中）存储的是对象在堆中的地址（引用），而非对象本身。
传递引用时，复制的是地址值，因此方法内外的变量会暂时指向同一个对象。
若在方法内**修改引用本身（如重新赋值 list = new ...）**，只会改变方法内变量的指向，不影响外部变量。
若在方法内**修改引用指向的对象内容（如 add 操作）**，会直接改变堆中对象，外部变量访问时会体现这个变化。

#### 如何在一个字符串中，判断是否有连续的n个字符，返回true或false

类似于kmp，更简单，每次匹配失败后更新连续数以及新的字符

这题应该答对了，时间复杂度O(n), 空间复杂度O(1)

#### 整数数组Array1和Array2（都是有序的）中如何获取Arry1中不包含Array2的数，并返回不包含的数组

回答的不好，battle了很久，自己的回答是用HashMap存Array2，再用双指针更新Array1的状态，最后使用substring获取Array1

可以新创建一个用于存放适合数据的空间，然后使用两个指针分别遍历1和2，如果1中元素大于2则移动2指针，如果1中元素小于2则直接进入，如果1中元素等于2则跳过该1中元素。时间复杂度是O(m+n)，空间复杂度则是O(min(m+n))

#### 你认为数据结构和算法在开发过程中的作用

口水题，挖苦了我一下md