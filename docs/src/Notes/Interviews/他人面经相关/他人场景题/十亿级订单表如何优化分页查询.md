### 来自拼多多提前批一面

#### 十亿级订单表如何优化分页查询？

由于偏移量增大，MySQL会扫描并丢弃大量前置行而导致IO成本线性增长，offset超过几十万百万级查询时间可能从毫秒上升到秒或几十秒

分页优化的策略：

1. **游标分页**：使用 WHERE id > last_seen_id ORDER BY id LIMIT pageSize 或联合索引 (user_id, create_time) 实现分页跳转，完全避免大偏移量扫描

2. **延迟关联**：子查询先获取主键集合：SELECT id FROM orders WHERE … ORDER BY … LIMIT offset, pageSize，再 join 原表：SELECT o.* FROM orders o JOIN ( … ) tmp ON o.id = tmp.id

3. 书签分页：通过记录查询边界，结合条件 id >= boundary 每次查询 pageSize 条，并向前或向后滚动，适合流式翻页或数据遍历场景

4. **覆盖索引**：选择包含分页所需字段的索引，使查询只访问索引层，无需回表，显著提速

5. **分区与分表**：按时间、哈希或业务字段拆分订单表，或做冷热数据分离，将热数据存入MySQL，历史冷数据存在ES等系统中减少范围查询

6. 缓存组合查询：将经常查询的分页或前几页结果缓存在Redis等缓存层，减少数据库压力并加速响应。

十亿级别订单表如何设计？
- 首先是数据的分库分表和冷热分层，将近三个月数据存入多个分库份表中，可以按照人员ID或订单ID计算分片位置；将冷数据归档并结合ES/Hive实现低成本查询
- 在分页查询的过程中，可以使用游标分页，记录上一次查询的页数并结合索引实现分页跳转，避免offset查询
- 设计联合索引用于分页排序，使用覆盖索引保证字段齐全，避免回表。

```sql
-- 游标分页
SELECT * FROM orders WHERE user_id = ? AND create_time < ? ORDER BY create_time DESC
LIMIT 20;

-- 延迟关联分页
SELECT o.* FROM orders o
JOIN (
  SELECT id
  FROM orders
  WHERE user_id = ?
  ORDER BY create_time DESC
  LIMIT 100000, 20
) tmp ON o.id = tmp.id;

```
