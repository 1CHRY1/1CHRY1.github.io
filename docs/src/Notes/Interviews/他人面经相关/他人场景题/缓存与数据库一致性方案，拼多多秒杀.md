### 来自拼多多提前批一面

#### 缓存与数据库一致性方案对比？拼多多秒杀采用哪种？

1. 仅设置缓存过期时间，不更新缓存 —— 实现简单，但缓存数据长期不一致而延迟过高
2. 先更新数据库，再删除缓存 —— 一致性较强，但可能出现少量读取到旧值的情况。
3. 延迟双删，即先删除缓存，再更新数据库，延迟后再删一次缓存 —— 效果稳定，但删除的时间需要调优，有高延迟的风险
4. 消息队列异步更新缓存 —— 更新DB后异步发送MQ，消费者更新缓存 —— 解耦缓存的逻辑增强可靠性，但顺序问题难以保证
5. 基于BinLog的异步同步 —— 监听MySQL的binlog根据DB变更同步缓存 —— 取耦合，不影响业务逻辑顺序且可靠，但实现复杂需要独立同步服务
6. 分布式锁/分布式事务 —— 更新时加锁或做分布式事务 —— 保障强一致性，但性能开销高且可用性下降

大多数选择“最终一致”策略，以延迟双删、MQ 异步更新或 Binlog 同步的方式权衡性能与一致性；在强一致性要求极高的场景下，考虑分布式事务与锁的方案。

拼多多秒杀系统一致性策略：
1. 缓存预热与 L1/L2 三级缓存架构
活动前通过 Kafka 将热点商品库存数据预加载到本地 Caffeine 缓存（L1）和 Redis 集群缓存（L2），大幅提升缓存命中率。

2. Redis 原子库存预减（Lua 原子操作）
核心库存扣减操作通过 Redis Lua 脚本完成，保证扣减逻辑的原子性与准确性，避免超卖。

3. 读缓存允许短暂读旧值，写流程确保数据库一致性（最终一致）
秒杀场景对一致性要求严格，但仍允许短暂不一致（读脏数据可容忍，写入口有 DB 校验）。这是典型的“高可用最终一致”架构路径，而非强一致方案。

综上，拼多多秒杀系统主要采用的是 缓存优先 + Lua 原子操作 + 最终一致性设计 的策略：
- 不直接同步更新缓存，而是依靠缓存预热降低加载压力；
- 写操作关键在 Redis 中原子完成库存判断与扣减，然后再同步写入数据库；
- 读缓存可略有滞后但保证流量削峰与核心数据正确性，选择性能与一致性的平衡路径；