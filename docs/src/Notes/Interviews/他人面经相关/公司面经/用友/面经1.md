自我介绍

**说一下对微服务的理解微服务鉴权机制，rpc是干什么的。**
微服务是一种架构风格，将复杂的单体应用分为多个小而独立的服务。每个服务专注一个特定的业务功能，服务之间通过轻量级协议（HTTP/REST、gRPC、消息队列等）通信。
微服务的鉴权机制可以使用：
- 用户在认证服务中登陆并生成一个JWT，后续访问任意接口都需要通过网关统一解析验证JWT并将用户信息放在请求头中，并发送给下游服务
- 服务监督调用时需要携带内部使用的JWT，被调用方可以再次校验TOken确保绕过网关的请求被隔离
- 业务服务内部可以使用SpringSecurity进行细粒度授权，根据JWT中的角色、权限信息以及配置类中的规则，判断用户是否有权访问对应接口

RPC是一种通信协议，使我们可以像调用函数一样调用远程服务，能够屏蔽底层网络细节，提高开发效率，也可以跨语言实现

**说一下kafka在系统中的作用，为什么用kafka而不是直接通信，kafka如何防止消息堆积。**
由于需要接入海量硬件设备的数据，且数据来源多格式也各不相同，速率也不稳定，因此用到了Kafka，可以做到：
- 消息解耦，将数据写入Kafka让后端不同的服务可以独立订阅处理，不必耦合在一起
- 削峰填谷：设备数据可能瞬间暴增，直接写入数据库容易压垮，kafka可以作为高吞吐消息缓冲层，将写入与消费解耦
- 可扩展性：可以通过分区机制，水平扩展消费者，支持并行处理
- 可靠性：kafka自带副本机制，可以保证消息不丢失，适合关键数据场景

使用kafka而非直接通信，可以将数据解耦，提高系统抗压性，并支持横向扩展。

消息堆积的发生原因往往是消费速度小于生产速度，可以用几种机制来缓解这个问题
- 分区：将一个Topi拆分成多个分区，消费者组内多个实例并行消费来提升吞吐
- 扩容消费者实例，使用消费者组实现
- 背压控制：合理设置max.poll.records实现批量拉取异步提交offset，提高消费效率
- 磁盘持久化+顺序写，即使短期积压也不会像内存队列那样直接崩掉。
- 监控预警：结合监控系统观察消费延迟，发现积压则临时扩容消费者

**说一下Redis的常见作用，发布订阅模式的优缺点。**
常见作用：
- 缓存
- 会话存储，保存用户会话实现多实例横向扩展
- 分布式锁，实现多个服务队共享资源的协调访问
- 排行榜，计数器，实时统计
- 消息队列

Redis发布订阅模式
优点在于：实时性好延迟低，简单易用且支持广播
缺点在于：无持久化和可靠性保障，无法确保消息顺序和失败重试，订阅者处理速度慢可能导致缓冲区膨胀

**说一下spring的bean的生命周期，bean初始化怎么知道自己在这个周期。**
Bean的生命周期：
- Spring首先启动后，查找并加载需要被Spring管理的Bean并进行实例化
- 实例化后它的引入和值注入到Bean属性中
- Aware回调，若实现了BeanNameAware(将BeanID传递给setBeanName方法)、BeanFactoryAware(将BeanFactory容器实例，调用setBeanFactory方法传递)、ApplicationContextAware(Bean所在应用上下文引用，调用setApplicationContext方法传递)等，容器会注入对应信息，这个阶段Bean能知道自己的名字或容器引用
- BeanPostProcessor.beforeInit，容器对bean调用BeanPostProcessor.postProcessBeforeInitialization()，允许在init前处理
- 初始化，先执行@PostConstruct，在执行afterPropertiesSet（完成属性注入后执行），最后执行初始化方法
- BeanPostProcessor.afterInitl，调用BeanPostProcessor.postProcessAfterInitialization()，返回最终可用的bean
- 就绪使用，应用代码可用安全使用bean
- 销毁，可触发PreDestroy，自定义销毁方法，。。

Bean可以通过：
- 实现**Aware**接口，注入属性后调用这些方法，能够知道自己的名字/容器引用/应用上下文
- 实现**InitializingBean**或使用@PostConstruct/init-method，此时Bean可以知道自己已经被创建完成或注入依赖或属性（Bean级别，属性就绪后执行自身初始化逻辑）
- 使用**BeanPostProcessor**，可以在容器初始化前/后触发函数（容器级别，在所有Bean初始化阶段拦截和增强）
- 在销毁时可以使用**PreDestory**或自定义destroy-method，bean可在此释放资源

**说一下spring事务机制，@Transactional在什么场景会失效。说一下spring事件传播机制，事物传播级别有哪些。**
Spring主要使用了AOP（代理）+ PlatformTransactionManager 实现事务控制
- 生成代理：Spring 为标注了 @Transactional 的类生成代理（JDK 动态代理或 CGLIB），通过代理拦截方法调用。
- 进入方法前，通过事务拦截器TransactionInterceptor 调用 PlatformTransactionManager 开启事务。
- 方法执行：执行目标业务方法。
- 若方法正常结束则提交事务，抛出未捕获异常则回滚事务

@Transactional失效场景有：
- 方法不是public的，方法没有被代理成功，事务失效
- 类A内部方法调用另一个@Transactional方法不走代理（内部方法直接通过this调用）、
- 异常被捕获但没抛出，Spring不认为有异常发生，不回滚
- 异常类型不匹配，默认只对Error或RuntimeException回滚。
- 事务不在当前线程中
- 数据库引擎不支持事务（如MyISAM不支持事务，需使用InnoDB）
- 未启用事务管理注解或服务类未被Spring容器管理
- 传播策略配置问题（导致事务被挂起或禁止）
- 嵌套事务不当

事务传播机制，共有七种事务传播的行为
- REQUIRED 默认方式。有事务时加入事务；无事务时新建事务。
- REQUIRES_NEW 默认方式。有事务时加入事务；无事务时新建事务。
- NESTED 有事务时创建嵌套事务（Savepoint 支持）；无事务时新建事务。
- SUPPORTS 有事务时加入；无事务则非事务方式执行。
- NOT_SUPPORTED 挂起事务，以非事务方式执行。
- MANDATORY 必须在事务环境中运行，否则抛异常。
- NEVER 必须在非事务环境中运行，否则抛异常。

使用NESTED时，Spring会为子事务创建保存点，异常回滚只回滚到保存点，若数据库不支持保存点则效果不理想

**说一下项目用了哪些常见设计模式，说一下单例模式的实现机制。**




非技术问题：家在哪里，遇到一个新的需求怎么解决，对未来发展的预期，北京的base能否接受，对于应用方向和纯技术的选择。
反问：公司目前主要业务（erp相关）。