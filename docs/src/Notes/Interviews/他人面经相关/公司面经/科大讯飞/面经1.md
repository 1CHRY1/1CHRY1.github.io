1. 先做个自我介绍吧。

2. Java 面向对象有哪些特点？
Java面向对象的四大核心特性：封装、继承、多态、抽象
**封装**是将数据属性和操作绑定在一起，对外隐藏对象内部的实现细节而只暴露必要的接口（比如private属性+getter/setter就是一种封装）
**继承**是子类继承父类的属性和方法，从而复用已有代码（extends类、implements接口，Java是单继承多实现）
**多态**同一接口可以有不同的实现，同一个方法也可以有不同的表现（编译时多态，运行时多态）
**抽象**提取对象的共性特征，隐藏具体实现，降低代码复杂度

3. 讲讲什么是继承、多态和封装？
如上

4. MySQL 索引用的什么数据结构？
B+树

5. 为啥索引要用 B+ 树？
- 和二叉树比较，树高度更小只有三到四层，减少磁盘I/O
- 和B树比较，B树每个节点都存放数据，而B+树只在叶子节点存数据。因此B+树的范围查询更高效，且非叶子节点更小，且由于计算机数据读取的局部性原理。一个数据被访问，其附近的数据也很可能被访问。
- 对比Hash索引，Hash索引更适合等值查询而非范围查询

6. 你觉得什么场景下需要加索引？是不是所有字段都该加？
高频查询的条件字段，JOIN的关联字段（不加的话JOIN会做全表扫描），ORDER BY和GROUP BY字段，经常需要去重或统计的字段（COUNT，GROUP BY），覆盖索引避免回表
不是所有字段都该加，因为索引占用磁盘空间，会降低写入性能，且会让优化器选择困难

7. 索引在哪些情况下会失效？
- 模糊查询以%开头
- 对索引列做计算/函数操作
- 隐式类型转换
- 使用OR且条件不全是索引列
- 不满足最左前缀原则
- 使用NOT，<>，!=，IS NULL（让优化器认为大部分都要扫描，索引意义不大）
- 使用IN或OR但范围太大（同样索引意义不大）
- 使用范围查询后，索引右边列失效

8. 了解 MySQL 的几种隔离级别吗？
读未提交（一个事务可能读到另一个事务未提交的数据）
读已提交（只能读到已经提交的数据）
可重复读（同一事物多次读取同一行，结果一致，可能出现幻读问题）
串行化（所有事务串行执行，性能差）

9.  MVCC 是什么？解决了什么问题？
MVCC —— 多版本并发控制，其核心思想是，同一行数据又多个不同版本存在，每个事务在查询时会根据事务隔离级别读取符合自己版本的快照数据

通过隐藏字段（创建版本号trx_id，删除版本号roll_pointer），将旧版本数据放在undoLog中，事务开始时会生成一个可见性原则ReadView，决定看到哪些版本

MVCC主要解决了读写并发冲突，也实现了高兴功能的事务隔离，具体来说：
- 避免了加锁读带来的性能问题，读操作可以通过快照读实现无锁执行
- 实现了不同的隔离级别如读已提交和可重复读，其中读已提交是每次读数据都会生成新的ReadView看到最新数据，而可重复读是事务第一次读数据生成ReadView而整个事务期间都基于这个快照读取
- 提升了并发性能，实现读写操作都不会阻塞读操作，常见的脏读和不可重复读就是通过MVCC+ReadView实现的

但是MVCC只适用于快照读而不适用于当前读，因为当前读需要读取数据的最新版本而保证数据的一致性，因此会对读取的行或范围加排他锁或意向排他锁

10. 了解线程池吗？
线程池是一种线程复用机制，预先创建好一定数量的线程放在池子里，需要执行任务的时候直接复用线程而不是每次都创建和销毁线程，在java中的核心类是ThreadPoolExecutor

用线程池的主要原因是：
- 减少频繁创建和销毁线程的开销（线程是重量级资源）
- 提高响应速度，任务来了可以用已有线程处理
- 统一管理线程防止资源耗尽
- 增强可扩展性，可以自定义拒绝策略、线程工厂等

线程池核心参数：
**corePoolSize**：核心线程数（空闲时是否保留）。
**maximumPoolSize**：最大线程数，队列满了才会创建新线程直到达到这个数量。
**keepAliveTime+TimeUnit**：非核心线程空闲存活时间。
**workQueue**：存放等待执行的任务
**ThreadFactory**：线程创建策略（命名、daemon、优先级、UncaughtExceptionHandler）。
**RejectedExecutionHandler**：拒绝策略（默认抛异常，调用者线程执行任务，丢弃任务，丢弃最老任务）。
**allowCoreThreadTimeOut**：是否允许 core 线程超时回收。

使用场景：
- IO密集型，线程数设为CPU*2左右
- CPU密集型，线程数设为CPU+1
- 定时任务，用ScheduledThreadPool

11.  线程池有哪些核心参数？
如上

12.  一个任务提交到线程池后，是怎么执行的？
通过调用execute提交任务后，
首先判断线程数是否小于核心线程数，是则创建任务执行，否则进入下一步
尝试将任务放入阻塞队列，若没满则进入队列并等待空闲线程执行，若队列满了则进入下一步
判断线程数是否小于最大线程数，若大于则创建新线程执行任务，否则执行拒绝策略
已有的工作线程会从任务队列中取出任务执行，空闲线程若超过时间单元且线程数大于corePoolSize，线程被销毁

13.  如果让你用 Java 的线程池，实现一个这样的策略：核心线程满了就开非核心线程，非核心也满了再进队列。你怎么实现？

方法一：改造ThreadPoolExecutor的默认行为
在核心线程满但非核心线程没满的时候，假装把队列装满而迫使ThreadPoolExecutor创建非核心线程，线程数达到maximumPoolSize时再把任务放入队列
方法二：继承ThreadPoolExecutor并重写execute()重新实现逻辑

14. 为啥 Java 开发基本都用 Spring？它有啥好处？
- 开发效率高，降低了复杂度（提供了很多开箱即用的功能如IoC，AOP，事务，数据访问，MVC，Security等；开发者不用从零构建框架，减少代码量；SpringBoot能够快速启动一个可以运行的项目）
- IoC/DI，通过容器统一管理对象的创建销毁和依赖关系，模块解耦更容易测试和扩展
- AOP面向切面编程，常见的系统级功能可以通过切面统一实现，不必写重复逻辑
- 统一的事务管理，如声明式事务Transactional，也支持多种数据源
- 生态完整，SpringBoot，Cloud，Secutiry等
- 解耦和可测试性，组件间松耦合
- 微服务与云原生友好

15. 了解 HashMap 吗？
- 数据结构：数组 + 链表 + 红黑树，链表长度超过8且数组长度大于64时，链表会转为红黑树
- 哈希算法：通过hashCode()计算哈希值，再经过**扰动函数**来减少冲突
- 存储过程：根据key的hash计算数组下标，位置为空则直接插入，否则比较key，相等则覆盖，否则加入链表
- 扩容机制：默认初始容量16，加载因子0.75，当size>threshold时会扩容到原来的2倍并重新计算hash位置。
- 线程安全问题：HashMap不线程安全，多线程下会导致数据丢失或死循环。

16.  HashMap 的原理是啥？
如上

17. 怎么让 HashMap 线程安全？
可以直接使用ConcurrentHashMap
也可以使用Collections.synchronizedMap()即对内部每个方法都加上synchronized保证原子性
可以使用HashTable但这个已经过时了
可以使用外部锁包装HashMap

18. ConcurrentHashMap 的实现原理是啥？
JDK1.7的实现是通过Segment分段锁，及Segment+HashEntry实现，将其分成若干个Segment，每个Segement类似于一个小的HashTable。加锁时只锁定一个Segment而并非整个Map。
其问题在于Segment数量固定且不能动态扩展，锁粒度较大

JDK1.8取消Segment，通过Node数组+链表+红黑树实现，通过CAS无锁插入新节点，synchronized用于链表或红黑树上节点操作，锁粒度是桶级别；volatile确保读操作的可见性
扩容机制：当线程发现需要扩容时，不会单线程做rehash而是多个线程一起迁移数据，迁移时采用分段迁移，每个线程负责一部分桶

读操作一般是无所的，而新节点插入时则是用CAS放入数据，若桶不为空则进入synchronized在链表或红黑树里修改

19. 聊聊你项目里解决过的问题，或者项目有什么亮点？