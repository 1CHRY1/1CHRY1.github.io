### 来自拼多多提前批一面

#### CAP理论在拼多多购物车中的取舍？

CAP 定理告诉我们在分布式系统遇到网络分区时只能在一致性和可用性之间选择。拼多多购物车的工程取舍通常是：常规交互（浏览、加车、跨端合并）以用户体验为先，选择可用性优先和最终一致性 —— 把购物车存在 Redis Cluster（低延迟高可用）并异步落库、在客户端/服务端做合并与版本控制，允许短暂不一致并用定期对账与合并策略解决；但在下单/扣库存这类关乎金额与库存安全的步骤必须保证强一致（或使用库存预占/令牌、分布式原子预减、或 SAGA 补偿），以避免超卖。换言之，购物车读写走 AP（快速响应、最终一致），而库存/下单走 CP（原子预占或强一致确认），两者结合，并配套幂等、补偿、监控与演练，能在实际业务中既保证用户体验又保证资金/库存安全

------

CAP理论：
C (一致性)：每次读都能读到最近写入的值
A (可用性)：每个非失效节点的请求都会得到响应
P (分区容错)：当网络分区/丢包时系统容仍能继续运行

**拼多多购物车的需求与侧重点**：
- 用户体验（交互流畅）：
用户在浏览、加车、修改数量时期望快速响应（页面交互不能等待全局同步）。
- 跨设备/跨端一致性：用户在不同设备上操作购物车（合并购物车）需要最终一致、并且冲突合并策略要合理。
- 下单/结算与库存安全：真正扣减库存发生在下单/支付环节，必须避免超卖（需要强一致或用补偿机制）。
- 高并发/抗压能力：大促/推荐流量下，购物车系统必须保持高可用与低延迟。

由此可得：**交互阶段**（浏览/加车/同步）宜倾向 AP（可用性、低延迟、最终一致）；**关键交易阶**段（下单-扣库存）须走 CP 或使用强一致性保障/补偿流程（例如库存预占、分布式事务/SAGA、乐观锁+库存服务单点控制）。这也是大多数电商实践（含秒杀设计）的共识。

工程实践思路：
1. 购物车读写（偏向 AP / 最终一致）
要求操作极快、低延迟、高并发
- **内存缓存为主**：使用 Redis Cluster（分片）存储每用户的购物车（key = user:cart:{userId}）以支持超高 QPS 与低延迟读取。Redis 作为缓存/快速存储以保证 A。
- **写入策略**（写缓存并异步落库）：用户加车/改数先写 Redis（立即返回），再异步写持久存储（MySQL）或写变更流入消息队列做持久化。这样在网络或 DB 压力下也能保持可用。
- **合并策略**：用户登录时把匿名设备的临时购物车合并到用户 ID 的 Redis 购物车，合并策略可以是“数量相加”或“以最后修改为准”，并记录版本/时间戳用于冲突解决。
- **冲突与合并**（最终一致）：使用版本号/时间戳或操作日志（OP log）。合并时通常采用可预测的策略（如 LWW 或 merge-add），并在必要时给用户界面提示。
- **CQRS**（读写分离）：查询走 Redis（热数据），写入写 Redis + 入队落库，离线/定期做反向同步和校验（anti-entropy）。这能提高读可用性与吞吐。

这里的关键：购物车本身接受**短期的不一致性** —— 用户在两端看到不同内容时会合并，但不会导致资金或商品超卖（超卖风险在下单阶段被解决）。

2. 下单 / 库存扣减（偏向 CP / 强一致保证）
防止超卖，保持库存与订单一致。

- 实时校验 + 原子库存预占（推荐）
下单时调用库存服务做**原子预减或预占**（reserve/lock），库存服务对某个 sku 的库存分区做串行化处理（分片 + 锁或单线程队列），或使用 DB 的事务与行级锁保证一致性。只有在预占成功后才创建订单；预占失败则返回库存不足。
预占成功后异步在用户支付时再 finalize（真正扣减）或在超时未支付时回滚预占。
这保证了在分区或并发下库存的一致性（CP）。

- 抢占令牌/令牌桶
在大促/秒杀，提前把可售库存通过分布式“令牌池”（在 Redis）发放给前端或下单节点，只有拿到令牌才允许下单。这是把库存一致性控制转化为令牌的原子分配（通过 Redis INCR/DECR 或 Lua 脚本保原子性），非常适合极端并发。成功拿令牌代表短期内“获得库存资格”

- SAGA/异步补偿
对于跨服务的复杂事务（库存、优惠券、支付），采用事务编排（SAGA）或基于消息的补偿，保证最终一致性并可回滚。SAGA 是把分布式事务拆成可补偿的局部事务，常和 MQ/异步流程结合。

3. 监控、补偿与幂等

- 幂等：所有扣减/回滚、合并操作要设计幂等（orderId、requestId 唯一）以便重试不引入副作用。
- 补偿/超时回滚：预占后设置 TTL，超时未支付自动回滚并发消息。
- 定期校验：异步校验库存与订单一致性，发现异常触发人工/自动补偿。

工程方向的技术细节：
**Redis 用法**：Redis Cluster 存储购物车（value 用 hash 或 JSON），通过 Lua 脚本保证复杂操作原子性（例如“有则增加，无则创建”）。
**持久化**：Redis 作为缓存 + MySQL 作为最终落地（或直接把变更写入消息队列，消费者负责入库）。避免 Redis 单点失数据风险（RDB/AOF/Replica + 持久化策略）。
**并发控制**：库存服务可采用乐观锁（version）或悲观锁（行锁、分布式锁），在超高并发下优先用分布式令牌/预占把并发压力削峰。
合并策略：客户端本地操作时也保留操作日志（op-log），便于离线/网络恢复时回放合并。
**CRDT/Conflict-free Approaches：**理论上可使用 CRDT（比如 G-Counter）来做合并但工程复杂度高，实际电商常用更简单的时间戳/merge 策略。
**灰度与演练**：在大促前做容量预演（库存预占、令牌分发、降级策略），确保分区/网络问题下行为合理。

