### 来自虾皮提前批一面面经

#### 介绍一下Java的并发编程？

并发编程是为了在同一时间段内让多个任务交替或并行执行，提高 CPU 利用率和系统吞吐量。Java 并发的底层基础是 Java 内存模型（JMM），它定义了线程与主内存的交互规则，核心要解决可见性、原子性和有序性问题，分别可以通过 volatile、synchronized、Lock、CAS 等手段解决。线程是基本执行单元，可以用 Thread、Runnable、Callable 创建，但实际开发中多用线程池（Executor 框架）管理线程，降低创建开销并控制并发度。Java 还提供了并发工具类（如 CountDownLatch、Semaphore）、线程安全集合（ConcurrentHashMap）和阻塞队列来简化并发控制。优化并发程序要减少共享数据、降低锁粒度、优先使用无锁结构，并通过监控和基准测试不断调优。优秀的并发程序应在性能和数据一致性之间取得平衡。

——————

并发编程是指在同一时间段内让多个任务交替执行或并行执行的技术，它的目标是提升 CPU 利用率和系统吞吐量，从而加快响应速度。并发与并行是两个不同的概念，**并发关注的是在任务层面上通过任务拆分与调度实现“看起来同时”运行，而并行依赖多核硬件实现物理上的同时执行**。在 Java 中，并发编程的底层基础是 **Java 内存模型（JMM），它定义了线程与主内存之间的交互规则**，也决定了程序在多线程环境下的可见性、原子性和有序性问。可见性问题来源于线程缓存导致变量修改对其他线程不可见；原子性问题出现在复合操作被线程切换打断时；有序性问题则与 CPU 和编译器的指令重排序有关。针对这些问题，Java 提供了 volatile、synchronized、Lock、原子类（CAS）等机制来保障线程安全。

在 Java 并发模型中，**线程**是最基本的执行单元，可以通过继承 Thread、实现 Runnable 或 Callable 接口创建，但在实际开发中更推荐使用**线程池**来管理线程，以减少频繁创建和销毁的开销。线程的状态包括**新建、可运行、阻塞、等待、超时等待和终止**，**不同状态之间的转换**是并发控制的核心。

**锁机制**是并发控制的重要手段，synchronized 是一种内置的可重入锁，适合简单同步场景；Lock 接口（如 ReentrantLock、ReadWriteLock）提供了更灵活的加锁和解锁控制，适合复杂的并发需求。除了锁和 volatile 外，Java 还提供了大量并发工具类，例如 **CountDownLatch** **用于等待多个任务完成，CyclicBarrier** 用于让一组线程相互等待，**Semaphore** 用于控制并发访问的数量，**Exchanger** 用于线程间数据交换。此外，JUC 包中的并发集合类（如 ConcurrentHashMap）和阻塞队列（如 LinkedBlockingQueue）可以在无须显式加锁的情况下安全地在多线程中使用。

**线程池**是 Java 并发编程中的高频考点和实用工具，通过 **ThreadPoolExecutor** 可以精确控制线程池的核心线程数、最大线程数、任务队列、线程存活时间以及拒绝策略，从而实现对系统并发度的合理管理和资源利用的最大化。在实际开发中，优化并发程序的关键在于减少共享数据、降低锁粒度、尽量使用无锁或低锁的数据结构，以及通过固定加锁顺序、锁超时等手段避免死锁。除此之外，开发者应当借助 JStack、Arthas 等工具分析死锁与性能瓶颈，并通过 JMH 等基准测试工具对关键代码进行性能评估与调优。

整体来看，并发编程并不是简单地多开几个线程，而是需要在理解底层内存模型、掌握线程调度原理的基础上，合理利用 Java 提供的各种并发工具与框架，结合具体业务场景做出性能与安全的平衡。一个优秀的并发程序应当既能充分发挥硬件性能，又能保证数据一致性和代码的可维护性。
