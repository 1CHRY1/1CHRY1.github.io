### 记不得在哪看到的了

#### 介绍一下Java的锁机制

Java中锁主要用在管理多线程并发访问共享资源，可以确保任意给定时间内只有一个或固定数量的线程访问特定的资源。

Java提供的锁机制，首先有
*1 内置锁*，可以用于方法或者代码块。当一个线程进入synchronized修饰的代码块或方法时，它会获取关联对象的锁，离开时则释放，在此期间其他线程若来获取同一对象的锁则会被阻塞。当一个线程进入代码块而没有其他线程竞争则使用**偏向锁**，当线程交替进入同步块时使用**轻量级锁**，使用线程栈上的数据结构而避免操作系统级别的锁。**重量级锁**则涉及操作系统的互斥锁。

*2 ReentrantLock*，提供了比synchronized更高级的功能，如可中断的锁等待、定时锁等待、公平锁选项等。ReentrantLock使用`lock()`和`unlock()`方法来获取和释放锁。其中，**公平锁**按照线程请求锁的顺序来分配锁，保证了锁分配的公平性，但可能增加锁的等待时间。**非公平锁**不保证锁分配的顺序，可以减少锁的竞争，提高性能，但可能造成某些线程的饥饿。(java.util.concurrent.locks.ReentrantLock)

*3 读写锁*，允许多个读取者同时访问共享资源，但只允许一个写入者。读写锁通常用于**读取远多于写入**的情况，以提高并发性。(java.util.concurrent.locks.ReadWriteLock)

*4 乐观锁和悲观锁*：悲观锁（Pessimistic Locking）通常指在访问数据前就锁定资源，假设最坏的情况，即数据很可能被其他线程修改。synchronized和ReentrantLock都是悲观锁的例子。乐观锁（Optimistic Locking）通常不锁定资源，而是在更新数据时检查数据是否已被其他线程修改。乐观锁常使用版本号或时间戳来实现。

*5 自旋锁*：自旋锁是一种锁机制，线程在等待锁时会持续循环检查锁是否可用，而不是放弃CPU并阻塞。通常可以使用CAS来实现。这在锁等待时间很短的情况下可以提高性能，但过度自旋会浪费CPU资源。