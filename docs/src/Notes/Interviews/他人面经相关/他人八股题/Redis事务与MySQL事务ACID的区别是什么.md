### 来自拼多多提前批一面

#### Redis事务与MySQL事务的ACID区别？

ACID分别是：
**原子性**：事务中的操作要么全部成功要么全部失败
**一致性**：事务使数据库从一个一致状态变到另一个一致状态，不破坏完整性
**隔离性**：并发事务之间互不干扰
**持久性**：事务提交后所做更改即使系统崩溃也不会丢失

在MySQL中是严格遵循ACID的，
原子性通过undolog实现，即使中间失败也能回滚到事务开始的状态
一致性通过各种约束、事务机制等实现状态完整转换
隔离性通过多种隔离级别实现，如可重复读，读已提交等
持久性通过binlog、redolog和文件系统同步等机制实现

在Redis中的事务则是轻量命令批处理，并不是真正的ACID
对于原子性，Redis事务通过MULTI...EXEC实现命令批量入队和顺序执行，若某条命令在**入队阶段被检查出语法错误**则会被拒绝执行或一条也不执行。但若存在**执行阶段出错**则Redis会跳过该命令并继续执行后续命令，**不支持回滚**，无法完全保证原子性。若节点宕机或故障则可能只部分写入，若使用AOF持久化则可通过redis-check-aof修复，但对原子性也不是自动完整保障。
对于一致性，保证若命令入队错误则事务被拒绝，避免业务状态不一致。若执行期间命令失败，也不会导致整体数据库完整性被破坏，因此一致性仍得保持。但Redis不具备外键、约束机制、一致性检查等传统数据库的结构性保障，一致性更多**依赖业务设计**。
对于隔离性，Redis是单线程执行的，因此事务执行阶段事务内命令排队依次执行而不会被其他客户端打断，事务提交时前若客户端修改了某个被watch的key则该事务也会被放弃执行，这里提供了一种**乐观锁**式的隔离。但Redis无法提供像关系型数据库那样的多隔离级别。
对于持久性，Redis持久性取决于配置，使用RDB快照的话，若快照后一段时间内没用执行快照而Redis崩溃，数据可能会丢失；若使用AOF持久化，仍存在延迟写入可能丢数据的风险。

总之，Redis 事务不是完整的 ACID 实现，不支持回滚、不支持隔离级别、多数情况下持久性弱。Redis 更侧重“性能/简单/高并发”，交易安全与完整一致性仍应依赖关系型数据库，如需强一致环境，可以通过 Redis + MySQL 双写或使用 Lua 脚本保障某些原子操作，但仍需结合业务设计保障可靠性。
