### 来自拼多多提前批一面

#### Nacos如何实现配置动态推送？长轮询原理？

Nacos 实现配置动态推送的核心机制是基于长轮询，它是在 Pull 模式的基础上，引入挂起请求的方式来模拟 Push 的实时响应能力。
客户端（通过 ConfigService）启动后，会周期性调度长轮询任务（默认每 10ms 检查），将自身监听的配置项对应的 MD5 等元数据发送给服务器。
服务端收到请求后，如果配置未变化，则把该请求挂起（hold）在监听队列中，并设定大约 29.5s 的超时时间；若在该时间内配置有变，则遍历挂起队列将新配置直接响应给客户端；若无变更，超时后统一返回，客户端收到后立即重启下一个长轮询。这样既保证配置变更能秒级通知，也避免短轮询带来的服务器和网络压力。
在 Nacos 2.0 中，为了提升效率和实时性，官方已在部分场景引入 gRPC（HTTP/2）双向长连接，服务端直接主动推送变更事件，客户端再按需拉取完整配置，实现更高效的动态同步。

------

Nacos使用长轮询的方式实现了配置的动态推送，即：客户端发起请求，服务端挂起该请求，直到配置变更或超时后才返回。若变更则立即响应避免延迟，无变更则等满超时才响应，减少无效的请求压力。

**客户端侧**：
1. 初始化配置监听时，Nacos客户端通过 ConfigService 创建过程启动 ClientWorker，配置一系列定时任务。（例如每 10ms 触发 checkConfigInfo()）
2. checkConfigInfo() 会调度多个 LongPollingRunnable 任务（每个处理约 3000 个配置监听点），统一分批发起长轮询请求到 Nacos 服务端 listener 接口进行监听
3. 客户端每次请求会携带当前缓存的配置标识（如 MD5），服务端判断是否变更，再决定是否尽快返回新数据或保持挂起等待
4. 收到响应后，客户端更新本地缓存，触发监听器回调，然后立即发起新一轮的长轮询请求，确保持续监听

**服务端侧**
1. 接收到客户端请求/v1/cs/configs/listener 时，若配置未变更则服务器挂起请求并加入监听队列，设置一个定时任务触发响应。若配置发生变更，则服务遍历监听队列，找到对应的监听配置的请求，将最新配置内容写回响应完成推送
2. 定时未发生变更时，会在超时后同一响应，然后客户端再发起新请求。

在Nacos2.0中官方引入了gRPC+HTTP/2长连接代替传统的HTTP长轮询
- 客户端通过gRPC建立双向流，服务端可主动推送配置变更事件
- 客户端接收到变更事件后会发起拉取最新配置更新本地缓存即可