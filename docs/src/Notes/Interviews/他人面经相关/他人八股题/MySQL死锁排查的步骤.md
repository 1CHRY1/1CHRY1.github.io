### 来自拼多多提前批一面

#### MySQL死锁排查步骤？如何用gap锁解决幻读？

死锁排查步骤：
1、首先获取最近一次检测到的死锁信息
SHOW ENGINE INNODB STATUS

2、查看当前正在等待或持有锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX（查看当前活跃的事务信息）
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS（查看当前存在的锁信息）
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS_WAITS（查看当前正在等待锁的事务信息）

3、解读deadlock区块，重点看哪些事务是相互等待的，每个事务持有的锁和等待的锁是哪些，被选为牺牲者的SQL是哪些以及为什么被选

4、回溯应用层与SQL的执行顺序，定位根因。修正可通过：同一访问顺序，缩短事务的事件，添加合适索引，批量操作变成小批次，对冲突高的操作做乐观重试等。

5、使用日志统计频繁死锁的SQL并对这些SQL做优化评估

------

Gap 锁 是对索引记录之间“间隙”的锁，仅用于阻止其他事务在该间隙插入新记录。幻读是在同一个事务中执行select操作得到一组行，后来同一事务再次执行相同查询却看到额外的“新行”。为防止这种情形，某些隔离级别会对扫描的范围加锁，阻止别的事务在该范围插入行。

innodb在可重复读的隔离级别下回将对index上被扫描到的记录设置next-key locks，也会对这些记录之间的gap加锁，因此若另一个事务向其中尝试新增值则会被阻塞。但gap/next-key锁也会导致锁竞争或死锁，因此需要权衡使用。

------

若一定要防止幻读，保证强一致性，可以使用可重复读的隔离级别，并在需要的读取语句中加上FOR UPDATE或LOCK IN SHARE MODE
若幻读并不是问题，则可以将隔离级别改为读已提交，使用MVCC机制来保证减少幻读的情况
