### 来自美团技术团队博客

#### JVM的GC优化方案

案例一、Major GC和Minor GC频繁
- 对于MinorGC频繁问题，其原因主要是新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC；而Minor GC则会在扫描新生代以及复制存活对象到Survivor区（主要）的时候会产生ms级别的STW而导致性能降低。可以通过**增大新生代空间**来降低Minor GC频率。
- 对于Major GC频繁的问题，可以通过**动态年龄计算**的方式实现。一般新生代对象在累计年龄到15以后会转移到老生代，这里可以通过将这个值取为 某个超过survivor区一般的年龄与默认的年龄中的较小值。若晋升年龄过大会导致原本应该晋升的对象一直停留在Survivor区直到溢出，此时Eden+survivor中对象将不再依据年零龄全部提升到老年代，这样对象老化的机制就失效了；若晋升年龄过小则过早晋升的对象不能在新生代被回收而导致老年代空间迅速增长。

案例二、请求高峰期发生GC导致服务可用性下降
- 由于CMS在Remark阶段会发生新生代对象持有老年代的跨代引用，因此Remark需要扫描整个堆判断对象是否存活。CMS在Remark前增加了一个**可中断的预清理**来等待Minor GC的发生，该阶段主要工作仍然是并发标记对象是否存活。此阶段在Eden区使用超过2M时启动，若此阶段执行时等到了Minor GC，那Remark需要扫描的对象就少了。若没有等待，则通过参数强制remark前进行一次Minor GC降低Remark阶段时间。
（当然案例中只针对老年代GC，对于新生代GC同样面临老年代引用问题，JVM通过卡表的引入实现，具体而言就是将老年代的空间范围大小为512B的若干张卡，JVM将卡表对应的元素设置为适当值，之后的MinorGC通过扫描卡表识别哪些卡中存在老年代指向新生代的引用避免了全堆扫描）

案例三、发生STW的GC
发生的情况：1 Perm空间不足 2、CMS GC时由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial Old GCC 3、统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间 4、主动触发Full GC

将永久代的大小进行固定避免动态扩容