### 来自网络面经

#### JVM由哪几部分组成

JVM由
**本地库接口**（与本地方法库交互，融合其他编程语言为Java所用，与其他编程语言交互的接口）
**类加载子系统**（根据全限定类名装载class文件到运行时数据区的方法区中）
**执行引擎子系统**（解释器，解释class指令并提交给操作系统）
**运行时数据区**（方法区、本地方法栈、虚拟机栈、堆、程序计数器）

Java代码运行过程：首先通过编译器将Java源代码转换成字节码，接着类加载系统把字节码加载到运行时数据区的方法区内，再使用执行引擎将字节码翻译成底层系统指令，最后交由 CPU 去执行，而这个过程中可能需要调用其他语言的本地库接口来实现整个程序的功能。

JVM运行时数据区的各区域作用：
**程序计数器**：当前线程执行的字节码的行号指示器，记录当前线程执行到程序的哪个位置，通过改变计数器的值，可以选取下一条需要执行的字节码指令。该区域是线程私有，且是唯一一个不会发生OOM的区域。
**虚拟机栈**：描述 Java 方法执行的内存模型，方法执行时都会创建一个栈帧，每个方法从调用到执行完成，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。用于存储局部变量表、操作数栈、动态链接、方法出口等信息。该区域线程私有，生命周期与线程的生命周期相同。
**本地方法栈**：本地方法栈和虚拟机栈的作用相似，区别是本地方法栈为Native方法服务，而虚拟机栈为Java方法服务，该区域也是线程私有。
**Java堆**：用于存储对象实例，是占用内存最大的区域，可划分为新生代和老年代，新生代又可细分为 Eden区、From Survivor区、To Survivor区。
HJotSpot中，对象在堆内存布局分为三部分：对象头（运行时数据MarkWord，类型指针，数据长度）、实例数据（对象中真正存储的有效信息）、对齐填充（占位符）。
**方法区**：该区域被所有线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码（即class文件）等数据。同时，方法区中有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该区域不需要连续的内存，并且可以动态扩展，动态扩展失败会抛出 OOM 异常，对该区域进行垃圾回收的主要目标是对常量池的回收和对类型的卸载，但是一般比较难实现。
JDK8 之前，Hotspot 中方法区的实现是永久代（Perm），JDK8 开始使用元空间（Metaspace），以前永久代的静态变量和常量池移至堆内存，其他内容移至元空间，**元空间直接在本地内存分配**。