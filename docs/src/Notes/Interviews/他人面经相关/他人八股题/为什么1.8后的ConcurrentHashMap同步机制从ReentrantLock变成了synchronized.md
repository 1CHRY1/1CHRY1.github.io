#### 为什么1.8后的ConcurrentHashMap同步机制从ReentrantLock变成了synchronized ?

在CHM1.7中其结构是数组+链表，相当于使用了多个固定大小的Segment，上锁也是通过key的hash判断Segment数组下标后将其上锁，再获取Segment中的HashEntry下标。其Segment数组一旦初始化后就不会扩容，只有其内部的HashEntry会扩容，并发度也较死板。

而在1.8其结构则不再分段，改成了数组+链表+红黑树的形式，将CHM分成多个Node数组，上锁时也是针对单个节点（桶）上锁。

总结一下，在 JDK 1.8 中，ConcurrentHashMap 改用 synchronized 代替 ReentrantLock，是因为经过 JDK 1.6 之后的多种锁优化（偏向锁、轻量级锁等），synchronized 性能已经不比 ReentrantLock 差，同时 JDK 1.8 改为节点级锁 + CAS 的方式，锁粒度更细，竞争更少，并发度更高。再加上结构由分段数组改为数组 + 链表 + 红黑树，配合 CAS 可以在大多数情况下实现无锁读写，使得整体性能和可维护性都优于 JDK 1.7 的分段锁设计。

synchronized 是 JVM 级别的锁，能享受运行时优化、语义简单、自动释放、无额外内存开销，并且与 CAS 协作自然，适合节点级锁的短临界区加锁。相比之下，ReentrantLock 在这里会增加代码复杂度和维护成本，对性能提升有限，因此 JDK 设计者选择了 synchronized。
