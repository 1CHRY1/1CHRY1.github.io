### 来自拼多多提前批一面

#### RocketMQ如何保证消息不丢失？

RocketMQ 保证消息不丢失是靠端到端的多层保障：生产者端要用可靠的发送模式（同步发送或可靠异步并启用重试），Broker 端要把消息写入持久化存储（CommitLog），并通过**同步刷盘（SYNC_FLUSH）或主从同步复制（SYNC_MASTER）**把数据刷到磁盘并同步到副本后再返回成功响应；消费端要实现幂等消费并正确管理消费位点与重试逻辑。若需要事务级一致性，还可以用 RocketMQ 的事务消息（半消息 + 回查），确保本地事务与消息投递的一致性。工程上要把 Broker 配置为 SYNC_FLUSH 或开启同步主从复制、至少一主一从并做好磁盘/IO 与复制的监控；生产者不要用 ONEWAY，并对发送失败做重试或持久化补发；消费者端保证幂等和 DLQ。通过这些策略结合故障演练（主宕机、磁盘满、网络分区），可以在多数生产场景下实现“消息不丢失”的目标。

------

要保证消息不丢失，需要在发送端、broker、消费端三层同时做好保障。

**从发送端看**：
发送方有SYNC同步等待ACK、ASYNC回调、ONEWAY不等待ACK三种发送模式。保证不丢失必须用SYNC或可靠ASYNC并启用**重试机制**。

**从消费端看**：
消费端在拉取和推送消息后必须正确上报消费结果，RMQ支持消费失败重试以及死信队列，来确保消息最终被处理或被人工补偿审计，同时也要实现消费的幂等性。

**最后从Broker的角度看**：
- 消息落盘与提交日志
RocketMQ 的核心存储是 CommitLog（MappedFile）。当 Broker 接收到消息，会把消息追加写入 CommitLog，再建立索引（ConsumeQueue/IndexFile）以便消费。消息在磁盘上持久化后就能抵抗 Broker 重启或故障。消息存储与清理策略在 MessageStore 中管理。
- 刷盘策略
`SYNC_FLUSH`：Broker 在**响应生产者成功之前，等待磁盘刷写完成**（GroupCommitService），确保消息已落盘 —— 更可靠但延迟高。
`ASYNC_FLUSH`：Broker 异步刷盘（背景线程批量写），吞吐高但在瞬间 crash 时可能丢失最近尚未刷盘的数据。
生产环境如需“零丢失”，应优先考虑 SYNC_FLUSH。
- 主从复制与同步复制模式
RocketMQ 支持 Master → Slave 复制。若配置为 同步复制（**SYNC_MASTER**），Master 只有在 Slave 写入并同步成功后才给生产者返回成功 —— 能避免主节点写入但还没复制到从节点而宕机导致的数据丢失。异步复制（ASYNC_MASTER）延迟小但存在短窗口丢失风险。
新版本/演进（如 5.x）引入更完善的副本集与同步状态集合机制提升 HA 能力。
- 事务消息
对于“发送消息 + 执行本地事务”需要强一致的场景，RocketMQ 支持**事务消息**（RocketMQ 的事务消息通过 “半事务消息 + 两阶段提交 + 事务回查” 机制实现分布式事务一致性：生产者先发送对消费者不可见的半事务消息，执行本地事务后向 broker 提交 COMMIT/ROLLBACK 状态；若结果未知，broker 会定期回查生产者确认状态，最终确保本地操作与消息发送要么都成功、要么都失败，适配跨服务通信场景，兼顾一致性与容错性。）。事务流程可把消息提交或回滚，避免本地事务成功但消息没送出的不一致问题（但注意：事务消息能保证消息被正确投递到 Broker，但最终业务一致性仍需消费者/上游保证）。
- 高可用，监控与容量保护
Broker 会监测磁盘空间、写入队列饱和等，如果磁盘满、流控或存储服务关闭，会拒绝写入（避免不完整写或损坏数据）——这也是防止丢失的一环（并触发告警/限流）。运维上需要做好磁盘/IO预警与扩容。

从工程设置角度看：
- Broker 配置
flushDiskType=SYNC_FLUSH（如果能接受延迟）或在主从复制同时启用 SYNC_MASTER。这确保 Broker 在响应前将数据刷盘并/或同步到从节点。
- 设置合适的 fileReservedTime、磁盘预警阈值和 flow control（写入限流）策略，避免磁盘写满导致异常。
- Producer 使用
使用 同步发送（SYNC）或可靠异步并开重试，不要用 ONEWAY 如果不能容忍丢失。开启发送重试次数与回退策略。生产者端应处理异常（如超时/发送失败）并重试或持久化到本地做补发。
- Replica 与 HA 设计
至少一主一从并配置为同步写入（在严格场景），或在 RocketMQ 新版中采用副本集/raft 风格的同步策略来提高一致性与可用性。验证复制滞后与自动修复机制。
- 事务消息（必要时）
对关键业务使用事务消息（半消息 + 回查）保证“本地事务成功且消息最终可见”的一致性；同时实现可靠的本地事务执行和回查逻辑。
- 消费端设计
实现**幂等消费**（业务侧对重复投递无害）。设置合理的消费重试次数、死信队列（DLQ）与报警。消费位点（offset）要持久化并备份。
- 监控与演练
监控写入成功率、未刷盘消息量、replica lag、磁盘使用、Broker 错误/拒绝情况。模拟故障（主宕机、磁盘满、网络分区）做演练，验证是否出现消息丢失并调整配置。
