### 来自拼多多提前批一面

#### Redis Cluster的slot迁移过程会阻塞请求吗？

Redis Cluster 的 slot 迁移不是把整个集群停掉去搬数据——它是按 slot/key 逐步迁移并用 MIGRATING/IMPORTING + ASK/MOVED 协议来保证客户端能继续被服务和被重定向。 因此不会整体阻塞请求，但会产生重定向、延迟与若干边界情况（如跨 slot 命令失败、Lua/长命令导致节点阻塞、客户端不支持 MOVED/ASK 导致失败）。实务上应使用 cluster-aware 客户端、分批迁移、限速和避免跨 slot 操作以把影响降到最低。

---

迁移的基本流程：
- 迁移一个 slot 时，目标节点会把该 slot 标记为 IMPORTING（来自某源节点），源节点把该 slot 标记为 MIGRATING（正在迁出到某目标节点）。
- 实际的数据是通过 MIGRATE（或内部等价实现）把每个 key 从源节点原子复制到目标节点，然后在源端删除。
- 迁移是逐个 key（或批次）进行的，不是把整个节点“关掉”再搬迁。

客户端是否能继续访问被迁移的key：
- 可以，但访问路径取决于时点与客户端是否是 cluster-aware：如果客户端访问时还在源节点上，源节点仍可能直接返回，在迁移过程中，若客户端请求命中了新分配但数据尚未完全到位，集群会返回 ASK（临时重定向）或 MOVED（永久重定向）响应，客户端应按协议重试到指定节点。
- 只要客户端是 cluster-aware 并能处理 MOVED/ASK，迁移不会导致不可恢复的阻塞，客户端会被透明地重定向或继续被服务。

什么时候会出现 阻塞/失败 感受
- Lua 脚本（EVAL）或长耗时命令：在单节点上会阻塞那个节点的事件循环；如果迁移同时触发大量 MIGRATE 操作或节点负载高，可能导致延迟或短暂阻塞感
- 事务/MULTI包含跨slot的多key操作：果命令涉及多个 slot（跨节点），会直接报 CROSSSLOT，无法正常执行；这跟迁移不直接相同，但在迁移期容易触发这类错误。
- 客户端不遵守cluster协议：（不处理 MOVED/ASK 或不刷新 slot 表）：会看到请求失败或者持续请求旧节点，从而表现为“阻塞”/错误。
- 迁移产生的资源竞争：（CPU/网络/IO 占用高）会引起延迟上升，这在高 QPS 下会被感知为“阻塞”或慢响应。

ASK vs MOVED（为什么有两种）
- ASK：用于临时状态 —— 当某个 key 刚被迁移到目标节点但 slot 映射还没全局更新时，目标节点会允许客户端带 ASKING 前缀直接访问该 key（客户端收到 ASK 后，应短期内直接请求目标节点并在请求前发送 ASKING）。
- MOVED：用于长期/最终状态 —— 表示 slot 的归属已经改变，客户端应该刷新 slot 表并永久访向新节点。

运维与最佳实践
- 使用 cluster-aware 的客户端
- 渐进式/批量迁移：不要一次性搬大量 key，分批迁移并监控延迟。
- 避免在高峰期做大规模重分片；若必须在流量高峰做，限制迁移速率、监控延迟和 CPU。
- 利用副本（replica）：先把副本加入目标节点以减小影响，最后 promote。或者先把 slot 对应数据复制到 replica，再切换主从关系以减少服务中断窗口。
- 避免跨 slot 的多 key 操作；用 hash tag（{}）把相关 keys 放到同一 slot，或重构调用。
- 若有严格零中断需求，考虑外部迁移工具（可以做平滑复制、限速、双写验证等），并做客户端侧重试与幂等。

面试中可能被追问的细节（准备回答）
- “为什么 Lua 脚本会影响迁移？”：因为 Lua 是阻塞式执行，会占用节点的事件循环，延缓 MIGRATE 等操作，或者在迁移时让节点响应变慢；长脚本会影响其他请求的延迟。
- “ASK/MOVED 是谁发起的？”：是节点在检测到请求的 slot 状态与本地映射不符时返回给客户端；客户端应按协议处理并重试。
- “迁移过程中 key 的一致性如何保证？”：MIGRATE 是同步复制单个 key 到目标后删除源，这个过程中目标会被标记为 IMPORTING，从而避免读写错位；但要考虑网络异常/重试带来的重复/幂等问题（MIGRATE 有选项如 REPLACE）。

多说一句，Redis的阻塞情况基本都源于：单线程模型+长耗时操作占用事件循环，主要几种在：
- 大数据量的单条命令（O(N) 操作）
- 持久化 fork + IO
- 网络写阻塞
- 长时间 Lua / 事务
- 删除或迁移大 key