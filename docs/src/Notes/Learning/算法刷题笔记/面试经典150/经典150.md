# 面试经典150题

---

## 📑 目录
- [面试经典150题](#面试经典150题)
  - [📑 目录](#-目录)
    - [一、数组/字符串](#一数组字符串)
      - [1、合并两个有序元素](#1合并两个有序元素)
      - [2、移除元素](#2移除元素)
      - [3、删除有序数组的重复项](#3删除有序数组的重复项)
      - [4、删除有序数组中的重复项2](#4删除有序数组中的重复项2)
      - [5、多数元素](#5多数元素)
      - [6、轮转数组](#6轮转数组)
      - [7、买卖股票的最佳时机](#7买卖股票的最佳时机)
      - [8、买卖股票的最佳时机2](#8买卖股票的最佳时机2)
      - [9、跳跃游戏](#9跳跃游戏)
      - [10、跳跃游戏2](#10跳跃游戏2)
      - [11、H指数](#11h指数)
      - [12、O(1)时间插入删除和获取随机元素](#12o1时间插入删除和获取随机元素)
      - [13、除自身以外数组的乘积](#13除自身以外数组的乘积)
      - [14、加油站](#14加油站)
      - [15、分发糖果](#15分发糖果)
      - [16、接雨水](#16接雨水)
      - [17、罗马数字转整数](#17罗马数字转整数)
      - [18、整数转罗马数字](#18整数转罗马数字)
      - [19、最后一个单词的长度](#19最后一个单词的长度)
      - [20、最长公共前缀](#20最长公共前缀)
      - [21、反转字符串中的单词](#21反转字符串中的单词)
      - [22、Z字形变换（要再去看）](#22z字形变换要再去看)
      - [23、找出字符串中第一个匹配的下标](#23找出字符串中第一个匹配的下标)
      - [24、文本左右对齐](#24文本左右对齐)
    - [二、双指针](#二双指针)
      - [1、验证回文串](#1验证回文串)
      - [2、判断子序列](#2判断子序列)
      - [3、两数之和Ⅱ-输入有序数组](#3两数之和ⅱ-输入有序数组)
      - [4、盛最多水的容器](#4盛最多水的容器)
      - [5、三数之和](#5三数之和)
    - [三、滑动窗口](#三滑动窗口)
      - [1、长度最小的子数组](#1长度最小的子数组)
      - [2、无重复字符的最长子串](#2无重复字符的最长子串)
      - [3、串联所有单词的子串](#3串联所有单词的子串)
      - [4、最小覆盖子串](#4最小覆盖子串)
      - [1、有效的数独](#1有效的数独)
      - [2、螺旋矩阵](#2螺旋矩阵)
      - [3、旋转图像](#3旋转图像)
      - [4、矩阵置零](#4矩阵置零)
      - [5、生命游戏](#5生命游戏)
    - [四、哈希表](#四哈希表)
      - [1、赎金信](#1赎金信)
      - [2、同构字符串](#2同构字符串)
      - [3、单词规律](#3单词规律)
      - [4、有效字母的异位词](#4有效字母的异位词)
      - [5、字母异位词分组](#5字母异位词分组)
      - [6、两数之和](#6两数之和)
      - [7、快乐数](#7快乐数)
      - [8、存在重复元素Ⅱ](#8存在重复元素ⅱ)
      - [128、最长连续序列](#128最长连续序列)
    - [五、区间](#五区间)
      - [1、汇总区间](#1汇总区间)
      - [2、合并区间](#2合并区间)
      - [3、插入区间](#3插入区间)
      - [4、用最少数量的箭引爆气球](#4用最少数量的箭引爆气球)
    - [六、栈](#六栈)
      - [1、有效的括号](#1有效的括号)
      - [2、简化路径](#2简化路径)
      - [3、最小栈](#3最小栈)
      - [4、逆波兰表达式求值](#4逆波兰表达式求值)
      - [5、基本计算器](#5基本计算器)
    - [七、链表](#七链表)
      - [1、环形链表](#1环形链表)
      - [2、两数相加](#2两数相加)
      - [3、合并两个有序链表](#3合并两个有序链表)
      - [4、随机链表的复制](#4随机链表的复制)
      - [5、反转链表Ⅱ](#5反转链表ⅱ)
      - [6、K个一组翻转链表](#6k个一组翻转链表)
      - [7、删除链表倒数第N哥节点](#7删除链表倒数第n哥节点)
      - [8、删除链表中的重复元素](#8删除链表中的重复元素)
      - [8、旋转链表](#8旋转链表)
      - [9、分隔链表](#9分隔链表)
      - [10、LRU缓存](#10lru缓存)
    - [八、二叉树](#八二叉树)
      - [1、二叉树的最大深度](#1二叉树的最大深度)
      - [2、相同的树](#2相同的树)
      - [3、翻转二叉树](#3翻转二叉树)
      - [4、对称二叉树](#4对称二叉树)
      - [5、从前序遍历与中序遍历构造二叉树](#5从前序遍历与中序遍历构造二叉树)
      - [6、从中序与后续遍历序列构造二叉树](#6从中序与后续遍历序列构造二叉树)
      - [7、填充每个节点的下一个右侧节点指针 II](#7填充每个节点的下一个右侧节点指针-ii)
      - [8、二叉树展开为链表](#8二叉树展开为链表)
      - [9、路径总和](#9路径总和)
      - [10、求根节点到叶节点数字之和](#10求根节点到叶节点数字之和)
      - [11、二叉树中的最大路径和](#11二叉树中的最大路径和)
      - [12、二叉搜索树迭代器](#12二叉搜索树迭代器)
      - [13、完全二叉树的节点个数](#13完全二叉树的节点个数)
      - [14、二叉树的最近公共祖先](#14二叉树的最近公共祖先)
    - [九、二叉树层次遍历](#九二叉树层次遍历)
      - [1、二叉树的右视图](#1二叉树的右视图)
      - [2、二叉树的层平均值](#2二叉树的层平均值)
      - [3、二叉树的层序遍历](#3二叉树的层序遍历)
      - [4、二叉树的锯齿形层序遍历](#4二叉树的锯齿形层序遍历)
    - [十、二叉搜索树](#十二叉搜索树)
      - [1、二叉搜索树的最小绝对差](#1二叉搜索树的最小绝对差)
      - [2、二叉搜索树中第 K 小的元素](#2二叉搜索树中第-k-小的元素)
      - [3、验证二叉搜索树](#3验证二叉搜索树)
    - [十一、图](#十一图)
      - [1、岛屿数量](#1岛屿数量)
      - [2、被围绕的区域](#2被围绕的区域)
      - [3、克隆图](#3克隆图)
      - [4、除法求值](#4除法求值)
      - [5、课程表](#5课程表)
      - [6、课程表Ⅱ](#6课程表ⅱ)
    - [十二、图的广度优先搜索](#十二图的广度优先搜索)
      - [1、蛇形棋](#1蛇形棋)
      - [2、最小基因变化](#2最小基因变化)
      - [3、单词接龙](#3单词接龙)
    - [十三、字典树](#十三字典树)
      - [1、实现Trie](#1实现trie)
      - [2、添加与搜索单词 - 数据结构设计](#2添加与搜索单词---数据结构设计)
      - [3、单词搜索Ⅱ](#3单词搜索ⅱ)
    - [十四、回溯](#十四回溯)
      - [1、电话号码的字母组合](#1电话号码的字母组合)
      - [2、组合](#2组合)
      - [3、全排列](#3全排列)
      - [4、组合总和](#4组合总和)
      - [5、N皇后Ⅱ](#5n皇后ⅱ)
      - [6、括号生成](#6括号生成)
      - [7、单词搜索](#7单词搜索)
    - [十五、分治](#十五分治)
      - [1、将有序数组转换为二叉搜索树](#1将有序数组转换为二叉搜索树)
      - [2、排序链表](#2排序链表)
      - [3、简建立叉树](#3简建立叉树)
      - [4、合并k个升序队列](#4合并k个升序队列)
    - [十六、kadane算法](#十六kadane算法)
      - [1、最大子数组和](#1最大子数组和)
      - [2、环形子数组的最大和](#2环形子数组的最大和)
    - [十七、二分查找](#十七二分查找)
      - [1、搜索插入位置](#1搜索插入位置)
      - [2、搜索二维矩阵](#2搜索二维矩阵)
      - [3、寻找峰值](#3寻找峰值)
      - [4、搜索旋转排序数组](#4搜索旋转排序数组)
      - [5、在排序数组中查找元素的第一个和最后一个位置](#5在排序数组中查找元素的第一个和最后一个位置)
      - [6、寻找旋转排序数组中的最小值](#6寻找旋转排序数组中的最小值)
      - [7、寻找两个正序数组的中位数](#7寻找两个正序数组的中位数)
    - [十八、堆](#十八堆)
      - [1、数组中的第K个最大元素](#1数组中的第k个最大元素)
    - [十九、位运算](#十九位运算)
      - [1、二进制求和](#1二进制求和)
      - [2、颠倒二进制位](#2颠倒二进制位)
      - [3、位1的个数](#3位1的个数)
      - [4、只出现一次的数字](#4只出现一次的数字)
      - [5、只出现一次的数字Ⅱ](#5只出现一次的数字ⅱ)
      - [6、数字范围按位与](#6数字范围按位与)
    - [二十、数学](#二十数学)
      - [1、回文数](#1回文数)
      - [2、加一](#2加一)
      - [3、阶乘后的零](#3阶乘后的零)
      - [4、x的平方根](#4x的平方根)
      - [5、Pow(x,n)](#5powxn)
      - [6、直线上最多的点](#6直线上最多的点)
    - [二十一、一维动态规划](#二十一一维动态规划)
      - [1、爬楼梯](#1爬楼梯)
      - [2、打家劫舍](#2打家劫舍)
      - [3、单词拆分](#3单词拆分)
      - [4、零钱兑换](#4零钱兑换)
      - [5、最长递增子序列](#5最长递增子序列)
  - [**核心思路：**](#核心思路)

### 一、数组/字符串

#### 1、合并两个有序元素

**题目链接**
[LeetCode No.88](https://leetcode.cn/problems/merge-sorted-array/?envType=study-plan-v2&envId=top-interview-150)


**核心代码**：

```java
while (p1 >= 0 || p2 >= 0) {
    if (p1 == -1) {
        cur = nums2[p2--];
    } else if (p2 == -1) {
        cur = nums1[p1--];
    } else if (nums1[p1] > nums2[p2]) {
        cur = nums1[p1--];
    } else {
        cur = nums2[p2--];
    }
    nums1[tail--] = cur;
}
```

**<font color=red>核心思路：</font>** 
- 方法一：暴力
- 方法二：正向双指针
- 方法三：逆向双指针（最优）

#### 2、移除元素

**题目链接**
[LeetCode No.27](https://leetcode.cn/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150)


**核心代码**：

```java
int n = nums.length;
int left = 0;
for (int right = 0; right < n; ++ right) {
    if (nums[right] != val) {
        nums[left] = nums[right];
        ++ left;
    }
}
return left;
```

**<font color=red>核心思路：</font>** 
- 双指针，左指针指向已经确定的数组，右指针去判断是否等于val
- 右指针不断向前，左指针只在有正确数字的时候向前

#### 3、删除有序数组的重复项

**题目链接**
[LeetCode No.26](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)


**核心代码**：

```java
int left = 1;
for (int right = 1; right < nums.length; ++ right) {
    if (nums[right] != nums[left-1]) {
        nums[left] = nums[right];
        ++ left;
    }
}
return left;
```

**<font color=red>核心思路：</font>** 
- 双指针，左指针指向已经确定的数组，右指针去判断是否等于左指针前一个值
- 右指针不断向前，左指针只在有正确数字的时候向前

#### 4、删除有序数组中的重复项2

**题目链接**
[LeetCode No.80](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150)


**核心代码**：

```java
int left = 2;
for (int right = 2; right < nums.length; ++ right) {
    if (nums[right] != nums[left-2]) {
        nums[left] = nums[right];
        ++ left;
    }
}
return left;
```

**<font color=red>核心思路：</font>** 
- 和上一题相近，从前一个数改成前两个数就行

#### 5、多数元素

**题目链接**
[LeetCode No.169](https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&envId=top-interview-150)


**核心代码**：

```java
int val = nums[0];
int count = 1;
for (int i = 1; i < nums.length; ++ i) {
    if (count == 0) {
        val = nums[i];
        count = 1;
        continue;
    }
    count = nums[i] == val ? count+1 : count-1;
}
return val;
```

**<font color=red>核心思路：</font>** 
- 本题方法很多
- 方法一：用哈希表计数
- 方法二：排序后取中值
- 方法三：随机挑选后判断是否为众数
- 方法四：将数组分成两段，分别求出左右两半部分的众数，再从中选出正确的众数（按照数量）
- 方法五：投票法（我认为最优）

#### 6、轮转数组

**题目链接**
[LeetCode No.189](https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150)


**核心代码**：

```java
// 方法二代码
public void rotate(int[] nums, int k) {
    int n = nums.length;
    k = k % n;
    int count = gcd(k, n);
    for (int start = 0; start < count; ++start) {
        int current = start;
        int prev = nums[start];
        do {
            int next = (current + k) % n;
            int temp = nums[next];
            nums[next] = prev;
            prev = temp;
            current = next;
        } while (start != current);
    }
}

public int gcd(int x, int y) {
    return y > 0 ? gcd(y, x % y) : x;
}

// 方法三代码
public void rotate(int[] nums, int k) {
    k %= nums.length;
    reverse(nums, 0, nums.length - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.length - 1);
}
public void reverse(int[] nums, int start, int end) {
    while (start < end) {
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start += 1;
        end -= 1;
    }
}
```

**<font color=red>核心思路：</font>** 
- 方法一：在另一个新数组上操作
- 方法二：循环交换（需要计算总数和移动数的最大公约数，用于计算交换轮数。）
- 方法三：交换三次（讨巧）

#### 7、买卖股票的最佳时机

**题目链接**
[LeetCode No.121](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 方法一：贪心算法
// 找到一个最小的购入点
int low = Integer.MAX_VALUE;
// res不断更新，直到数组循环完毕
int res = 0;
for(int i = 0; i < prices.length; i++){
    low = Math.min(prices[i], low);
    res = Math.max(prices[i] - low, res);
}
return res;

// 方法二：动态规划
int[][] dp = new int[length][2];
int result = 0;
dp[0][0] = -prices[0];
dp[0][1] = 0;
for (int i = 1; i < length; i++) {
    dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
    dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
}

```

**<font color=red>核心思路：</font>** 
- 两种方法，贪心算法或动态规划
- 贪心算法的思想主要是，记录最低的价格，并每次都和最低值对比，获取结果最大值
- 动态规划的思想是：使用二维dp数组，第一维是价格数量，第二维是是否已经买入；切记每次更新时如果是买入状态要不维持要不等于价格的负数，因为无法重复买入

#### 8、买卖股票的最佳时机2

**题目链接**
[LeetCode No.122](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java

// 方法一，动态规划
int len = prices.length;
int dp[][] = new int[len][2];
dp[0][0] = - prices[0];
dp[0][1] = 0;
for (int i = 1; i < len; ++ i) {
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]-prices[i]);
    dp[i][1] = Math.max(dp[i-1][0]+prices[i], dp[i-1][1]);
}
return Math.max(dp[len-1][0], dp[len-1][1]);

// 方法二，贪心算法
int result = 0;
for (int i = 1; i < prices.length; ++ i) {
    result += Math.max(prices[i]-prices[i-1], 0);
}
return result;
```

**<font color=red>核心思路：</font>** 
- 和上题基本相同，贪心算法要注意每次累加前一次的价格差，动态规划注意在买入状态要继承先前状态

#### 9、跳跃游戏

**题目链接**
[LeetCode No.55](https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
int len = nums.length;
if (len == 1) return true;
int cover = nums[0];
for (int i = 1; i <= cover; ++ i) {
    if (cover >= len-1)
        return true;
    cover = Math.max(cover, i+nums[i]);
}
return false;
```

**<font color=red>核心思路：</font>** 
- 不断更新右边界，并实时判断是否包含了长度

#### 10、跳跃游戏2

**题目链接**
[LeetCode No.45](https://leetcode.cn/problems/jump-game-ii/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
int result = 0;
// 当前覆盖的最远距离下标
int cur = 0;
// 下一步覆盖的最远距离下标
int next = 0;
for (int i = 0; i <= cur && cur < nums.length - 1; ++i) {
    next = Math.max(next, i + nums[i]);
    // 可达位置的改变次数就是跳跃次数
    if (i == cur) {
        cur = next;
        result++;
    }
}
return result;
```

**<font color=red>核心思路：</font>** 
- 这题好理解，但写的逻辑比较绕，要牢牢把握“当前范围”这个概念
- 通过一个当前范围，一个下一步的范围，不断扩散遍历整个数组，每次离开当前范围的时候都扩展下一范围，将原先下一范围继承给当前范围
- 要注意结束条件是cur < len-1而不是cur < len，因为当cur抵达 len-1 这个值的时候，直接就会跳出循环

#### 11、H指数

**题目链接**
[LeetCode No.274](https://leetcode.cn/problems/h-index/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
Arrays.sort(citations);
int len = citations.length;
int hIndex = 0;
for (int i = 0; i < citations.length; ++ i) {
    if ((len - i) <= citations[i])
        hIndex = Math.max(hIndex, len - i);
}
return hIndex;
```

**<font color=red>核心思路：</font>** 
- 排序后计数判断

#### 12、O(1)时间插入删除和获取随机元素

**题目链接**
[LeetCode No.380](https://leetcode.cn/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// insert
if (indices.containsKey(val))
    return false;
int index = nums.size();
nums.add(val);
indices.put(val, index);
return true;

// delete
if (!indices.containsKey(val))
    return false;
int index = indices.get(val);
int last = nums.get(nums.size()-1);
nums.set(index, last);
indices.put(last, index);
nums.remove(nums.size()-1);
indices.remove(val);
return true;
```

**<font color=red>核心思路：</font>** 
- 使用HashMap与List结合，实现O(1)的get和put，以及随机读取

#### 13、除自身以外数组的乘积

**题目链接**
[LeetCode No.238](https://leetcode.cn/problems/product-of-array-except-self/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
left[0] = 1;
for (int i = 1; i < len; ++ i) {
    left[i] = left[i-1] * nums[i-1];
}
right[len-1] = 1;
for (int i = len-2; i >= 0; -- i) {
    right[i] = right[i+1] * nums[i+1];
}
for (int i = 0; i < len; ++ i)
    result[i] = left[i] * right[i];
```

**<font color=red>核心思路：</font>** 
- 求所有数的左侧数与右侧数乘机，最终相乘得到结果

#### 14、加油站

**题目链接**
[LeetCode No.134](https://leetcode.cn/problems/gas-station/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
for (int i = 0; i < gas.length; ++ i) {
    totalSum += gas[i]-cost[i];
    curSum += gas[i]-cost[i];
    if (curSum < 0) {
        start = i+1;
        curSum = 0;
    }
}
return totalSum >= 0 ? start : -1;
```

**<font color=red>核心思路：</font>** 
- 贪心算法，维护一个totalSum和一个curSum，遍历cost和gas
- 不断累加totalSum和curSum，若curSum<0则证明无法以这个点作为开始，则起始点设为i+1

#### 15、分发糖果

[LeetCode No.135](https://leetcode.cn/problems/candy/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
Arrays.fill(candy,1);
for (int i = 1; i < len; ++ i) 
    candy[i] = ratings[i] > ratings[i-1] ? candy[i-1]+1 : candy[i];
for (int i = len-2; i >= 0; -- i)
    candy[i] = ratings[i] > ratings[i+1] ? Math.max(candy[i],candy[i+1]+1) : candy[i];
for (int i = 0; i < len; ++ i)
    result += candy[i];
```

**<font color=red>核心思路：</font>** 
- 找到从左向右数的正确糖果数量，再从右到左计算正确数量，并与先前数据对比选择最大的

#### 16、接雨水

**题目链接**
[LeetCode No.150](https://leetcode.cn/problems/trapping-rain-water/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
left[0] = height[0];
for (int i = 1; i < len; ++ i)
    left[i] = Math.max(left[i-1], height[i])
right[len-1] = height[len-1];
for (int i = len-2; i >= 0; -- i)
    right[i] = Math.max(right[i+1], height[i]);

for (int i = 0; i < len; ++ i)
    result += Math.min(left[i], right[i])-height[i];
```

**<font color=red>核心思路：</font>** 
- 从左到右选择和左侧比的最大值，从右到左选择和右侧比的最大值，两者求最小值后减去height
- 相当于雨水灌满空间，分别立起左侧和右侧的板子并积累雨水，最后将两个板子抽走，获取还能剩下的水量

#### 17、罗马数字转整数

**题目链接**
[LeetCode No.13](https://leetcode.cn/problems/roman-to-integer/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 初始化
Map<Character, Integer> numMap = new HashMap<Character, Integer>() {{
    put('I', 1);
    put('V', 5);
    put('X', 10);
    put('L', 50);
    put('C', 100);
    put('D', 500);
    put('M', 1000);
}};

// 遍历
for (int i = 0; i < len; ++ i) {
    int value = numMap.get(s.charAt(i));
    if (i < len-1 && value < numMap.get(s.charAt(i+1)))
        result -= value;
    else
        result += value;
}
```

**<font color=red>核心思路：</font>** 
- 使用put初始化map
- 遍历map中信息时，若当前字符串所指代的值小于后一个则减去这个值，否则加上这个值

#### 18、整数转罗马数字

**题目链接**
[LeetCode No.12](https://leetcode.cn/problems/integer-to-roman/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
int[] values={1000,900,500,400,100,90,50,40,10,9,5,4,1};
String[] rom={"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
StringBuilder sb=new StringBuilder();
for (int i = 0; i < values.length; ++ i) {
    while (num >= values[i]) {
        sb.append(rom[i]);
        num -= values[i];
    }
}
```

**<font color=red>核心思路：</font>** 
- 列举所有会出现的值，从大到小判断值是否大于num，大于则写入罗马数字并减去这个值

#### 19、最后一个单词的长度

**题目链接**
[LeetCode No.58](https://leetcode.cn/problems/length-of-last-word/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
while (s.charAt(index) == ' ')
    -- index;
while (index >= 0 && s.charAt(index) != ' ') {
    ++ result;
    -- index;
}
```

**<font color=red>核心思路：</font>** 
- 反向遍历

#### 20、最长公共前缀

**题目链接**
[LeetCode No.14](https://leetcode.cn/problems/longest-common-prefix/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
for (int i = 0; i < length; i++) {
    char c = strs[0].charAt(i);
    for (int j = 1; j < count; j++) {
        if (i == strs[j].length() || strs[j].charAt(i) != c) {
            return strs[0].substring(0, i);
        }
    }
}
```

**<font color=red>核心思路：</font>** 
- 横向或纵向遍历

#### 21、反转字符串中的单词

**题目链接**
[LeetCode No.151](https://leetcode.cn/problems/reverse-words-in-a-string/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
s = s.trim();
List<String> wordList = Arrays.asList(s.split("\\s+"));
Collections.reverse(wordList);
return String.join(" ", wordList);
```

**<font color=red>核心思路：</font>** 
- 使用语言特性，正则匹配空格并分割在拼接


#### 22、Z字形变换（要再去看）

**题目链接**
[LeetCode No.6](https://leetcode.cn/problems/zigzag-conversion/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 特殊情况：行数为1时无需变换
if (numRows == 1) {
    return s;
}

int len = s.length();
int cycle = numRows * 2 - 2; // 周期长度
StringBuilder sb = new StringBuilder();

// 按行遍历（每行处理所有周期中对应位置的字符）
for (int row = 0; row < numRows; row++) {
    // 遍历每个周期
    for (int i = 0; i < len; i += cycle) {
        // 1. 处理周期中垂直向下的字符（每行在周期中的固定位置）
        if (i + row < len) {
            sb.append(s.charAt(i + row));
        }
        
        // 2. 处理周期中斜向上的字符（除了第一行和最后一行）
        if (row != 0 && row != numRows - 1) {
            // 斜向上的字符在周期中的位置 = i + cycle - row
            int diagonalPos = i + cycle - row;
            if (diagonalPos < len) {
                sb.append(s.charAt(diagonalPos));
            }
        }
    }
}

return sb.toString();
```

**<font color=red>核心思路：</font>** 
- 按周期模拟计算


#### 23、找出字符串中第一个匹配的下标

**题目链接**
[LeetCode No.28](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int strStr(String haystack, String needle) {
    if (needle.length() == 0) {
        return 0;
    }
    int[] next = new int[needle.length()];
    getnext(needle, next);
    int i = 0, j = 0;
    while (i < haystack.length()) {
        if (haystack.charAt(i) == needle.charAt(j)) {
            ++ i; ++ j;
        }
        if (j == needle.length()) {
            return i - j;
        } else if (i < haystack.length() && haystack.charAt(i) != needle.charAt(j)) {
            if (j != 0) {
                j = next[j - 1];
            } else {
                ++ i;
            }
        }
    }
    return -1;
}
public void getnext(String s, int[] next) {
    int i = 0;
    next[0] = 0;
    for (int j = 1; j < s.length(); ++ j) {
        while (i > 0 && s.charAt(i) != s.charAt(j)) {
            i = next[i - 1];
        }
        if (s.charAt(i) == s.charAt(j)) {
            ++ i;
            next[j] = i;
        }
    }
}
```

**<font color=red>核心思路：</font>** 
- 求天杀的next数组（不太好理解）

#### 24、文本左右对齐

**题目链接**
[LeetCode No.68](https://leetcode.cn/problems/text-justification/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 没啥，纯模拟，很无聊但不好写
```

**<font color=red>核心思路：</font>** 
- 模拟

### 二、双指针

#### 1、验证回文串

**题目链接**
[LeetCode No.125](https://leetcode.cn/problems/valid-palindrome/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 写入后判断，或直接在字符串上判断（这个更快）
for (int i = 0; i < s.length(); ++ i) {
    if ((s.charAt(i) >= 'a' && s.charAt(i) <= 'z') || (s.charAt(i) >= 'A' && s.charAt(i) <= 'Z')) {
        sb.append(Character.toLowerCase(s.charAt(i)));
    }
    if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
        sb.append(s.charAt(i));
}
int left = 0, right = sb.length()-1;
while (left <= right) {
    if (sb.charAt(left) != sb.charAt(right))
        return false;
    ++ left;
    -- right;
}

while (left < right) {
    while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
        ++left;
    }
    while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
        --right;
    }
    if (left < right) {
        if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {
            return false;
        }
        ++left;
        --right;
    }
}
```

**<font color=red>核心思路：</font>** 
- 双指针遍历左右，直到找到各自满足条件的数后，判断是否相等

#### 2、判断子序列

**题目链接**
[LeetCode No.392](https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public boolean isSubsequence(String s, String t) {
    int indexs = 0, indext = 0;
    int slen = s.length(), tlen = t.length();
    if (slen > tlen)
        return false;
    while (indexs < slen && indext < tlen) {
        if (s.charAt(indexs) == t.charAt(indext)) {
            ++ indexs;
            ++ indext;
        } else
            ++ indext;
    }
    if (indexs > s.length()-1)
        return true;
    else
        return false;
}
```

**<font color=red>核心思路：</font>** 
- s和t上双指针判断

#### 3、两数之和Ⅱ-输入有序数组

**题目链接**
[LeetCode No.167](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
while (index1 < index2) {
    if (numbers[index1] + numbers[index2] > target)
        -- index2;
    else if (numbers[index1] + numbers[index2] < target)
        ++ index1;
    else 
        return new int[]{index1+1, index2+1};
}
```

**<font color=red>核心思路：</font>** 
- 双指针不断逼近target

#### 4、盛最多水的容器

**题目链接**
[LeetCode No.11](https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
while (left < right) {
    result = Math.max(result, (right-left)*Math.min(height[left], height[right]));
    if (height[left] <= height[right])
        ++ left;
    else
        -- right;
}
```

**<font color=red>核心思路：</font>** 
- 移动较低矮的边界，对比最大值

#### 5、三数之和

**题目链接**
[LeetCode No.15](https://leetcode.cn/problems/3sum/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
for (int i = 0; i < len-2; ++ i) {
    if (nums[i] > 0) {
        return result;
    }
    if (i != 0 && nums[i] == nums[i-1])
        continue;
    int left = i+1, right = len-1;
    while (left < right) {
        if (nums[i] + nums[left] + nums[right] < 0) {
            ++ left;
        } else if ( nums[i] + nums[left] + nums[right] > 0 ) {
            -- right;
        } else {
            result.add(Arrays.asList(nums[i], nums[left], nums[right]));
            while (right > left && nums[right] == nums[right-1]) -- right;
            while (right > left && nums[left] == nums[left+1]) ++ left;
            -- right; ++ left;
        }
    }
}
```

**<font color=red>核心思路：</font>** 
- 先排序，选定一个数后使用双指针、

### 三、滑动窗口

#### 1、长度最小的子数组

**题目链接**
[LeetCode No.209](https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
for (int i = 0, j = 0; j < nums.length; ++ j ) {
    sum += nums[j];
    while (sum >= target) {
        len = j - i + 1;
        result = Math.min(result, len);
        sum -= nums[i++];
    }
}
```

**<font color=red>核心思路：</font>** 
- 滑动窗口，值在要求范围时左指针向右，否则右指针向右

#### 2、无重复字符的最长子串

**题目链接**
[LeetCode No.3](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
for (int i = 0, j = 0; j < s.length(); ++ j) {
    while (map.containsKey(s.charAt(j))) {
        map.remove(s.charAt(i));
        ++ i;
    }
    map.put(s.charAt(j), 1);
    maxLen = Math.max(maxLen, j - i + 1);
}
```

**<font color=red>核心思路：</font>** 
- 不断移动右指针，若右侧有相同元素则左指针不断右移直到没有

#### 3、串联所有单词的子串

**题目链接**
[LeetCode No.30](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 没啥
```

**<font color=red>核心思路：</font>** 
- 使用differ哈希表，标识窗口中单词频次和words中单词频次之差。
- 遍历列表，对于每个字符都使用滑动窗口的方法，获取其后面所有符合条件的结果

#### 4、最小覆盖子串

**题目链接**
[LeetCode No.76](https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java

```

**<font color=red>核心思路：</font>** 
- 用右指针扩大窗口找 “有效范围”，用左指针缩小窗口找 “最短有效范围”，通过哈希表记录字符数量并判断有效性

> ### 四、矩阵

#### 1、有效的数独

**题目链接**
[LeetCode No.36](https://leetcode.cn/problems/valid-sudoku/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
for (int i = 0; i < 9; i++) {
    for (int j = 0; j < 9; j++) {
        char c = board[i][j];
        if (c != '.') {
            int index = c - '0' - 1;
            rows[i][index]++;
            columns[j][index]++;
            subboxes[i / 3][j / 3][index]++;
            if (rows[i][index] > 1 || columns[j][index] > 1 || subboxes[i / 3][j / 3][index] > 1) {
                        return false;
                }
            }
        }
    }
```

**<font color=red>核心思路：</font>** 
- 声明固定大小的二维数组实现、

#### 2、螺旋矩阵

**题目链接**
[LeetCode No.54](https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> order = new ArrayList<Integer>();
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return order;
        }

        int rows = matrix.length, columns = matrix[0].length;
        boolean[][] visited = new boolean[rows][columns];
        int total = rows * columns;
        int row = 0, column = 0;
        int[][] directions = { {0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int directionIndex = 0;
        for (int i = 0; i < total; ++ i) {
            order.add(matrix[row][column]);
            visited[row][column] = true;
            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn]) {
                directionIndex = (directionIndex + 1) % 4;
            }
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        }
        return order;
    }
```

**<font color=red>核心思路：</font>** 
- 模拟
- 不断按照四个方向变换，若碰壁就更改方向，直到全部遍历完

#### 3、旋转图像

**题目链接**
[LeetCode No.48](https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 直接旋转
public void rotate(int[][] matrix) {
    int n = matrix.length;
    for (int i = 0; i < n / 2; ++i) {
        for (int j = 0; j < (n + 1) / 2; ++j) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][i];
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
            matrix[j][n - i - 1] = temp;
        }
    }
}

// 水平翻转+对角翻转
// 水平翻转
for (int i = 0; i < n / 2; ++i) {
    for (int j = 0; j < n; ++j) {
        int temp = matrix[i][j];
        matrix[i][j] = matrix[n - i - 1][j];
        matrix[n - i - 1][j] = temp;
    }
}
// 主对角线翻转
for (int i = 0; i < n; ++i) {
    for (int j = 0; j < i; ++j) {
        int temp = matrix[i][j];
        matrix[i][j] = matrix[j][i];
        matrix[j][i] = temp;
    }
}
```

**<font color=red>核心思路：</font>** 
- 方法一：新建一个matrix后每行做一次旋转
- 方法二：分割成四块后，四块分别旋转
- 方法三：水平翻转＋对角线翻转

#### 4、矩阵置零

**题目链接**
[LeetCode No.73](https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
int m = matrix.length, n = matrix[0].length;
boolean[] row = new boolean[m];
boolean[] col = new boolean[n];
for (int i = 0; i < m; i++) {
    for (int j = 0; j < n; j++) {
        if (matrix[i][j] == 0) {
            row[i] = col[j] = true;
        }
    }
}
for (int i = 0; i < m; i++) {
    for (int j = 0; j < n; j++) {
        if (row[i] || col[j]) {
            matrix[i][j] = 0;
        }
    }
}
```

**<font color=red>核心思路：</font>** 
- 标记所有包含0的行号和列号
- 遍历时置零

#### 5、生命游戏

**题目链接**
[LeetCode No.289](https://leetcode.cn/problems/game-of-life/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public void gameOfLife(int[][] board) {
Set<int[]> live = new HashSet<int[]>();
Set<int[]> death = new HashSet<int[]>();
for (int i = 0; i < board.length; ++ i)
    for (int j = 0; j < board[0].length; ++ j)
        int res = check(board, i, j);
        if (res == 1)
            live.add(new int[]{i, j});
        else if (res == 2)
            death.add(new int[]{i, j});
    }
for (int[] location : live)
    board[location[0]][location[1]] = 1;
for (int[] location : death)
    board[location[0]][location[1]] = 0;

private int check(int[][] board, int row, int col) {
    int liveSum = 0;
    for (int i = row-1; i <= row+1; ++ i)
        for (int j = col-1; j <= col+1; ++ j)
            if (!(i == row && j == col) && i >= 0 && >=0 && i < board.length && j < board[0].length && board[i][j]  == 1)
                ++ liveSum;
    if (board[row][col] == 1 && (liveSum < 2 || liveSum>    3))
        return 2;
    else if (board[row][col] == 0 && liveSum == 3)
        return 1;
    else
        return 0;
}
```

**<font color=red>核心思路：</font>** 
- 找到需要更新的位置并记录更新状态

### 四、哈希表

#### 1、赎金信

**题目链接**
[LeetCode No.383](https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
int[] check = new int[26];
for (int i = 0; i < magazine.length(); ++ i) {
    ++ check[magazine.charAt(i)-'a'];
}
for (int i = 0; i < ransomNote.length(); ++ i) {
    if (check[ransomNote.charAt(i)-'a'] == 0)
        return false;
    else
        -- check[ransomNote.charAt(i)-'a'];
}
return true;
```

**<font color=red>核心思路：</font>** 
- 数组统计

#### 2、同构字符串

**题目链接**
[LeetCode No.205](https://leetcode.cn/problems/isomorphic-strings/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
for (int i = 0; i < len; ++i) {
    char x = s.charAt(i), y = t.charAt(i);
    if ((s2t.containsKey(x) && s2t.get(x) != y) || (t2s.containsKey(y) && t2s.get(y) != x)) {
        return false;
    }
    s2t.put(x, y);
    t2s.put(y, x);
}
```

**<font color=red>核心思路：</font>** 
- 让两种字符串中的字符相互映射

#### 3、单词规律

**题目链接**
[LeetCode No.290](https://leetcode.cn/problems/word-pattern/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
String[] strs = s.trim().split(" ");
if (strs.length != pattern.length())
    return false;
HashMap<String, Character> smap = new HashMa>();
HashMap<Character, String> pmap = new HashMa>();
for (int i = 0; i < strs.length; ++i) {
    char pChar = pattern.charAt(i);
    String str = strs[i];
    if ((smap.containsKey(str) && smap.g(str) != pChar) || 
        (pmap.containsKey(pChar) && !Objects.equals(pmap.get(pChar), str))) {
        return false;
    }
    smap.put(str, pChar);
    pmap.put(pChar, str);
}
return true;
```

**<font color=red>核心思路：</font>** 
- 同上，还是存两组对应关系
- 在判断str相等的时候用Objects.equals

#### 4、有效字母的异位词

**题目链接**
[LeetCode No.242](https://leetcode.cn/problems/valid-anagram/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    int[] table = new int[26];
    for (int i = 0; i < s.length(); i++) {
        table[s.charAt(i) - 'a']++;
    }
    for (int i = 0; i < t.length(); i++) {
        table[t.charAt(i) - 'a']--;
        if (table[t.charAt(i) - 'a'] < 0) {
            return false;
        }
    }
    return true;
}
```

**<font color=red>核心思路：</font>** 
- 使用一个int[26]记录字母个数
- 若是包含非字母，则需要使用Hashtable

#### 5、字母异位词分组

**题目链接**
[LeetCode No.49](https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public List<List<String>> groupAnagrams(String[] strs) {
    List<List<String>> result = new ArrayList<>();
    HashMap<String, List<String>> map = new HashMap<>();
    
    for (int i = 0; i < strs.length; ++i) {
        char[] keyChars = strs[i].toCharArray();
        Arrays.sort(keyChars);
        String key = new String(keyChars);
        
        if (map.containsKey(key)) {
            map.get(key).add(strs[i]);
        } else {
            List<String> list = new ArrayList<>();
            list.add(strs[i]);
            map.put(key, list);
        }
    }
    
    for (String key : map.keySet()) {
        result.add(map.get(key));
    }
    
    return result;
}
```

**<font color=red>核心思路：</font>** 
- 用排序后的字符串做键

#### 6、两数之和

**题目链接**
[LeetCode No.1](https://leetcode.cn/problems/two-sum/submissions/648317067/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int[] twoSum(int[] nums, int target) {
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; ++ i) {
        if (map.containsKey(target - nums[i])) {
            return new int[]{map.get(target - nums[i]), i};
        } else {
            map.put(nums[i], i);
        }
    }
    return new int[0];
}
```

**<font color=red>核心思路：</font>** 
- 使用哈希表存放已有数值，每次查看当前数值是否和已有数值匹配

#### 7、快乐数

**题目链接**
[LeetCode No.202](https://leetcode.cn/problems/happy-number/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public boolean isHappy(int n) {
    Set<Integer> seen = new HashSet<>();
    while (n != 1 && !seen.contains(n)) {
        seen.add(n);
        n = getNext(n);
    }
    return n == 1;
}
private int getNext(int n) {
    int totalSum = 0;
    while (n > 0) {
        int d = n % 10;
        n = n / 10;
        totalSum += d * d;
    }
    return totalSum;
}
```

**<font color=red>核心思路：</font>** 
- 不存在无限大的可能，只能是循环或者成为1

#### 8、存在重复元素Ⅱ

**题目链接**
[LeetCode No.219](https://leetcode.cn/problems/contains-duplicate-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < nums.length; ++ i) {
        if (map.containsKey(nums[i]) && i - map.get(nums[i]) <= k)
            return true;
        map.put(nums[i], i);
    }
    return false;
}
```

**<font color=red>核心思路：</font>** 
- 哈希表维护最新的数值位置

#### 128、最长连续序列

**题目链接**
[LeetCode No.128](https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 排序
Arrays.sort(nums);
if (nums.length == 0)
    return 0;
int maxLen = 1;
int result = 1;
for (int i = 1; i < nums.length; ++ i) {
    if (nums[i] == nums[i-1]+1)
        ++ maxLen;
    else if (nums[i] == nums[i-1])
        continue;
    else
        maxLen = 1;
    result = Math.max(result, maxLen);
}
return result;

// 不排序
Set<Integer> num_set = new HashSet<Integer>();
for (int num : nums) {
    num_set.add(num);
}
int longestStreak = 0;
for (int num : num_set) {
    if (!num_set.contains(num - 1)) {
        int currentNum = num;
        int currentStreak = 1
        while (num_set.contains(currentNum + 1)) {
            currentNum += 1;
            currentStreak += 1;
        
        longestStreak = Math.max(longestStreak, currentStreak);
    }

return longestStreak;
```

**<font color=red>核心思路：</font>** 
- 排序法：先排序后判断新进入的值是否等于旧的数+1，更新长度
- 不排序法：使用set存放所有数，并遍历set中的值查看是否是连续数的头，若是则统计数量

### 五、区间

#### 1、汇总区间

**题目链接**
[LeetCode No.228](https://leetcode.cn/problems/summary-ranges/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public List<String> summaryRanges(int[] nums) {
    List<String> result = new ArrayList<>();
    if (nums.length == 0)
        return result;
    List<Integer> cur = new ArrayList<>();
    cur.add(nums[0]);
    
    for (int i = 1; i <= nums.length; ++i) {
        if (i == nums.length || cur.get(cur.size()-1) + 1 != nums[i]) {
            StringBuilder sb = new StringBuilder();
            sb.append(cur.get(0));
            if (cur.size() > 1) {
                sb.append("->");
                sb.append(cur.get(cur.size()-1));
            }
            result.add(sb.toString());
            cur.clear();
            if (i < nums.length) {
                cur.add(nums[i]);
            }
        } else {
            cur.add(nums[i]);
        }
    }
    
    return result;
}
```

**<font color=red>核心思路：</font>** 
- 用一个list存当前连续的区间中的值，在区间结束后加入到结构中

#### 2、合并区间

**题目链接**
[LeetCode No.56](https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int[][] merge(int[][] intervals) {
    int len = intervals.length;
    if (len == 1 || len == 0)
        return intervals;
    List<int[]> regions = new ArrayList<>();
    Arrays.sort(intervals, (a,b) -> a[0] - b[0]);
    for (int i = 0; i < len; ++ i) {
        int start = intervals[i][0], end = intervals[i][1];
        if (regions.size() == 0 || regions.get(regions.size()-1)[1] < s tart)
            regions.add(new int[]{start, end});
        else
            regions.get(regions.size()-1)[1] = Math.max(regions.get(regions.size()-1)[1], end);
    }
    int[][] result = new int[regions.size()][2];
    for (int i = 0; i < regions.size(); ++ i)
        result[i] = regions.get(i);
    return result;
}
```

**<font color=red>核心思路：</font>** 
- 排序后循环所有区间并放入list中，若要更新范围则直接在list中更新范围即可

#### 3、插入区间

**题目链接**
[LeetCode No.57](https://leetcode.cn/problems/insert-interval/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
while (i < n && intervals[i][1] < newInterval[0]) {
    result.add(intervals[i]);
    i++;
}
while (i < n && intervals[i][0] <= newInterval[1]) {
    // 扩展新区间的范围
    newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
    newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
        i++;
    }
// 添加合并后的新区间
result.add(newInterval);
// 3. 添加所有在新区间之后且不重叠的区间
while (i < n) {
    result.add(intervals[i]);
    i++;
}
return result.toArray(new int[result.size()][]);

```

**<font color=red>核心思路：</font>** 
- 分为三段分别遍历，最后添加进入int中

#### 4、用最少数量的箭引爆气球

**题目链接**
[LeetCode No.452](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
int result = 1;
Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));
for (int i = 1; i < points.length; ++ i) {
    if (points[i][0] > points[i-1][1])
        ++ result;
    else 
        points[i][1] = Math.min(points[i-1][1], points[i][1]);
}
return result;
```

**<font color=red>核心思路：</font>** 
- 排序时用Integer.compare，否则碰到极大数会超出限制导致排序错误
- 遍历时直接在point数组中即可更新边界

### 六、栈

#### 1、有效的括号

**题目链接**
[LeetCode No.20](https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
int n = s.length();
if (n % 2 == 1) {
    return false;

Map<Character, Character> pairs = new HashMap<Character, Character>() {{
    put(')', '(');
    put(']', '[');
    put('}', '{');
}};

Deque<Character> stack = new LinkedList<Character>();
for (int i = 0; i < n; i++) {
    char ch = s.charAt(i);
    if (pairs.containsKey(ch)) {
        if (stack.isEmpty() || stack.peek() != pairs.get(ch))   {
                return false;
            }
            stack.pop();
        } else {
            stack.push(ch);
        }
    }
    return stack.isEmpty();
}
```

**<font color=red>核心思路：</font>** 
- 使用map实现括号间匹配，不要用条件判断，没必要
- 也可以使用原数组作为栈，省去栈的空间

#### 2、简化路径

**题目链接**
[LeetCode No.71](https://leetcode.cn/problems/simplify-path/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
for (int i = 0; i < files.length; ++ i) {
    String file = files[i];
    if (file == "" || file.equals("."))
        continue;
    else if (file.equals("..")) {
        if (!stack.isEmpty())
            stack.pop();
    } else
        stack.push(file);
}
if (stack.isEmpty())
    return "/";
StringBuilder sb = new StringBuilder();
while (!stack.isEmpty()) {
    sb.append("/");
    sb.append(stack.pollLast());
}
```

**<font color=red>核心思路：</font>** 
- 先用split将所有的路径提取出来，用栈实现..的逻辑，再用StringBuilder转为字符串即可。

#### 3、最小栈

**题目链接**
[LeetCode No.155](https://leetcode.cn/problems/min-stack/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class MinStack {

    Deque<Integer> stack;
    Deque<Integer> minStack;

    public MinStack() {
        stack = new LinkedList<>();
        minStack = new LinkedList<>();
        minStack.push(Integer.MAX_VALUE);
    }
    
    public void push(int val) {
        stack.push(val);
        minStack.push(Math.min(minStack.peek(), val));
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}
```

**<font color=red>核心思路：</font>** 
- 使用一个minStack存放每次有新元素进入时当前主栈中最小的元素

#### 4、逆波兰表达式求值

**题目链接**
[LeetCode No.150](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
Deque<String> stack = new LinkedList<>();
for (String str : tokens) {
    if (!str.equals("+") && !str.equals("-") && !str.equals("*") && !str.equals("/"))
        stack.push(str);
    else {
        int num1 = Integer.parseInt(stack.pop()), num2 = Integer.parseInt(stack.pop());
        switch (str) {
            case "+": stack.push(Integer.toString(num2 + num1)); break;
            case "-": stack.push(Integer.toString(num2 - num1)); break;
            case "*": stack.push(Integer.toString(num2 * num1)); break;
            case "/": stack.push(Integer.toString(num2 / num1)); break;
            default: break;
        }
    }
}
return Integer.parseInt(stack.pop());
```

**<font color=red>核心思路：</font>** 
- 中间字符格式等转换相对麻烦

#### 5、基本计算器

**题目链接**
[LeetCode No.224](https://leetcode.cn/problems/basic-calculator/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int calculate(String s) {
        int len = s.length();
        int sign = 1;
        Deque<Integer> stack = new LinkedList<Integer>();
        stack.push(1);
        int i = 0;
        int result = 0;
        while (i < len) {
            if (s.charAt(i) == ' ')
                ++ i;
            else if (s.charAt(i) == '+') {
                sign = stack.peek();
                ++ i;
            } else if (s.charAt(i) == '-') {
                sign = - stack.peek();
                ++ i;
            } else if (s.charAt(i) == '(') {
                stack.push(sign);
                ++ i;
            } else if (s.charAt(i) == ')') {
                stack.pop();
                ++ i;
            } else {
                long num = 0;
                while (i < len && Character.isDigit(s.charAt(i))) {
                    num = 10 * num + s.charAt(i) - '0';
                    ++ i;
                }
                result += sign * num;
            }
        }
        return result;
    }
```

**<font color=red>核心思路：</font>** 
- 记录一个符号栈，在遇到括号和弹出括号时加入和弹出阔号前的符号，并不断维护计算一个最终的result

### 七、链表

#### 1、环形链表

**题目链接**
[LeetCode No.141](https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null)
        return false;
    ListNode fast = head.next, slow = head;
    while (slow != fast) {
        if (fast == null || fast.next == null)
            return false;
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
}
```

**<font color=red>核心思路：</font>** 
- 定义一个快指针和一个慢指针，快指针每次向后移动两个节点，满指针每次移动一个，若快指针追上满指针则说明有环，若快指针碰到null值则无环

#### 2、两数相加

**题目链接**
[LeetCode No.2](https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    int pre = 0;
    ListNode result = new ListNode();
    ListNode cur = result;
    result.next = cur;
    while (l1 != null || l2 != null) {
        int num = 0;
        if (l1 != null && l2 != null)
            num = l1.val + l2.val + pre;
        else if (l1 == null)
            num = l2.val + pre;
        else
            num = l1.val + pre;
        ListNode temp = new ListNode();
        if (num >= 10) {
            temp.val = num % 10;
            pre = num / 10;
        }
        else {
            temp.val = num;
            pre = 0;
        }
        cur.next = temp;
        cur = temp;
        if (l1 != null)
            l1 = l1.next;
        if (l2 != null)
            l2 = l2.next;
    }
    if (pre != 0)
        cur.next = new ListNode(pre);
    return result.next;
}
```

**<font color=red>核心思路：</font>** 
- 遍历两链表并相加每一个数，记录进位数并作用与后续的计算

#### 3、合并两个有序链表

**题目链接**
[LeetCode No.21](https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 递归
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) {
        return l2;
    } else if (l2 == null) {
        return l1;
    } else if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}

// 迭代
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode prehead = new ListNode(-1);
    ListNode prev = prehead;
    while (l1 != null && l2 != null) {
        if (l1.val <= l2.val) {
            prev.next = l1;
            l1 = l1.next;
        } else {
            prev.next = l2;
            l2 = l2.next;
        }
        prev = prev.next;
    }
    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
    prev.next = l1 == null ? l2 : l1;
    return prehead.next;
}
```

**<font color=red>核心思路：</font>** 
- 递归或迭代都可以

#### 4、随机链表的复制

**题目链接**
[LeetCode No.138](https://leetcode.cn/problems/copy-list-with-random-pointer/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public Node copyRandomList(Node head) {
    if (head == null) {
        return null;
    }
    if (!cachedNode.containsKey(head)) {
        Node headNew = new Node(head.val);
        cachedNode.put(head, headNew);
        headNew.next = copyRandomList(head.next);
        headNew.random = copyRandomList(head.random);
    }
    return cachedNode.get(head);
}
```

**<font color=red>核心思路：</font>** 
- 使用一个Map存储原链表和已拷贝链表节点的对应关系，并不断递归求当前节点的next和random

#### 5、反转链表Ⅱ

**题目链接**
[LeetCode No.92](https://leetcode.cn/problems/reverse-linked-list-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public ListNode reverseBetween(ListNode head, int left, int right) {
    ListNode dummyNode = new ListNode(-1);
    dummyNode.next = head;
    ListNode pre = dummyNode;
    for (int i = 0; i < left-1; ++ i) {
        pre = pre.next;
    }
    ListNode cur = pre.next;
    ListNode leftHead = pre, rightTail = cur;
    for (int i = 0; i < right - left + 1; ++ i) {
        ListNode temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    leftHead.next = pre;
    rightTail.next = cur;
    return dummyNode.next;
}
```

**<font color=red>核心思路：</font>** 
- 遍历到需要反转链表处开始反转，并记录反转后的leftHead和rightTail值

#### 6、K个一组翻转链表

**题目链接**
[LeetCode No.25](https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummyHead = new ListNode(-1, head);
    ListNode cur = head;
    ListNode pre = dummyHead;
    while (cur != null) {
        ListNode temp = pre;
        for (int i = 0; i < k; ++ i) {
            temp = temp.next;
            if (temp == null)
                return dummyHead.next;
        }
        ListNode next = temp.next;
        Reverse(cur, temp);
        pre.next = temp;
        cur.next = next;
        pre = cur;
        cur = next;
    }
    return dummyHead.next;
}

private void Reverse(ListNode left, ListNode right) {
    ListNode pre = new ListNode(-1, left);
    ListNode cur = left;
    while (pre != right) {
        ListNode temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
}
```

**<font color=red>核心思路：</font>** 
- 遍历整个链表并不断查看当前是否满足长度要求，若满足则将该链表进行反转后并入结果

#### 7、删除链表倒数第N哥节点

**题目链接**
[LeetCode No.19](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
while (cur != null) {
    ++ count;
    cur = cur.next;
}
cur = dummyHead;
int lose = count - n + 1;
while (cur != null) {
    -- lose;
    if (lose == 0) {
        cur.next = cur.next.next;
        return dummyHead.next;
    } else
        cur = cur.next;
}
return dummyHead.next;
```

**<font color=red>核心思路：</font>** 
- 先求链表长度，记录要删除的链表节点位置后，删除这个节点。
- 要使用dummyHead

#### 8、删除链表中的重复元素

**题目链接**
[LeetCode No.82](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
if (head == null) {
    return head;
}

ListNode dummy = new ListNode(0, head)
ListNode cur = dummy;
while (cur.next != null && cur.next.next != null) {
    if (cur.next.val == cur.next.next.val) {
        int x = cur.next.val;
        while (cur.next != null && cur.next.val == x)
            cur.next = cur.next.next;
        }
    } else {
        cur = cur.next;
    }
}

return dummy.next;
```

**<font color=red>核心思路：</font>** 
- 使用cur节点不断向后探测是否有相同节点值，若有则一直循环直到找到非相同的节点。

#### 8、旋转链表

**题目链接**
[LeetCode No.61](https://leetcode.cn/problems/rotate-list/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public ListNode rotateRight(ListNode head, int k) {
    if (k == 0 || head == null || head.next == null) {
        return head;
    }
    int n = 1;
    ListNode iter = head;
    while (iter.next != null) {
        iter = iter.next;
        n++;
    }
    int add = n - k % n;
    if (add == n) {
        return head;
    }
    iter.next = head;
    while (add-- > 0) {
        iter = iter.next;
    }
    ListNode ret = iter.next;
    iter.next = null;
    return ret;
}
```

**<font color=red>核心思路：</font>** 
- 第一次遍历，计数顺便将指针放置在最后
- 第二次遍历，获取到n-k处指针，再拼接为新的旋转链表

#### 9、分隔链表

**题目链接**
[LeetCode No.86](https://leetcode.cn/problems/partition-list/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
ListNode dummyHead = new ListNode(-1, head);
ListNode cur = dummyHead;
while (cur.next != null && cur.next.val < x) {
    cur = cur.next;
}
ListNode pre = cur;
cur = cur.next;
while (cur != null) {
    if (cur.next != null && cur.next.val < x) {
        ListNode temp = cur.next;
        // 接上后半部分
        cur.next = cur.next.next;
        // 塞入前半部分，并移动前半部分
        temp.next = pre.next;
        pre.next = temp;
        pre = pre.next;
    } else
        cur = cur.next;
}
return dummyHead.next;
```

**<font color=red>核心思路：</font>** 
- 用一个pre记录小于x的部分的节点位置，用cur遍历后续节点，若不符合则插入pre节点后

#### 10、LRU缓存

**题目链接**
[LeetCode No.146](https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class LRUCache {

    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
    private int size;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null)
            return -1;
        moveToHead(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            DLinkedNode newNode = new DLinkedNode(key,value);
            cache.put(key, newNode);
            addToHead(newNode);
            ++ size;
            if (size > capacity) {
                DLinkedNode tail = removeTail();
                cache.remove(tail.key);
                -- size;
            }
        } else {
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }

    private DLinkedNode removeTail() {
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
}
```

**<font color=red>核心思路：</font>** 
- 使用哈希表+双向链表实现
- 哈希表中存放双向链表中的具体节点
- 在写的时候，可以先实现addToHead, removeTail, removeNode, moveTOHead等子函数

### 八、二叉树

#### 1、二叉树的最大深度

**题目链接**
[LeetCode No.104](https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
private int travesal(TreeNode node, int level) {
    if (node == null) 
        return level;
    int left = travesal(node.left, level) + 1;
    int right = travesal(node.right, level) + 1;
    return Math.max(left, right);
}
```

**<font color=red>核心思路：</font>** 
- 传入当前层的上层的level，计算当前层的最大层数

#### 2、相同的树

**题目链接**
[LeetCode No.100](https://leetcode.cn/problems/same-tree/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
private boolean traversal(TreeNode p, TreeNode q) {
    if (p == null && q == null)
        return true;
    else if (p == null || q == null)
        return false;
    else if (p.val != q.val)
        return false;
    boolean left = traversal(p.left, q.left);
    boolean right = traversal(p.right, q.right);
    return left && right;
}
```

**<font color=red>核心思路：</font>** 
- 判断pq是否都为空，或者一个为空，或都不为空的情况的前提下，再判断是否相等

#### 3、翻转二叉树

**题目链接**
[LeetCode No.226](https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
private TreeNode traversal(TreeNode node) {
    if (node == null)
        return node;
    traversal(node.left);
    traversal(node.right);
    TreeNode temp = node.left;
    node.left = node.right;
    node.right = temp;
    return node;
}
```

**<font color=red>核心思路：</font>** 
- 前序或后续遍历即可

#### 4、对称二叉树

**题目链接**
[LeetCode No.101](https://leetcode.cn/problems/symmetric-tree/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
private boolean compare(TreeNode left, TreeNode right) {
    if (left == null && right == null)
        return true;
    else if (left == null || right == null)
        return false;
    else if (left.val != right.val)
        return false;
    return compare(left.left, right.right) && compare(left.right, right.left);
}
```

**<font color=red>核心思路：</font>** 
- 同样是先判断空节点，再判断有实数的节点，先序遍历

#### 5、从前序遍历与中序遍历构造二叉树

**题目链接**
[LeetCode No.105](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
private TreeNode build(int[] preorder, int[] inorder, int prestart, int preend, int instart, int inend) {
    if (prestart == preend)
        return null;
    
    int rootVal = preorder[prestart];
    TreeNode node = new TreeNode(rootVal);
    int inmiddle = instart;
    while (inmiddle < inend && inorder[inmiddle] != rootVal)
        ++inmiddle;
    
    int leftSize = inmiddle - instart;
    node.left = build(preorder, inorder, prestart + 1, prestart + 1 + leftSize, instart, inmiddle);
    node.right = build(preorder, inorder, prestart + 1 + leftSize, preend, inmiddle + 1, inend);
        
    return node;
}
```

**<font color=red>核心思路：</font>** 
- 递归生成子树，获取并构建树的根节点后，找到子树的范围后递归构建

#### 6、从中序与后续遍历序列构造二叉树

**题目链接**
[LeetCode No.106](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
private TreeNode build(int[] inorder, int[] postorder, int instart, int inend, int poststart, int postend) {
    if (instart == inend)
        return null;
    int nodeVal = postorder[postend-1];
    TreeNode node = new TreeNode(nodeVal);  
    int inmiddle = instart;
    while (inmiddle < inend && inorder[inmiddle] != nodeVal)
        ++ inmiddle;
        
    int offset = inmiddle - instart;
    node.left = build(inorder, postorder, instart, inmiddle, poststart, poststart + offset);
    node.right = build(inorder, postorder, inmiddle+1, inend, poststart + offset, postend - 1);
        
    return node;
}
```

**<font color=red>核心思路：</font>** 
- 同上题

#### 7、填充每个节点的下一个右侧节点指针 II

**题目链接**
[LeetCode No.117](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 层次遍历
public Node connect(Node root) {
    if (root == null)
        return null;
    Deque<Node> queue = new LinkedList<Node>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int levelSize = queue.size();
        for (int i = 0; i < levelSize; ++ i) {
            Node cur = queue.poll();
            if (i != levelSize - 1)
                cur.next = queue.peek();
            else
                cur.next = null;
            if (cur.left != null)
                queue.offer(cur.left);
            if (cur.right != null)
            queue.offer(cur.right);
        }
    }
    return root;
}

// 在遍历当前层的时候执行下一层的链接
// 我愿称之为惊天妙手
public Node connect(Node root) {
    if (root == null) {
        return null;
    }
    Node head = root; // 当前层的头节点
    // 循环遍历每一层，从上至下
    while (head != null) {
        Node dummy = new Node(0); //下一层的虚拟头节点
        Node temp = dummy; //当前处理的节点
        // 遍历当前层，连接下一层的节点
        for (Node cur = head; cur != null; cur = cur.next) 
            if (cur.left != null) {
                temp.next = cur.left;
                temp = temp.next; //移动temp
            }
            if (cur.right != null) {
                temp.next = cur.right;
                temp = temp.next; //移动temp
            }
        }
        // 移动到下一层的实际头节点处
        head = dummy.next;
    }
    return root;
}
```

**<font color=red>核心思路：</font>** 
- 可以使用层次遍历，记住在内部使用一个循环记录当前层
- 在此基础上优化，可以不用队列直接在当前列将下一列的节点穿起来，时间复杂度为O(1)

#### 8、二叉树展开为链表

**题目链接**
[LeetCode No.114](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
private TreeNode traversal(TreeNode node) {
    if (node == null)
        return null;
    TreeNode left = traversal(node.left);
    node.left = null;
    TreeNode temp = node.right;
    if (left == null)
        node.right = traversal(temp);
    else {
        node.right = left;
        while (left.right != null) 
            left = left.right;
        left.right = traversal(temp);
    }
    return node;
}
```

**<font color=red>核心思路：</font>** 
- 先处理左侧，左侧处理完后记录并将左侧置为空，再处理右侧。若左侧处理结果为空则将右侧结果挂在右节点上，否则遍历左侧结果，并将右侧结果挂在左侧结果的后面

#### 9、路径总和

**题目链接**
[LeetCode No.]()

**核心代码**：

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    return root == null ? false : traversal(root, targetSum, 0);
}
private boolean traversal(TreeNode node, int targetSum, int curSum) {
    curSum += node.val;
    if (node.left == null && node.right == null && curSum == targetSum)
        return true;
    boolean left = node.left == null ? false : traversal(node.left, targetSum, curSum);
    boolean right = node.right == null ? false : traversal(node.right, targetSum, curSum);
    return left || right;
}
```

**<font color=red>核心思路：</font>** 
- 用递归的方法，当判断到叶子节点且当前的路径和等于目标和的时候返回true，最终结果只要有一次返回true就是符合条件的

#### 10、求根节点到叶节点数字之和

**题目链接**
[LeetCode No.129](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
private int sum = 0;

public int sumNumbers(TreeNode root) {
    if (root == null)
        return 0;
    traversal(root, 0);
    return sum;
}
private void traversal(TreeNode root, int curSum) {
    curSum = curSum*10 + root.val;
    if (root.left == null && root.right == null) {
        sum += curSum;
        return;
    }
    if (root.left != null)
        traversal(root.left, curSum);
    if (root.right != null)
    traversal(root.right, curSum);
}
```

**<font color=red>核心思路：</font>** 
- 用递归的方法，存一个全局的sum值，若遍历到叶子节点则在sum的基础上加上这个路径的数值，若叶子节点为null则不继续计算

#### 11、二叉树中的最大路径和

**题目链接**
[LeetCode No.124](https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
int maxSum = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) {
    maxGain(root);
    return maxSum;
}
private int maxGain(TreeNode node) {
    if (node == null)
        return 0;
    
    int leftGain = Math.max(maxGain(node.left), 0);
    int rightGain = Math.max(maxGain(node.right), 0);

    int priceNewpath = node.val + leftGain + rightGain;

    maxSum = Math.max(maxSum, priceNewpath);

    return node.val + Math.max(leftGain, rightGain);
}
```

**<font color=red>核心思路：</font>** 
- 递归解决。
- 递归过程中使用后续遍历（左右子树的最大路径和），先计算出当前节点为路径中心的最大路径和，并与当前maxSum比较。返回值为当前值与左右子树更大路径和的加和。
- 可以看作两个步骤，一个是求当前节点的最大路径和，一个是用当前节点作为路径和中心的路径和 与 当前最大路径和对比计算 得出当前真正的最大路径和

#### 12、二叉搜索树迭代器

**题目链接**
[LeetCode No.173](https://leetcode.cn/problems/binary-search-tree-iterator/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
private class ListNode {

    int val;
    ListNode next;
    public ListNode() {}
    public ListNode(int val) {
        this.val = val;
    }
}
ListNode index;
public BSTIterator(TreeNode root) {
    index = new ListNode(-1);
    ListNode head = index;
    traversal(root);
    index = head;
}
private void traversal(TreeNode node) {
    if (node == null)
        return;
    traversal(node.left);
    index.next = new ListNode(node.val);
    index = index.next;
    traversal(node.right);
}

public int next() {
    index = index.next;
    return index.val;
}

public boolean hasNext() {
    return index.next != null;
}
```

**<font color=red>核心思路：</font>** 
- 使用链表存储中序遍历二叉树的结果

#### 13、完全二叉树的节点个数

**题目链接**
[LeetCode No.222](https://leetcode.cn/problems/count-complete-tree-nodes/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int countNodes(TreeNode root) {
    if (root == null)
        return 0;
    int left = countNodes(root.left);
    int right = countNodes(root.right);
    return 1 + left + right;
}
```

**<font color=red>核心思路：</font>** 
- 递归后续遍历，返回左右子树的节点数+1作为当前节点的个数

#### 14、二叉树的最近公共祖先

**题目链接**
[LeetCode No.236](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q)
        return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if (left != null && right != null) {
        return root;
    }
    if (left != null) {
        return left;
    }
    return right;
}
```

**<font color=red>核心思路：</font>** 
- 若左右节点计算返回p或q，则返回左右节点的返回值。若左右节点分别返回p和q，则返回当前节点

### 九、二叉树层次遍历

#### 1、二叉树的右视图

**题目链接**
[LeetCode No.199](https://leetcode.cn/problems/binary-tree-right-side-view/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 层序遍历
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null)
        return result;
    Deque<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; ++ i) {
            TreeNode cur = queue.poll();
            if (i == size - 1)
                result.add(cur.val);
            if (cur.left != null)
                queue.offer(cur.left);
            if (cur.right != null)
                queue.offer(cur.right);
        }
    }
    return result;
}

// dfs
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> ans = new LinkedList<>();
    dfs(root, 1, ans);
    return ans;
}

public void dfs(TreeNode node, int i, List<Integer> ans) {
    if (node == null) {
        return;
    }
    if (i > ans.size()) {
        ans.add(node.val);
    }
    dfs(node.right, i+1, ans);
    dfs(node.left, i+1, ans);
}
```

**<font color=red>核心思路：</font>** 
- 层序遍历：获取每行最后一个点
- 深度优先：对于每一行，先遍历右子树再遍历左子树，这样右子树的最右侧肯定会先被遍历到。每次遍历时检验当前层的结果List是否存在值，若不存在则将第一个遍历到的值填入

#### 2、二叉树的层平均值

**题目链接**
[LeetCode No.637](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
List<Double> result = new ArrayList<>();
if (root == null)
    return result;
Deque<TreeNode> queue = new LinkedList<TreeNode>();
queue.offer(root);
while (!queue.isEmpty()) {
    int size = queue.size();
    double sum = 0.0;
    for (int i = 0; i < size; ++ i) {
        TreeNode cur = queue.poll();
        sum += cur.val;
        if (cur.left != null)
            queue.offer(cur.left);
        if (cur.right != null)
            queue.offer(cur.right);
    }
    result.add(sum / size);
}
return result;
```

**<font color=red>核心思路：</font>** 
- 同样使用层次遍历统计每一层的数值平均值并加入结果

#### 3、二叉树的层序遍历

**题目链接**
[LeetCode No.102](https://leetcode.cn/problems/binary-tree-level-order-traversal/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null)
        return result;
    Deque<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> levelResult = new ArrayList<>();
        for (int i = 0; i < size; ++ i) {
            TreeNode cur = queue.poll();
            levelResult.add(cur.val);
            if (cur.left != null)
                queue.offer(cur.left);
            if (cur.right != null)
                queue.offer(cur.right);
        }
        result.add(levelResult);
    }
    return result;
}
```

**<font color=red>核心思路：</font>** 
- 和前两个使用同一套代码

#### 4、二叉树的锯齿形层序遍历

**题目链接**
[LeetCode No.103](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null)
        return result;
    Deque<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    int order = 1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> levelResult = new ArrayList<>();
        for (int i = 0; i < size; ++ i) {
            TreeNode cur = queue.poll();
            if (order == 1)
                levelResult.add(cur.val);
            else
                levelResult.add(0, cur.val);
            if (cur.left != null)
                queue.offer(cur.left);
            if (cur.right != null)
                queue.offer(cur.right);
        }
        result.add(levelResult);
        order *= -1;
    }
    return result;
}
```

**<font color=red>核心思路：</font>** 
- 使用order判断插入方式
- 或者使用Collections.reverse(list)

### 十、二叉搜索树


#### 1、二叉搜索树的最小绝对差

**题目链接**
[LeetCode No.530](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
private int result = Integer.MAX_VALUE;
private int lastValue = -1;
public int getMinimumDifference(TreeNode root) {
    traversal(root);
    return result;
}
private void traversal(TreeNode node) {
    if (node == null)
        return;
    traversal(node.left);
    if (lastValue == -1)
        lastValue = node.val;
    else {
        result = Math.min(result, node.val - lastValue);
        lastValue = node.val;
    }
    traversal(node.right);
}
```

**<font color=red>核心思路：</font>** 
- 不断更新lastValue和result
- 要判断lastValue是否为初始值，若为初始值则不做操作

#### 2、二叉搜索树中第 K 小的元素

**题目链接**
[LeetCode No.230](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?envType=study-plan-v2&envId=top-interview-150)


**核心代码**：

```java
private int count = 0;

private int result = -1;

public int kthSmallest(TreeNode root, int k) {
    traversal(root, k);
    return result;
}

private void traversal(TreeNode node, int k) {
    if (node == null)
        return;
    traversal(node.left, k);
    ++ count;
    if (count == k)
        result = node.val;
    traversal(node.right, k);
}
```

**<font color=red>核心思路：</font>** 
- 中序遍历并计数，直到数量达到k记录result

#### 3、验证二叉搜索树

**题目链接**
[LeetCode No.98](https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-interview-150)


**核心代码**：

```java
private long maxValue = Long.MIN_VALUE;

public boolean isValidBST(TreeNode root) {
    if (root == null)
        return true;
    if (!isValidBST(root.left))
        return false;
    if (root.val <= maxValue)
        return false;
    maxValue = root.val;
    return isValidBST(root.right);
}
```

**<font color=red>核心思路：</font>** 
- 每次遍历时都记录当前的node的值为最大值
- 在每次遍历过程中，先判断左子树是否符合条件，后判断node值是否大于左节点，再判断右子树是否符合条件

### 十一、图

#### 1、岛屿数量

**题目链接**
[LeetCode No.200](https://leetcode.cn/problems/number-of-islands/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
private int[][] dir = { {0,1},{-1,0},{0,-1},{1,0} };

private void dfs(int x, int y, char[][] grid) {
    for (int i = 0; i < 4; ++ i) {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx < 0 || nexty <0 || nextx >= grid.length ||nexty >= grid[0].length) 
            continue;
        if (grid[nextx][nexty] =='1') {
            grid[nextx][nexty] = '2';
            dfs(nextx, nexty, grid);
        }
    }
}
public int numIslands(char[][] grid){
    int row = grid.length, col = gri[0].length;
    int result = 0;
    for (int i = 0; i < row; ++ i)
        for (int j = 0; j < col; ++j)
            if (grid[i][j] == '1') {
                ++ result;
                grid[i][j] = '2';
                dfs(i, j, grid);
            }
    return result;
}
```

**<font color=red>核心思路：</font>** 
- 针对所有值为1的格子进行深度优先搜索，若访问过则将值设为2，避免重复访问。

#### 2、被围绕的区域

**题目链接**
[LeetCode No.130](https://leetcode.cn/problems/surrounded-regions/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public void solve(char[][] board) {
    int row = board.length, col =board[0].length;
    for (int i = 0; i < row; i++) {
        dfs(board, i, 0);
        dfs(board, i, col - 1);
    }
    for (int i = 1; i < col; i++) {
        dfs(board, 0, i);
        dfs(board, row - 1, i);
    }
    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; ++) {
            if (board[i][j] == 'A') {
                board[i][j] = 'O';
            } else if (board[i][j]== 'O') {
                board[i][j] = 'X';
            }
        }
    }
}
public void dfs(char[][] board, intx, int y) {
    if (x < 0 || x >= boardlength || y < 0 || y >= board[0]length || board[x][y] != 'O')
        return;
    board[x][y] = 'A';
    dfs(board, x + 1, y);
    dfs(board, x - 1, y);
    dfs(board, x, y + 1);
    dfs(board, x, y - 1);
}
```

**<font color=red>核心思路：</font>** 
- 对边缘格子进行深度优先遍历，若将边缘以及延申到内部的值为'O'的格子设置值为A，其余不动。后重新遍历整个网格，将值为O的全部替换成X，A的替换成O，即可。

#### 3、克隆图

**题目链接**
[LeetCode No.133](https://leetcode.cn/problems/clone-graph/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
private HashMap<Node, Node> visited = new HashMap<>();

public Node cloneGraph(Node node) {
    if (node == null)
        return node;
    if (visited.containsKey(node))
        return visited.get(node);
    Node cloneNode = new Node(nodeval, new ArrayList<>());
    visited.put(node, cloneNode);
    for (Node neighbor : nodeneighbors)
        cloneNode.neighbors.ad(cloneGraph(neighbor));
    return cloneNode;
}
```

**<font color=red>核心思路：</font>** 
- 建立一个Map对应已有节点和新建节点
- 若visited中存在新建节点则返回新建节点，若不存在则新建节点后将其放入visited中，并遍历当前节点的neighbour并同步执行cloneNode函数将结果放入新建节点的neighbours中
- 深拷贝的题目，直接考虑构建一个Map使原有元素和新元素对应，再递归创建

#### 4、除法求值

**题目链接**
[LeetCode No.399](https://leetcode.cn/problems/evaluate-division/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
    int nvars = 0;
    Map<String, Integer> variables =new HashMap<String, Integer>();
    int n = equations.size();
    for (int i = 0; i < n; i++) {
        if (!variables.containsKe(equations.get(i).get(0))) {
            variables.put(equationsget(i).get(0), nvars++);
        }
        if (!variables.containsKe(equations.get(i).get(1))) {
            variables.put(equationsget(i).get(1), nvars++);
        }
    }
    double[][] graph = new doubl[nvars][nvars];
    for (int i = 0; i < nvars; i++) {
        Arrays.fill(graph[i], -1.0);
    }
    for (int i = 0; i < n; i++) {
        int va = variables.ge(equations.get(i).get(0)),vb = variables.get(equationsget(i).get(1));
        graph[va][vb] = values[i];
        graph[vb][va] = 1.0 / value[i];
    }
    for (int k = 0; k < nvars; k++) {
        for (int i = 0; i < nvars; ++) {
            for (int j = 0; j <nvars; j++) {
                if (graph[i][k] >1e-6 && graph[k][j]> 1e-6) {
                    graph[i][j] =graph[i][k] *graph[k][j];
                }
            }
        }
    }
    int queriesCount = queries.siz();
    double[] ret = new doubl[queriesCount];
    for (int i = 0; i <queriesCount; i++) {
        List<String> query = queriesget(i);
        double result = -1.0;
        if (variables.containsKe(query.get(0)) && variablescontainsKey(query.get(1))) {
            int ia = variables.ge(query.get(0)), ib =variables.get(query.ge(1));
            if (graph[ia][ib] > 0) {
                result = graph[ia[ib]];
            }
        }
        ret[i] = result;
    }
    return ret;
}
```

**<font color=red>核心思路：</font>** 
- 弗洛伊德算法解题
- 将所有字符存在一个Map中，并使用一个图存放所有的字符（n*n），在图中填满-1，若变量间有除法关系则在图中记录。
- 使用弗洛伊德算法，计算变量之间能够相互计算结果（通过中间值）的最小路径，并记录其值。
- 遍历queries并找到图内部是否有相关的路径，若有则记录，没有则设置为-1。

#### 5、课程表

**题目链接**
[LeetCode No.207](https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 深搜
List<List<Integer>> edges;
int[] visited;
boolean valid = true;
public boolean canFinish(intnumCourses, int[][] prerequisites) {
    edges = new ArrayList<List<Integer>>();
    for (int i = 0; i < numCourses;++i) {
        edges.add(new ArrayList<Integer>());
    }
    visited = new int[numCourses];
    for (int[] info : prerequisites){
        edges.get(info[1]).add(info[0]);
    }
    for (int i = 0; i <numCourses && valid; ++ i)
        if (visited[i] == 0)
            dfs(i);
    return valid;
}
private void dfs(int u) {
    visited[u] = 1;
    for (int v : edges.get(u)) {
        if (visited[v] == 0) {
            dfs(v);
            if (!valid) {
                return;
            }
        } else if (visited[v] == 1) {
            valid = false;
            return;
        }
    }
    visited[u] = 2;
}

// 广搜
List<List<Integer>> edges;
int[] indeg;

public boolean canFinish(intnumCourses, int[][] prerequisites) {
    edges = newArrayList<List<Integer>>();
    for (int i = 0; i < numCourses;++i) {
        edges.add(newArrayList<Integer>());
    }
    indeg = new int[numCourses];
    for (int[] info : prerequisites){
        edges.get(info[1]).add(inf[0]);
        ++indeg[info[0]];
    }
    Queue<Integer> queue = newLinkedList<Integer>();
    for (int i = 0; i < numCourses;++i) {
        if (indeg[i] == 0) {
            queue.offer(i);
        }
    }
    int visited = 0;
    while (!queue.isEmpty()) {
        ++visited;
        int u = queue.poll();
        for (int v: edges.get(u)) {
            --indeg[v];
            if (indeg[v] == 0) {
                queue.offer(v);
            }
        }
    }
    return visited == numCourses;
}
```

**<font color=red>核心思路：</font>** 
- 使用拓扑排序方法，通过使用一个visit数组记录节点的遍历状态（0未遍历，1当前遍历到，2遍历完成），若出现了重复搜索的问题则立刻返回false表示无法学完所有课程，全部搜索完毕后则返回true
- 深搜：逆向思维，在课程的所有前置课程中深度搜索，若碰到循环则返回false
- 广搜：正向思维，使用数组存放每个节点的前置数量，并使用队列，若前置节点数量为0则入队，出队时计数并减去所有前置队列包含当前出队节点的数量，若最终计数值等于课程数量则返回true。

#### 6、课程表Ⅱ

**题目链接**
[LeetCode No.210](https://leetcode.cn/problems/course-schedule-ii/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
List<List<Integer>> edges;
int[] visited;
boolean valid = true;
List<Integer> result = newArrayList<>();
public int[] findOrder(intnumCourses, int[][] prerequisites) {
    edges = new ArrayList<>();
    for (int i = 0; i < numCourses++i) {
        edges.add(newArrayList<Integer>());
    }
    visited = new int[numCourses];
    for (int[] info : prerequisites){
        edges.get(info[1]).add(inf[0]);
    }
    for (int i = 0; i <numCourses &&valid; ++ i)
        if (visited[i] == 0)
            dfs(i);
    if (valid == true) {
        Collections.reverse(result);
        return result.stream()mapToInt(Integer::intValue)toArray();
    } else
        return new int[0];
}
private void dfs(int u) {
    visited[u] = 1;
    for (int v : edges.get(u)) {
        if (visited[v] == 0) {
            dfs(v);
            if (!valid) {
                return;
            }
        } else if (visited[v] == 1) {
            valid = false;
            return;
        }
    }
    visited[u] = 2;
    result.add(u);
}
```

**<font color=red>核心思路：</font>** 
- 同上一题，只是在遍历完后添加结果，注意深搜的结果需要倒序

### 十二、图的广度优先搜索

#### 1、蛇形棋

**题目链接**
[LeetCode No.909](https://leetcode.cn/problems/snakes-and-ladders/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int snakesAndLadders(int[][] board) {
    int len = board.length;
    Deque<int[]> queue = newLinkedList<int[]>();
    boolean[] visited = new boolea[len*len+1];
    queue.offer(new int[]{1, 0});
    while (!queue.isEmpty()) {
        int[] cur = queue.poll();
        for (int i = 1; i <= 6; ++i) {
            int value = cur[0] + i;
            if (value > len*len)
                break;
            // if (visited[value] ==true)
            //     continue;
            int[] location =value2location(value,len);
            if (board[location[0]][location[1]] != -1)
                value = boar[location[0]][location[1]];
            if (value == len*len)
                return cur[1]+1;
            if (!visited[value]) {
                visited[value] =true;
                queue.offer(new int[]{value, cur[1]+1});
            }
        }
    }
    return -1;
}
private int[] value2location(intvalue, int len) {
    int row = (value - 1) / len, col= (value - 1) % len;
    if (row % 2 == 1)
        col = len - 1 - col;
    return new int[]{len - 1 - row,col};
}
```

**<font color=red>核心思路：</font>** 
- 在队列中存放{x,y}，其中x代表当前节点所到位置，y代表到当前节点所需的步数
- 除此之外再存一个visited数组记录是否访问过
- 创建一个队列，每次实现一个长度为6（骰子点数）的循环，若当前为被访问到则入队，否则也会继续访问
- 直到找到第一个返回到终点的值
- 注意这里不能过早设置已访问，因为梯子需要反复使用。假设value之前被访问过，但此时value存在一个未被处理过的「梯子」可以跳转到一个新的未访问位置。由于提前判断value已访问而跳过，会错失这个通过梯子到达新位置的机会，导致 BFS 漏解。

#### 2、最小基因变化

**题目链接**
[LeetCode No.433](https://leetcode.cn/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int minMutation(String startGene, String endGene, String[] bank) {
    Set<String> bankGene = new HashSet<String>();
    Set<String> visited = new HashSet<String>();
    char[] keys = {'A', 'C', 'G', 'T'};
    for (String w : bank)
        bankGene.add(w);
    if (startGene.equals(endGene))
        return 0;
    if (!bankGene.contains(endGene))
        return -1;
    Deque<String> queue = newLinkedList<String>();
    queue.offer(startGene);
    visited.add(startGene);
    int step = 1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; ++i) {
            String cur = queue.pol();
            for (int j = 0; j < 8;++ j) {
                for (int k = 0; k <4; ++ k) {
                    StringBuffer sb= newStringBuffe(cur);
                    sb.setCharAt(j,keys[k]);
                    String next = sb.toString();
                    if (!visited.contains(next) && bankGene.contains(next)) {
                        if (next.equals(endGene))
                            return step;
                        queue.offer(next);
                        visited.add(next);
                    }
                }
            }
        }
        ++ step;
    }
    return -1;
}
```

**<font color=red>核心思路：</font>** 
- 遍历每个可能改动的String中的字母，若bank中存在则将其放入队列，直到找到合理解

#### 3、单词接龙

**题目链接**
[LeetCode No.127](https://leetcode.cn/problems/word-ladder/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    Set<String> wordDict = new HashSet<>();
    Set<String> visited = new HashSet<String>();
    Set<Character> charDict = new HashSet<>();
    for (String word : wordList) {
        for (int i = 0; i < word.length(); ++ i)
            charDict.add(word.charAt(i));
        wordDict.add(word);
    }
    if (!wordDict.contains(endWord))
        return 0;
    Deque<String> queue = new LinkedList<String>();
    queue.offer(beginWord);
    visited.add(beginWord);
    int step = 1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; ++ i) {
            String word = queue.poll();
            for (int j = 0; j < word.length(); ++ j) {
                for (char ch : charDict) {
                    if (ch == word.charAt(j))
                        continue;
                    StringBuilder sb = new StringBuilder(word);
                    sb.setCharAt(j, ch);
                    String next = sb.toString();
                    if (!visited.contains(next) && wordDict.contains(next)) {
                        if (next.equals(endWord))
                            return step + 1;
                        queue.offer(next);
                        visited.add(next);
                    }
                }
            }
        }
        ++ step;
    }
    return 0; 
}
```

**<font color=red>核心思路：</font>** 
- 可以用和上一题相同的思路实现，区别在于需要自己统计所有存在的字母

### 十三、字典树

#### 1、实现Trie

**题目链接**
[LeetCode No.208](https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Trie {

    Trie[] children;
    boolean isEnd;

    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }
    
    public void insert(String word) {
        Trie node = this;
        for (int i = 0; i < word.length(); ++ i) {
            char ch = word.charAt(i);
            int index = ch - 'a';
            if (node.children[index] == null)
                node.children[index] = new Trie();
            node = node.children[index];
        }
        node.isEnd = true;
    }
    
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }

    private Trie searchPrefix(String prefix) {
        Trie node = this;
        for (int i = 0; i < prefix.length(); ++ i) {
            char ch = prefix.charAt(i);
            int index = ch - 'a';
            if (node.children[index] == null)
                return null;
            node = node.children[index];
        }
        return node;
    }
}
```

**<font color=red>核心思路：</font>** 
- 节点中存放数组和是否为单词结尾的标识符，妙哉

#### 2、添加与搜索单词 - 数据结构设计

**题目链接**
[LeetCode No.211](https://leetcode.cn/problems/design-add-and-search-words-data-structure/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class WordDictionary {

    class Trie {
        private Trie[] children;
        private boolean isEnd;

        public Trie() {
            children = new Trie[26];
            isEnd = false;
        }

        public void insert(String word) {
            Trie node = this;
            for (int i = 0; i < word.length(); ++ i) {
                char ch = word.charAt(i);
                int index = ch - 'a';
                if (node.children[index] == null)
                    node.children[index] = new Trie();
                node = node.children[index];
            }
            node.isEnd = true;
        }

        public Trie[] getChildren() {
            return children;
        }

        public boolean isEnd() {
            return isEnd;
        }
    }

    private Trie root;

    public WordDictionary() {
        root = new Trie();
    }
    
    public void addWord(String word) {
        root.insert(word);
    }
    
    public boolean search(String word) {
        return dfs(word, 0, root);
    }

    private boolean dfs(String word, int index, Trie node) {
        if (index == word.length())
            return node.isEnd();
        char ch = word.charAt(index);
        if (Character.isLetter(ch)) {
            int childIndex = ch - 'a';
            Trie child = node.getChildren()[childIndex];
            if (child != null && dfs(word, index+1, child))
                return true;
        } else {
            for (int i = 0; i < 26; ++ i) {
                Trie child = node.getChildren()[i];
                if (child != null && dfs(word, index + 1, child))
                    return true;
            }
        }
        return false;
    }
}
```

**<font color=red>核心思路：</font>** 
- 在上一题基础上，加上'.'的使用，即遇到'.'的时候执行遍历的逻辑，逐步dfs每个节点是否符合条件

#### 3、单词搜索Ⅱ

**题目链接**
[LeetCode No.212](https://leetcode.cn/problems/word-search-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {
    int[][] dirs = { {1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    public List<String> findWords(char[][] board, String[] words) {
        Trie trie = new Trie();
        for (String word : words) {
            trie.insert(word);
        }

        Set<String> ans = new HashSet<String>();
        for (int i = 0; i < board.length; ++i) {
            for (int j = 0; j < board[0].length; ++j) {
                dfs(board, trie, i, j, ans);
            }
        }

        return new ArrayList<String>(ans);
    }

    public void dfs(char[][] board, Trie now, int i1, int j1, Set<String> ans) {
        if (!now.children.containsKey(board[i1][j1])) {
            return;
        }
        char ch = board[i1][j1];
        Trie nxt = now.children.get(ch);
        if (!"".equals(nxt.word)) {
            ans.add(nxt.word);
            nxt.word = "";
        }

        if (!nxt.children.isEmpty()) {
            board[i1][j1] = '#';
            for (int[] dir : dirs) {
                int i2 = i1 + dir[0], j2 = j1 + dir[1];
                if (i2 >= 0 && i2 < board.length && j2 >= 0 && j2 < board[0].length) {
                    dfs(board, nxt, i2, j2, ans);
                }
            }
            board[i1][j1] = ch;
        }

        if (nxt.children.isEmpty()) {
            now.children.remove(ch);
        }
    }
}

class Trie {
    String word;
    Map<Character, Trie> children;
    boolean isWord;

    public Trie() {
        this.word = "";
        this.children = new HashMap<Character, Trie>();
    }

    public void insert(String word) {
        Trie cur = this;
        for (int i = 0; i < word.length(); ++i) {
            char c = word.charAt(i);
            if (!cur.children.containsKey(c)) {
                cur.children.put(c, new Trie());
            }
            cur = cur.children.get(c);
        }
        cur.word = word;
    }
}
```

**<font color=red>核心思路：</font>** 
- 构建字典树，其中children可以是HashMap便于匹配
- 深度优先遍历board，由于同样的路径中不能使用重复的单词，需要用回溯的方式将当前搜索过的单词置为'#'，深度搜索后再将其置为原来值

### 十四、回溯

#### 1、电话号码的字母组合

**题目链接**
[LeetCode No.17](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {

    HashMap<Character, String> letterMap = new HashMap<>() {{
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }};
    List<String> result = new ArrayList<>();
    
    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0)
            return result;
        StringBuilder sb = new StringBuilder();
        backtracking(digits, 0, sb);
        return result;
    }

    private void backtracking(String digits, int index, StringBuilder sb) {
        if (index == digits.length()) {
            result.add(sb.toString());
            return;
        }
        String letters = letterMap.get(digits.charAt(index));
        for (int i = 0; i < letters.length(); ++ i) {
            sb.append(letters.charAt(i));
            backtracking(digits, index+1, sb);
            sb.deleteCharAt(index);
        }
    }
}
```

**<font color=red>核心思路：</font>** 
- 将数据填入HashMap，每次记录当前拼凑字符串以及位置并计算结束后回溯，将数据记录进入全局的List中，最后返回结果

#### 2、组合

**题目链接**
[LeetCode No.77](https://leetcode.cn/problems/combinations/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {

    List<List<Integer>> result = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        backtracking(1, n, k, new ArrayList<>());
        return result;
    }

    private void backtracking(int index, int n, int k, List<Integer> cur) {
        if (cur.size() == k) {
            result.add(new ArrayList<>(cur));
            return;
        }
        int size = n - (k - cur.size()) + 1;
        for (int i = index; i <= size; ++ i) {
            cur.add(i);
            backtracking(i+1, n, k, cur);
            cur.remove(cur.size()-1);
        }
    }
}
```

**<font color=red>核心思路：</font>** 
- 在回溯过程中记录当前所抵达的数值位置以及当前记录下来的路径，并在遍历的时候通过当前数量以及要求数量剪枝

#### 3、全排列

**题目链接**
[LeetCode No.46](https://leetcode.cn/problems/permutations/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {

    List<List<Integer>> result = new ArrayList<>();

    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        boolean[] visited = new boolean[len];
        List<Integer> path = new ArrayList<>();
        backtracking(nums, visited, path);
        return result;
    }

    private void backtracking(int[] nums, boolean[] visited, List<Integer> path) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; ++ i) {
            if (visited[i] == true)
                continue;
            visited[i] = true;
            path.add(nums[i]);
            backtracking(nums, visited, path);
            visited[i] = false;
            path.remove(path.size()-1);
        }
    }
}
```

**<font color=red>核心思路：</font>** 
- 设置一个visited数组记录已经访问过的元素，回溯时回溯path和visited

#### 4、组合总和

**题目链接**
[LeetCode No.39](https://leetcode.cn/problems/combination-sum/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {

    List<List<Integer>> result = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtracking(candidates, target, 0, new ArrayList<>(), 0);
        return result;
    }

    private void backtracking(int[] candidates, int target, int curSum, List<Integer> cur, int index) {
        if (curSum == target) {
            result.add(new ArrayList<>(cur));
            return;
        }
        for (int i = index; i < candidates.length; ++ i) {
            if (curSum + candidates[i] > target)
                continue;
            cur.add(candidates[i]);
            backtracking(candidates, target, curSum+candidates[i], cur, i);
            cur.remove(cur.size()-1);
        }
    }
}
```

**<font color=red>核心思路：</font>** 
- 搜索回溯，每次记录回溯的起始索引（一定要包含上次的索引）

#### 5、N皇后Ⅱ

**题目链接**
[LeetCode No.52](https://leetcode.cn/problems/n-queens-ii/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {

    private int result = 0;

    public int totalNQueens(int n) {
        int[] methods = new int[n];
        backtracking(methods, 0);
        return result;
    }

    private void backtracking(int[] methods, int row) {
        if (row == methods.length) {
            ++ result;
            return;
        }
        int len = methods.length;
        for (int j = 0; j < len; ++ j) {
            if (check(methods, row, j)) {
                methods[row] = j;
                backtracking(methods, row+1);
                methods[row] = 0;
            }
        }
    }

    private boolean check(int[] methods, int row, int col) {
        for (int i = 0; i < row; ++ i) 
            if (methods[i] == col || Math.abs(row-i) == Math.abs(col - methods[i]))
                return false;
        return true;
    }
}

// 位运算法
class Solution {
    // 主方法：计算n皇后问题的解的总数
    public int totalNQueens(int n) {
        // 调用递归方法solve，初始参数：
        // n：棋盘大小
        // row=0：从第0行开始处理（行从0计数）
        // columns=0：列冲突标记（初始无冲突）
        // diagonals1=0：主对角线（左上→右下）冲突标记（初始无冲突）
        // diagonals2=0：副对角线（右上→左下）冲突标记（初始无冲突）
        return solve(n, 0, 0, 0, 0);
    }

    // 递归方法：计算从第row行开始的有效布局数量
    // 参数说明：
    // n：棋盘大小
    // row：当前处理的行（从0到n-1）
    // columns：二进制数，第i位为1表示"第i列已有皇后"（列冲突）
    // diagonals1：二进制数，第i位为1表示"第i条主对角线已有皇后"（主对角线冲突）
    // diagonals2：二进制数，第i位为1表示"第i条副对角线已有皇后"（副对角线冲突）
    public int solve(int n, int row, int columns, int diagonals1, int diagonals2) {
        // 递归终止条件：当处理完所有行（row == n），说明找到一个有效布局，返回1
        if (row == n) {
            return 1;
        } else {
            int count = 0; // 记录当前行开始的有效布局数量
            
            // 计算当前行可用的列位置（二进制位为1表示可用）
            // 1. (columns | diagonals1 | diagonals2)：合并所有冲突位（1表示不可用）
            // 2. ~(...)：取反后，1表示可用位置（但高位可能有1，需要过滤）
            // 3. (1 << n) - 1：生成低n位全为1的掩码（例如n=4时为0b1111），用于过滤高位无效位
            // 最终：availablePositions的二进制中，1的位置是当前行可放皇后的列
            int availablePositions = ((1 << n) - 1) & (~(columns | diagonals1 | diagonals2));
            
            // 循环处理当前行的每个可用位置
            while (availablePositions != 0) {
                // 提取availablePositions中最低位的1（获取当前行可放置皇后的一个列）
                // 例如availablePositions=0b1010时，position=0b0010
                int position = availablePositions & (-availablePositions);
                
                // 移除availablePositions中最低位的1（处理完一个位置，继续下一个）
                // 例如availablePositions=0b1010 → 0b1000
                availablePositions = availablePositions & (availablePositions - 1);
                
                // 递归处理下一行，并累加解的数量
                // 更新冲突标记：
                // 1. columns | position：将当前列标记为冲突（列冲突）
                // 2. (diagonals1 | position) << 1：主对角线冲突标记左移1位（下一行的主对角线冲突位置会左移）
                // 3. (diagonals2 | position) >> 1：副对角线冲突标记右移1位（下一行的副对角线冲突位置会右移）
                count += solve(n, row + 1, columns | position, (diagonals1 | position) << 1, (diagonals2 | position) >> 1);
            }
            
            return count; // 返回当前行开始的有效布局总数
        }
    }
}
```

**<font color=red>核心思路：</font>** 
- 用一个methods数组记录每一行的列号
- 针对每一行进行回溯操作

#### 6、括号生成

**题目链接**
[LeetCode No.22](https://leetcode.cn/problems/generate-parentheses/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {

    List<String> result = new ArrayList<>();

    public List<String> generateParenthesis(int n) {
        int leftNum = n, rightNum = n;
        String cur = "";
        backtracking(leftNum, rightNum, cur);
        return result;
    }

    private void backtracking(int leftNum, int rightNum, String cur) {
        StringBuilder sb = new StringBuilder(cur);
        if (leftNum == 0) {
            while (rightNum != 0) {
                sb.append(")");
                -- rightNum;
            }
            result.add(sb.toString());
            return;
        }
        if (leftNum >= rightNum) {
            sb.append("(");
            backtracking(leftNum-1, rightNum, sb.toString());
        } else {
            sb.append("(");
            backtracking(leftNum-1, rightNum, sb.toString());
            sb.deleteCharAt(sb.length()-1);
            sb.append(")");
            backtracking(leftNum, rightNum-1, sb.toString());
        }
    }
}
```

**<font color=red>核心思路：</font>** 
- 记录左右括号的剩余数量，若全是右括号则全部加入并输出，否则回溯加入左/右括号的过程

#### 7、单词搜索

**题目链接**
[LeetCode No.79](https://leetcode.cn/problems/word-search/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {

    private boolean valid = false;

    private int[][] dirs = new int[][]{ {0,1},{-1,0},{0,-1},{1,0}};

    public boolean exist(char[][] board, String word) {
        for (int i = 0; i < board.length; ++ i)
            for (int j = 0; j < board[0].length; ++ j) {
                backtracking(board, i, j, word, 0);
                if (valid)
                    return valid;
            }
        return valid;
    }

    private void backtracking(char[][] board, int x, int y, String word, int index) {
        if (index == word.length()) {
            valid = true;
            return;
        }
        if (board.length == 1 && word.length() == 1) {
            valid = board[0][0] == word.charAt(0) ? true : false;
            return;
        }
        for (int i = 0; i < 4; ++ i) {
            int nextx = x + dirs[i][0], nexty = y + dirs[i][1];
            if (nextx >= 0 && nexty >= 0 && nextx < board.length && nexty < board[0].length && board[nextx][nexty] == word.charAt(index)) {
                board[nextx][nexty] = '#';
                backtracking(board, nextx, nexty, word, index+1);
                board[nextx][nexty] = word.charAt(index);
            }
        }
    }
}
```

**<font color=red>核心思路：</font>** 
- 遍历每一个字母位置，并在每一个字母处进行回溯判断是否能组成当前单词

### 十五、分治

#### 1、将有序数组转换为二叉搜索树

**题目链接**
[LeetCode No.108](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        int left = 0, right = nums.length-1;
        return build(nums, left, right);
    }

    private TreeNode build(int[] nums, int left, int right) {
        if (left > right)
            return null;
        int middle = (left + right) / 2;
        TreeNode root = new TreeNode(nums[middle]);
        root.left = build(nums, left, middle-1);
        root.right = build(nums, middle+1, right);
        return root;
    }
}
```

**<font color=red>核心思路：</font>** 
- 构建的时候传入当前需要构建数组的左右侧边界以及整个构建数组

#### 2、排序链表

**题目链接**
[LeetCode No.148](https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {
    public ListNode sortList(ListNode head) {
        return sort(head, null);
    }

    private ListNode sort(ListNode head, ListNode tail) {
        if (head == null)
            return head;
        if (head.next == tail) {
            head.next = null;
            return head;
        }

        ListNode slow = head, fast = head;
        while (fast != tail) {
            slow = slow.next;
            fast = fast.next;
            if (fast != tail)
                fast = fast.next;
        }
        ListNode mid = slow;
        ListNode list1 = sort(head, mid);
        ListNode list2 = sort(mid, tail);
        return merge(list1, list2);
    }

    private ListNode merge(ListNode head1, ListNode head2) {
        ListNode dummyHead = new ListNode(0);
        ListNode temp = dummyHead, temp1 = head1, temp2 = head2;
        while (temp1 != null && temp2 != null) {
            if (temp1.val <= temp2.val) {
                temp.next = temp1;
                temp1 = temp1.next;
            } else {
                temp.next = temp2;
                temp2 = temp2.next;
            }
            temp = temp.next;
        }
        if (temp1 != null) {
            temp.next = temp1;
        } else if (temp2 != null) {
            temp.next = temp2;
        }
        return dummyHead.next;
    }
}
```

**<font color=red>核心思路：</font>** 
- 使用快慢指针定位到链表中间，将链表分为两端，将两端链表分别进行先排序后合并。

#### 3、简建立叉树

**题目链接**
[LeetCode No.427](https://leetcode.cn/problems/construct-quad-tree/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {
    public Node construct(int[][] grid) {
        int n = grid.length;
        return build(0, 0, n, n, grid);
    }

    private Node build(int x1, int y1, int x2, int y2, int[][] grid) {
        if (x2 <= x1 && y2 <= y1)
            return null;
        boolean value = grid[x1][y1] == 1 ? true : false;
        if (x1 == x2-1 && y1 == y2-1)
            return new Node(value, true);
        boolean flag = true;
        for (int i = x1; i < x2; ++ i) {
            for (int j = y1; j < y2; ++ j) {
                boolean temp = grid[i][j] == 1 ? true : false;
                if (temp != value) {
                    flag = false;
                    break;
                }
            }
            if (flag == false)
                break;
        }
        if (flag == true)
            return new Node(value, true);
        Node root = new Node(false, false);
        int xmid = x1 + (x2-x1) / 2, ymid = y1 + (y2-y1) / 2;
        root.topLeft = build(x1, y1, xmid, ymid, grid);
        root.topRight = build(x1, ymid, xmid, y2, grid);
        root.bottomLeft = build(xmid, y1, x2, ymid, grid);
        root.bottomRight = build(xmid, ymid, x2, y2, grid);
        return root;
    }
}
```

**<font color=red>核心思路：</font>** 
- 递归实现四个节点的计算，使用x1 + (x2 - x1)/2 的方法计算出当前x或y的中间值

#### 4、合并k个升序队列

**题目链接**
[LeetCode No.23](https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        int len = lists.length;
        return merge(lists, 0, len);
    }

    private ListNode merge(ListNode[] lists, int left, int right) {
        if (left >= right)
            return null;
        else if (left == right-1)
            return lists[left];
        int mid = (left + right) / 2;
        ListNode leftHead = merge(lists, left, mid);
        ListNode rightHead = merge(lists, mid, right);
        ListNode dummy = new ListNode(-1), temp = dummy;
        while (leftHead != null && rightHead != null) {
            if (leftHead.val <= rightHead.val) {
                temp.next = leftHead;
                leftHead = leftHead.next;
            } else {
                temp.next = rightHead;
                rightHead = rightHead.next;
            }
            temp = temp.next;
        }
        if (leftHead == null)
            temp.next = rightHead;
        if (rightHead == null)
            temp.next = leftHead;
        return dummy.next;
    }
}
```

**<font color=red>核心思路：</font>** 
- 将链表list分为左侧和右侧两部分，递归合并操作，秒了

### 十六、kadane算法

#### 1、最大子数组和

**题目链接**
[LeetCode No.53](https://leetcode.cn/problems/maximum-subarray/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int maxSubArray(int[] nums) {
    int sum = 0, max = IntegerMIN_VALUE;
    for (int i = 0; i < nums.length;++ i) {
        sum += nums[i];
        max = Math.max(max, sum);
        if (sum < 0)
            sum = 0;
    }
    return max;
}
```

**<font color=red>核心思路：</font>** 
- 不断更新sum并同时记录最大值max，若sum为负数则重新开始记录sum

#### 2、环形子数组的最大和

**题目链接**
[LeetCode No.918](https://leetcode.cn/problems/maximum-sum-circular-subarray/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int maxSubarraySumCircular(int[] nums) {
    int n = nums.length;
    int[] leftMax = new int[n];
    leftMax[0] = nums[0];
    int leftSum = nums[0];
    int pre = nums[0];
    int res = nums[0];
    for (int i = 1; i < n; i++) {
        pre = Math.max(pre + nums[i], nums[i]);
        res = Math.max(res, pre);
        leftSum += nums[i];
        leftMax[i] = Math.max(leftMax[i - 1], leftSum);
    }
    int rightSum = 0;
    for (int i = n - 1; i > 0; i--) {
        rightSum += nums[i];
        res = Math.max(res, rightSum + leftMax[i - 1]);
    }
    return res;
}
```

**<font color=red>核心思路：</font>** 
- 本题分两种情况，1是从头到尾的最大值，2是从中间跨过尾再到头的最大值
- 遍历两次，第一次计算情况1的最大值 与 情况2中后半部分的最大值数组；第二次遍历计算情况2中前半部分的最大值数组，并每次都与第一次遍历计算的结果相对比

### 十七、二分查找

#### 1、搜索插入位置

**题目链接**
[LeetCode No.35](https://leetcode.cn/problems/search-insert-position/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int middle = (left + right) / 2;
            if (nums[middle] < target) {
                left = middle + 1;
            } else if (nums[middle] > target) {
                right = middle - 1;
            } else
                return middle;
        }
        return left;
    }
}
```

**<font color=red>核心思路：</font>** 
- 使用闭区间实现二分查找，变更边界的时候不包含原有边界

#### 2、搜索二维矩阵

**题目链接**
[LeetCode No.74](https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public boolean searchMatrix(int[][] matrix, int target) {
    int row = matrix.length, col = matrix[0].length;
    int up = 0, down = row-1, left = 0, right = col-1;
    int rowNum = 0;
    while (up <= down) {
        int mid = (up + down) >> 1;
        if (matrix[mid][0] > target)
            down = mid -1;
        else if (matrix[mid][col-1] < target)
            up = mid + 1;
        else {
            rowNum = mid;
            break;
        }
    }
    while (left <= right) {
        int mid = (left + right) >> 1;
        if (matrix[rowNum][mid] > target)
            right = mid - 1;
        else if (matrix[rowNum][mid] < target)
            left = mid + 1;
        else
            return true;
    }
    return false;
}
```

**<font color=red>核心思路：</font>** 
- 两次二分查找，第一次查找对应行，第二次查找对应列

#### 3、寻找峰值

**题目链接**
[LeetCode No.162](https://leetcode.cn/problems/find-peak-element/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int left=0,right=nums.length-1;
        while(left<right){
            int mid = (left+right)/2;
            if(nums[mid]>nums[mid+1]){  
//说明此时mid为下坡路，那么有可能自己本身就是山峰，或者在下山的过程中，所以right=mid而不能等于mid-1
                right = mid;
            }else{
                left = mid+1; 
//反之说明此时mid为上坡路，既然是上坡，那么mid肯定不是山峰，所以left=mid+1（题目要求nums[i]!=nums[i+1]，所以不可能存在“平峰”的情况）
            }
        }
        return left;
    }
}
```

**<font color=red>核心思路：</font>**
- 一直往高出走就能找到山峰，因为nums[-1] = nums[n] = -∞。
- 二分查找，不断对比中值与右侧的大小，有两种可能性——可能性1：若当前mid比右侧小，则右侧一定会有山峰但不可能是mid，因此将left更新为mid+1；可能性2：若当前mid比右侧大，则左侧包括mid自己都有可能是山峰，因此将right更新为mid。这样范围缩小到最后一个的时候肯定是山峰了

#### 4、搜索旋转排序数组

**题目链接**
[LeetCode No.33](https://leetcode.cn/problems/search-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {
    public int search(int[] nums, int target) {
        int len = nums.length;
        if (len == 0)
            return -1;
        if (len == 1)
            return nums[0] == target ? 0 : -1;
        int left = 0, right = len - 1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (nums[mid] == target)
                return mid;
            if (nums[0] <= nums[mid]) {
                // 左侧局部有序
                if (nums[0] <= target && target < nums[mid])
                    right = mid - 1;
                else
                    left = mid + 1;

            } else {
                // 右侧局部有序
                if (nums[mid] < target && target <= nums[len-1])
                    left = mid + 1;
                else
                    right = mid - 1;
            }
        }
        return -1;
    }
}
```

**<font color=red>核心思路：</font>** 
- 从中间分开数组的时候，一定有一部分数组是有序的，可能是左侧也可能是右侧
- 因此，这也有两种可能：1 左侧局部有序，此时判断nums[mid]是否在左侧区间内，若在则将右边界放到mid-1处，若不在则将左边界放到mid+1处。2 左侧局部无序则右侧局部有序，此时判断nums[mid]是否在右侧区间内，等等判断逻辑。

#### 5、在排序数组中查找元素的第一个和最后一个位置

**题目链接**
[LeetCode No.34](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int[] searchRange(int[] nums, int target) {
    int left = 0, right = nums.length-1;
    int loc = -1;
    while (left <= right) {
        int mid = (left + right) >> 1;
        if (nums[mid] < target)
            left = mid + 1;
        else if (nums[mid] > target)
            right = mid - 1;
        else {
            loc = mid;
            break;
        }
    }
    if (loc == -1)
        return new int[]{-1, -1};
    int leftLoc = loc, rightLoc = loc;
    while (leftLoc >= 0 && nums[leftLoc] == target)
        -- leftLoc;
    while (rightLoc < nums.length && nums[rightLoc] == target)
        ++ rightLoc;
    return new int[]{leftLoc+1, rightLoc-1};
}
```

**<font color=red>核心思路：</font>** 
- 先用二分法找到值为target的位置，再向左右扩展寻找范围

#### 6、寻找旋转排序数组中的最小值

**题目链接**
[LeetCode No.153](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int findMin(int[] nums) {
    int len = nums.length;
    int left = 0, right = len-1;
    while (left < right) {
        int mid = (left + right) >> 1;
        if (nums[mid] < nums[right])
            right = mid;
        else
            left = mid + 1;
    }
    return nums[left];
}
```

**<font color=red>核心思路：</font>** 
- 二分查找，找到左右两部分中非顺序的部分并继续二分查找。
- 若mid值小于right则右侧正常，右侧边界向左移动至mid处
- 若mid值大于等于right则左侧正常但不包括mid，左侧边界向右移动至mid+1处
- 最终left和right会重合

#### 7、寻找两个正序数组的中位数

**题目链接**
[LeetCode No.4](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        if (totalLength % 2 == 1) {
            int midIndex = totalLength / 2;
            double median = getKthElement(nums1, nums2, midIndex + 1);
            return median;
        } else {
            int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
            double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
            return median;
        }
    }

    private int getKthElement(int[] nums1, int[] nums2, int k) {
        int length1 = nums1.length, length2 = nums2.length;
        int index1 = 0, index2 = 0;
        int kthElement = 0;

        while (true) {
            if (index1 == length1)
                return nums2[index2+k-1];
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }

            int half = k/2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int bound1 = nums1[newIndex1], bound2 = nums2[newIndex2];
            if (bound1 <= bound2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2+ 1);
                index2 = newIndex2 + 1;
            }
        }
    }
}
```

**<font color=red>核心思路：</font>** 
- 求得中位数前的位数k，每次将nums1和nums2的指针向前移动k/2个位置，并比较两指针的数值大小。将小的那部分前面的值全部舍弃，并在k的基础上减去k/2，并继续计算。直到有一侧的数组边界到顶（中位数为另一侧数组的当前指针值）或k值为1（中位数为两侧数组指针出值的较小者）

### 十八、堆

#### 1、数组中的第K个最大元素

**题目链接**
[LeetCode No.](https://leetcode.cn/problems/kth-largest-element-in-an-array/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 使用PriorityQueue
public int findKthLargest(int[] nums, int k) {
    // 小顶堆，仅保留前k大的元素，堆顶即为第k大
    PriorityQueue<Integer> heap = new PriorityQueue<>(k);
    for (int num : nums) {
        heap.add(num);
        if (heap.size() > k) {
            heap.poll(); // 超过k个元素时，移除最小的（堆顶）
        }
    }
    return heap.peek();
}

// 使用stream流
public int findKthLargest(int[] nums, int k) {
    return Arrays.stream(nums)
    .boxed()
    .sorted((a,b) -> Integer.compare(b,a))
    .skip(k-1)
    .findFirst()
    .get();
}

// 使用TreeMap
public int findKthLargest(int[] nums, int k) {
    // TreeMap默认按键升序排序
    TreeMap<Integer, Integer> countMap = new TreeMap<>();
    // 统计每个元素的出现次数
    for (int num : nums) {
        countMap.put(num, countMap.getOrDefault(num, 0) + 1);
    }
    
    int count = 0;
    // 逆序遍历键（从大到小）
    Set<Integer> descendingKeys = countMap.descendingKeySet();
    for (int key : descendingKeys) {
        count += countMap.get(key);
        // 累计次数达到k时，当前键即为第k个最大元素
        if (count >= k) {
            return key;
        }
    }
    
    return -1; // 理论上不会执行到此处（输入合法时）
}

// 快速排序
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickSelect(nums, 0, nums.length-1, k-1);
    }

    private int quickSelect(int[] nums, int left, int right, int k) {
        int leftBorder = left, rightBorder = right;
        int pivot = nums[left];
        while (left < right) {
            while (left < right && nums[right] <= pivot)
                -- right;
            nums[left] = nums[right];
            while (left < right && nums[left] >= pivot)
                ++ left;
            nums[right] = nums[left];
        }
        nums[left] = pivot;
        if (left == k)
            return nums[left];
        else if (k < left)
            return quickSelect(nums, leftBorder, left-1, k);
        else
            return quickSelect(nums, left+1, rightBorder, k);
    }
}

// 堆排序
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize = nums.length;
        buildMaxHeap(nums, heapSize);
        for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {
            swap(nums, 0, i);
            --heapSize;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }

    public void buildMaxHeap(int[] a, int heapSize) {
        for (int i = heapSize / 2 - 1; i >= 0; --i) {
            maxHeapify(a, i, heapSize);
        } 
    }

    public void maxHeapify(int[] a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        } 
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a, i, largest);
            maxHeapify(a, largest, heapSize);
        }
    }

    public void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

**<font color=red>核心思路：</font>** 
- 经典题目，可以用多种方法实现

### 十九、位运算

#### 1、二进制求和

**题目链接**
[LeetCode No.67](https://leetcode.cn/problems/add-binary/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder sb = new StringBuilder();
        int ca = 0;
        for (int i = a.length()-1, j = b.length()-1; i >= 0 || j >= 0; --i, --j) {
            int sum = ca;
            sum += i >= 0 ? a.charAt(i) - '0' : 0;
            sum += j >= 0 ? b.charAt(j) - '0' : 0;
            sb.append(sum % 2);
            ca = sum / 2;
        }
        sb.append(ca == 1 ? ca : "");
        return sb.reverse().toString();
    }
}
```

**<font color=red>核心思路：</font>** 
- 倒叙遍历两个字符串，最后reverse得到结果
- 在reverse之前若左后进位>0则再添加为最后一位数

#### 2、颠倒二进制位

**题目链接**
[LeetCode No.190](https://leetcode.cn/problems/reverse-bits/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int reverseBits(int n) {
    int rev = 0;
    for (int i = 0; i < 32 && n != 0; ++ i) {
        rev |= (n & 1) << (31 - i);
        n >>>= 1;
    }
    return rev;
}
```

**<font color=red>核心思路：</font>** 
- 使用二进制位运算的方法，将n与1取余获取最低位的值，将这个值向左侧移动到对应位置后，将值更新到rev中，最后将n向右使用无符号的右移

#### 3、位1的个数

**题目链接**
[LeetCode No.191](https://leetcode.cn/problems/number-of-1-bits/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 直接转换为二进制字符串
public int hammingWeight(int n) {
    String binaryStr = Integer.toBinaryString(n);
    int count = 0;
    for (int i = 0; i < binaryStr.length(); ++ i)
        if (binaryStr.charAt(i) == '1')
            ++ count;
    return count;
}

// 位运算
public int hammingWeight(int n) {
    int ret = 0;
    for (int i = 0; i < 32; ++ i)
        if ((n & (1 << i)) != 0)
            ++ ret;
    return ret;
}
```

**<font color=red>核心思路：</font>** 
- 从第一位数一直到最后一位数做&操作判断是否为1，若是1则累加数量

#### 4、只出现一次的数字

**题目链接**
[LeetCode No.136](https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int singleNumber(int[] nums) {
    int single = 0;
    for (int num : nums)
        single ^= num;
    return single;
}
```

**<font color=red>核心思路：</font>** 
- 使用异或运算，因为异或运算存在交换律和结合律，两两相等的数最终会成为0，而任何数与0做异或运算都会得到原来的数

#### 5、只出现一次的数字Ⅱ

**题目链接**
[LeetCode No.137](https://leetcode.cn/problems/single-number-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int singleNumber(int[] nums) {
    int res = 0;
    for (int i = 0; i < 32; ++ i) {
        int total = 0;
        for (int num : nums)
            total += ((num >> i) & 1);
        if (total % 3 != 0)
            res |= (1 << i);
    }
    return res;
}
```

**<font color=red>核心思路：</font>** 
- 统计32位中每一位中在所有数值里1的数量，如果数量能被3整除，则唯一值在这个位数是0，不做操作。若数量不能被3整除，则唯一值在这个位数是1，将其写入。

#### 6、数字范围按位与

**题目链接**
[LeetCode No.201](https://leetcode.cn/problems/bitwise-and-of-numbers-range/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int rangeBitwiseAnd(int left, int right) {
    int shift = 0;
    while (left < right) {
        left >>= 1;
        right >>= 1;
        ++ shift;
    }
    return left << shift;
}
```

**<font color=red>核心思路：</font>** 
- 将头尾两数同时向右移动直到两数相等，记录移动次数（可以理解成left和right分别向中间逼近直到相遇）
- 两数相等后再同时向左移动

### 二十、数学

#### 1、回文数

**题目链接**
[LeetCode No.9](https://leetcode.cn/problems/palindrome-number/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 使用字符串
public boolean isPalindrome(int x) {
    String num = String.valueOf(x);
    int left = 0, right = num.length()-1;
    while (left <= right) {
        if (num.charAt(left) != num.charAt(right))
            return false;
        ++ left;
        -- right;
    }
    return true;
}

// 使用reverse数
public boolean isPalindrome(int x) {
    if (x % 10 == 0 && x != 0)
        return false;
    int reverse = 0;
    while (reverse < x) {
        reverse = reverse*10 + x%10;
        x /= 10;
    }
    return reverse == x || reverse/10 == x;
}
```

**<font color=red>核心思路：</font>** 
- 构造一个反向数组或直接使用字符串

#### 2、加一

**题目链接**
[LeetCode No.66](https://leetcode.cn/problems/plus-one/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int[] plusOne(int[] digits) {
    int len = digits.length;
    for (int i = len-1; i >= 0; -- i) {
        if (digits[i] != 9) {
            ++ digits[i];
            for (int j = i+1; j < len; ++ j)
                digits[j] = 0;
            return digits;
        }
    }
    int[] res = new int[len+1];
    res[0] = 1;
    return res;
}
```

**<font color=red>核心思路：</font>** 
- 若碰到连续的9则将后面所有的数都置0，否则加一后直接返回
- 若值为99...9，则新建一个数组并将0位置置为1

#### 3、阶乘后的零

**题目链接**
[LeetCode No.172](https://leetcode.cn/problems/factorial-trailing-zeroes/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 求5的数量
public int trailingZeroes(int n) {
    int count5 = 0;
    for (int i = 1; i <= n; ++ i)
        if (i % 5 == 0) {
            int num = i;
            while (num % 5 == 0 && num != 0) {
                ++ count5;
                num /= 5;
            }
        }
    return count5;
}

// 优化
public int trailingZeroes(int n) {
    int ans = 0;
    while (n > 0) {
        // 循环 k 次后，n 变成了 floor(n/5^k)
        n /= 5;
        ans += n;
    }
    return ans;
}
```

**<font color=red>核心思路：</font>** 
- 累加5的各次幂的倍数数量

#### 4、x的平方根

**题目链接**
[LeetCode No.69](https://leetcode.cn/problems/sqrtx/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 计算器方法
public int mySqrt(int x) {
    if (x == 0) {
        return 0;
    }
    int ans = (int) Math.exp(0.5 * Math.log(x));
    return (long) (ans + 1) * (ans + 1) <= x ? ans + 1 : ans;
}

// 二分查找法
public int mySqrt(int x) {
    int l = 0, r = x, ans = -1;
    while (l <= r) {
        int mid = (l+r) / 2;
        if ((long) mid * mid <= x) {
            ans = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return ans;
}

```

**<font color=red>核心思路：</font>** 
- 根号可以通过ln化解，模拟计算器直接实现
- 可以通过二分查找的方式，不断找到中位数并比较中位数的平方和x值的大小并不断更新区间

#### 5、Pow(x,n)

**题目链接**
[LeetCode No.50](https://leetcode.cn/problems/powx-n/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {
    public double myPow(double x, int n) {
        long N = n;
        return N >= 0 ? quickMi(x, N) : 1.0 / quickMi(x, -N);
    }

    private double quickMi(double x, long N) {
        if (N == 0)
            return 1.0;
        double y = quickMi(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }
}
```

**<font color=red>核心思路：</font>** 
- 快速幂，使用二分法将乘积递归执行

#### 6、直线上最多的点

**题目链接**
[LeetCode No.149](https://leetcode.cn/problems/max-points-on-a-line/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
class Solution {
    public int maxPoints(int[][] points) {
        int n = points.length;
        if (n <= 2) {
            return n;
        }
        int ret = 0;
        for (int i = 0; i < n; i++) {
            if (ret >= n - i || ret > n / 2) {
                break;
            }
            Map<Integer, Integer> map = new HashMap<Integer, Integer>();
            for (int j = i + 1; j < n; j++) {
                int x = points[i][0] - points[j][0];
                int y = points[i][1] - points[j][1];
                if (x == 0) {
                    y = 1;
                } else if (y == 0) {
                    x = 1;
                } else {
                    if (y < 0) {
                        x = -x;
                        y = -y;
                    }
                    int gcdXY = gcd(Math.abs(x), Math.abs(y));
                    x /= gcdXY;
                    y /= gcdXY;
                }
                int key = y + x * 20001;
                map.put(key, map.getOrDefault(key, 0) + 1);
            }
            int maxn = 0;
            for (Map.Entry<Integer, Integer> entry: map.entrySet()) {
                int num = entry.getValue();
                maxn = Math.max(maxn, num + 1);
            }
            ret = Math.max(ret, maxn);
        }
        return ret;
    }

    public int gcd(int a, int b) {
        return b != 0 ? gcd(b, a % b) : a;
    }
}
```

**<font color=red>核心思路：</font>** 
- 使用一个Map存储所有可能结果以及其中点的个数，并最终将返回最大的个数值

### 二十一、一维动态规划

#### 1、爬楼梯

**题目链接**
[LeetCode No.70](https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int climbStairs(int n) {
    if ( n <=2 )
        return n;
    int[] dp = new int[n+1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i < n+1; ++ i)
        dp[i] = dp[i-1] + dp[i-2];
    return dp[n];
}
```

**<font color=red>核心思路：</font>** 
- dp[i]表示爬到第i层的方法数
- dp[i] = dp[i-1] + dp[i-2]

#### 2、打家劫舍

**题目链接**
[LeetCode No.198](https://leetcode.cn/problems/house-robber/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
// 二维数组版本
public int rob(int[] nums) {
    int len = nums.length;
    int[][] dp = new int[len][2]; // [0]表示打，[1]表示不打
    dp[0][0] = 0;
    dp[0][1] = nums[0];
    for (int i = 1; i < len; ++ i) {
        dp[i][0] = dp[i-1][1];
        dp[i][1] = Math.max(dp[i-1][0]+nums[i], dp[i-1][1]);
    }
    return Math.max(dp[len-1][0], dp[len-1][1]);
}

//一维数组版本
public int rob(int[] nums) {
    int len = nums.length;
    int[] dp = new int[len];
    dp[0] = nums[0];
    if (len > 1)
        dp[1] = Math.max(nums[0], nums[1]);
    else
        return dp[0];
    for (int i = 2; i < len; ++ i)
        dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
    return dp[len-1];
}
```

**<font color=red>核心思路：</font>** 
- dp[i]代表经过了第i家人后手里最多的财富
- dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i])

#### 3、单词拆分

**题目链接**
[LeetCode No.](https://leetcode.cn/problems/word-break/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public boolean wordBreak(String s, List<String> wordDict) {
    boolean[] dp = new boolean[s.length()+1];
    dp[0] = true;
    for (int i = 1; i <= s.length(); ++ i)
        for (String word : wordDict) {
            int len = word.length();
            if (i >= len && dp[i-len] && word.equals(s.substring(i-len, i))) {
                dp[i] = true;
                break;
            }
        }
    return dp[s.length()];
}
```

**<font color=red>核心思路：</font>** 
- dp[i]是前i个字符是否可以被wordDict组成
- 遍历所有字符，每次都遍历一遍wordDick，判断当前遍历到的和先前为true的字符之间组成的单词是否存在于wordDict中，若存在则当前遍历到的位置为true

#### 4、零钱兑换

**题目链接**
[LeetCode No.322](https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java
public int coinChange(int[] coins,int amount) {
    int[] dp = new int[amount+1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    for (int i = 0; i < coins.length; ++ i)
        for (int j = coins[i]; j <= amount; ++ j)
            if (dp[j - coins[i]] != Integer.MAX_VALUE)
                dp[j] = Math.min(dp[j], dp[j-coins[i]]+1);
    return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
}
```

**<font color=red>核心思路：</font>** 
- 完全背包问题，零钱价值为物品，总价值为背包大小。
- 先遍历零钱（物品），在从当前价值的最小值处开始遍历背包，在当前d[i-coins[j]]有值的时候，dp[j] = min(dp[j-coins[i]]-1, dp[j])

#### 5、最长递增子序列

**题目链接**
[LeetCode No.300](https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-interview-150)

**核心代码**：

```java

```

**<font color=red>核心思路：</font>** 
- 