# é¢è¯•ç»å…¸150é¢˜

---

## ğŸ“‘ ç›®å½•
- [é¢è¯•ç»å…¸150é¢˜](#é¢è¯•ç»å…¸150é¢˜)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
    - [ä¸€ã€æ•°ç»„/å­—ç¬¦ä¸²](#ä¸€æ•°ç»„å­—ç¬¦ä¸²)
      - [1ã€åˆå¹¶ä¸¤ä¸ªæœ‰åºå…ƒç´ ](#1åˆå¹¶ä¸¤ä¸ªæœ‰åºå…ƒç´ )
      - [2ã€ç§»é™¤å…ƒç´ ](#2ç§»é™¤å…ƒç´ )
      - [3ã€åˆ é™¤æœ‰åºæ•°ç»„çš„é‡å¤é¡¹](#3åˆ é™¤æœ‰åºæ•°ç»„çš„é‡å¤é¡¹)
      - [4ã€åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹2](#4åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹2)
      - [5ã€å¤šæ•°å…ƒç´ ](#5å¤šæ•°å…ƒç´ )
      - [6ã€è½®è½¬æ•°ç»„](#6è½®è½¬æ•°ç»„)
      - [7ã€ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº](#7ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº)
      - [8ã€ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº2](#8ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº2)
      - [9ã€è·³è·ƒæ¸¸æˆ](#9è·³è·ƒæ¸¸æˆ)
      - [10ã€è·³è·ƒæ¸¸æˆ2](#10è·³è·ƒæ¸¸æˆ2)
      - [11ã€HæŒ‡æ•°](#11hæŒ‡æ•°)
      - [12ã€O(1)æ—¶é—´æ’å…¥åˆ é™¤å’Œè·å–éšæœºå…ƒç´ ](#12o1æ—¶é—´æ’å…¥åˆ é™¤å’Œè·å–éšæœºå…ƒç´ )
      - [13ã€é™¤è‡ªèº«ä»¥å¤–æ•°ç»„çš„ä¹˜ç§¯](#13é™¤è‡ªèº«ä»¥å¤–æ•°ç»„çš„ä¹˜ç§¯)
      - [14ã€åŠ æ²¹ç«™](#14åŠ æ²¹ç«™)
      - [15ã€åˆ†å‘ç³–æœ](#15åˆ†å‘ç³–æœ)
      - [16ã€æ¥é›¨æ°´](#16æ¥é›¨æ°´)
      - [17ã€ç½—é©¬æ•°å­—è½¬æ•´æ•°](#17ç½—é©¬æ•°å­—è½¬æ•´æ•°)
      - [18ã€æ•´æ•°è½¬ç½—é©¬æ•°å­—](#18æ•´æ•°è½¬ç½—é©¬æ•°å­—)
      - [19ã€æœ€åä¸€ä¸ªå•è¯çš„é•¿åº¦](#19æœ€åä¸€ä¸ªå•è¯çš„é•¿åº¦)
      - [20ã€æœ€é•¿å…¬å…±å‰ç¼€](#20æœ€é•¿å…¬å…±å‰ç¼€)
      - [21ã€åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯](#21åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯)
      - [22ã€Zå­—å½¢å˜æ¢ï¼ˆè¦å†å»çœ‹ï¼‰](#22zå­—å½¢å˜æ¢è¦å†å»çœ‹)
      - [23ã€æ‰¾å‡ºå­—ç¬¦ä¸²ä¸­ç¬¬ä¸€ä¸ªåŒ¹é…çš„ä¸‹æ ‡](#23æ‰¾å‡ºå­—ç¬¦ä¸²ä¸­ç¬¬ä¸€ä¸ªåŒ¹é…çš„ä¸‹æ ‡)
      - [24ã€æ–‡æœ¬å·¦å³å¯¹é½](#24æ–‡æœ¬å·¦å³å¯¹é½)
    - [äºŒã€åŒæŒ‡é’ˆ](#äºŒåŒæŒ‡é’ˆ)
      - [1ã€éªŒè¯å›æ–‡ä¸²](#1éªŒè¯å›æ–‡ä¸²)
      - [2ã€åˆ¤æ–­å­åºåˆ—](#2åˆ¤æ–­å­åºåˆ—)
      - [3ã€ä¸¤æ•°ä¹‹å’Œâ…¡-è¾“å…¥æœ‰åºæ•°ç»„](#3ä¸¤æ•°ä¹‹å’Œâ…±-è¾“å…¥æœ‰åºæ•°ç»„)
      - [4ã€ç››æœ€å¤šæ°´çš„å®¹å™¨](#4ç››æœ€å¤šæ°´çš„å®¹å™¨)
      - [5ã€ä¸‰æ•°ä¹‹å’Œ](#5ä¸‰æ•°ä¹‹å’Œ)
    - [ä¸‰ã€æ»‘åŠ¨çª—å£](#ä¸‰æ»‘åŠ¨çª—å£)
      - [1ã€é•¿åº¦æœ€å°çš„å­æ•°ç»„](#1é•¿åº¦æœ€å°çš„å­æ•°ç»„)
      - [2ã€æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²](#2æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²)
      - [3ã€ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²](#3ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²)
      - [4ã€æœ€å°è¦†ç›–å­ä¸²](#4æœ€å°è¦†ç›–å­ä¸²)
      - [1ã€æœ‰æ•ˆçš„æ•°ç‹¬](#1æœ‰æ•ˆçš„æ•°ç‹¬)
      - [2ã€èºæ—‹çŸ©é˜µ](#2èºæ—‹çŸ©é˜µ)
      - [3ã€æ—‹è½¬å›¾åƒ](#3æ—‹è½¬å›¾åƒ)
      - [4ã€çŸ©é˜µç½®é›¶](#4çŸ©é˜µç½®é›¶)
      - [5ã€ç”Ÿå‘½æ¸¸æˆ](#5ç”Ÿå‘½æ¸¸æˆ)
    - [å››ã€å“ˆå¸Œè¡¨](#å››å“ˆå¸Œè¡¨)
      - [1ã€èµé‡‘ä¿¡](#1èµé‡‘ä¿¡)
      - [2ã€åŒæ„å­—ç¬¦ä¸²](#2åŒæ„å­—ç¬¦ä¸²)
      - [3ã€å•è¯è§„å¾‹](#3å•è¯è§„å¾‹)
      - [4ã€æœ‰æ•ˆå­—æ¯çš„å¼‚ä½è¯](#4æœ‰æ•ˆå­—æ¯çš„å¼‚ä½è¯)
      - [5ã€å­—æ¯å¼‚ä½è¯åˆ†ç»„](#5å­—æ¯å¼‚ä½è¯åˆ†ç»„)
      - [6ã€ä¸¤æ•°ä¹‹å’Œ](#6ä¸¤æ•°ä¹‹å’Œ)
      - [7ã€å¿«ä¹æ•°](#7å¿«ä¹æ•°)
      - [8ã€å­˜åœ¨é‡å¤å…ƒç´ â…¡](#8å­˜åœ¨é‡å¤å…ƒç´ â…±)
      - [128ã€æœ€é•¿è¿ç»­åºåˆ—](#128æœ€é•¿è¿ç»­åºåˆ—)
    - [äº”ã€åŒºé—´](#äº”åŒºé—´)
      - [1ã€æ±‡æ€»åŒºé—´](#1æ±‡æ€»åŒºé—´)
      - [2ã€åˆå¹¶åŒºé—´](#2åˆå¹¶åŒºé—´)
      - [3ã€æ’å…¥åŒºé—´](#3æ’å…¥åŒºé—´)
      - [4ã€ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒ](#4ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒ)
    - [å…­ã€æ ˆ](#å…­æ ˆ)
      - [1ã€æœ‰æ•ˆçš„æ‹¬å·](#1æœ‰æ•ˆçš„æ‹¬å·)
      - [2ã€ç®€åŒ–è·¯å¾„](#2ç®€åŒ–è·¯å¾„)
      - [3ã€æœ€å°æ ˆ](#3æœ€å°æ ˆ)
      - [4ã€é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼](#4é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼)
      - [5ã€åŸºæœ¬è®¡ç®—å™¨](#5åŸºæœ¬è®¡ç®—å™¨)
    - [ä¸ƒã€é“¾è¡¨](#ä¸ƒé“¾è¡¨)
      - [1ã€ç¯å½¢é“¾è¡¨](#1ç¯å½¢é“¾è¡¨)
      - [2ã€ä¸¤æ•°ç›¸åŠ ](#2ä¸¤æ•°ç›¸åŠ )
      - [3ã€åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨](#3åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨)
      - [4ã€éšæœºé“¾è¡¨çš„å¤åˆ¶](#4éšæœºé“¾è¡¨çš„å¤åˆ¶)
      - [5ã€åè½¬é“¾è¡¨â…¡](#5åè½¬é“¾è¡¨â…±)
      - [6ã€Kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨](#6kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨)
      - [7ã€åˆ é™¤é“¾è¡¨å€’æ•°ç¬¬Nå“¥èŠ‚ç‚¹](#7åˆ é™¤é“¾è¡¨å€’æ•°ç¬¬nå“¥èŠ‚ç‚¹)
      - [8ã€åˆ é™¤é“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ ](#8åˆ é™¤é“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ )
      - [8ã€æ—‹è½¬é“¾è¡¨](#8æ—‹è½¬é“¾è¡¨)
      - [9ã€åˆ†éš”é“¾è¡¨](#9åˆ†éš”é“¾è¡¨)
      - [10ã€LRUç¼“å­˜](#10lruç¼“å­˜)
    - [å…«ã€äºŒå‰æ ‘](#å…«äºŒå‰æ ‘)
      - [1ã€äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](#1äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦)
      - [2ã€ç›¸åŒçš„æ ‘](#2ç›¸åŒçš„æ ‘)
      - [3ã€ç¿»è½¬äºŒå‰æ ‘](#3ç¿»è½¬äºŒå‰æ ‘)
      - [4ã€å¯¹ç§°äºŒå‰æ ‘](#4å¯¹ç§°äºŒå‰æ ‘)
      - [5ã€ä»å‰åºéå†ä¸ä¸­åºéå†æ„é€ äºŒå‰æ ‘](#5ä»å‰åºéå†ä¸ä¸­åºéå†æ„é€ äºŒå‰æ ‘)
      - [6ã€ä»ä¸­åºä¸åç»­éå†åºåˆ—æ„é€ äºŒå‰æ ‘](#6ä»ä¸­åºä¸åç»­éå†åºåˆ—æ„é€ äºŒå‰æ ‘)
      - [7ã€å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II](#7å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ-ii)
      - [8ã€äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨](#8äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨)
      - [9ã€è·¯å¾„æ€»å’Œ](#9è·¯å¾„æ€»å’Œ)
      - [10ã€æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ](#10æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ)
      - [11ã€äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](#11äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ)
      - [12ã€äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨](#12äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨)
      - [13ã€å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°](#13å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°)
      - [14ã€äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](#14äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ)
    - [ä¹ã€äºŒå‰æ ‘å±‚æ¬¡éå†](#ä¹äºŒå‰æ ‘å±‚æ¬¡éå†)
      - [1ã€äºŒå‰æ ‘çš„å³è§†å›¾](#1äºŒå‰æ ‘çš„å³è§†å›¾)
      - [2ã€äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼](#2äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼)
      - [3ã€äºŒå‰æ ‘çš„å±‚åºéå†](#3äºŒå‰æ ‘çš„å±‚åºéå†)
      - [4ã€äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†](#4äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†)
    - [åã€äºŒå‰æœç´¢æ ‘](#åäºŒå‰æœç´¢æ ‘)
      - [1ã€äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®](#1äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®)
      - [2ã€äºŒå‰æœç´¢æ ‘ä¸­ç¬¬ K å°çš„å…ƒç´ ](#2äºŒå‰æœç´¢æ ‘ä¸­ç¬¬-k-å°çš„å…ƒç´ )
      - [3ã€éªŒè¯äºŒå‰æœç´¢æ ‘](#3éªŒè¯äºŒå‰æœç´¢æ ‘)
    - [åä¸€ã€å›¾](#åä¸€å›¾)
      - [1ã€å²›å±¿æ•°é‡](#1å²›å±¿æ•°é‡)
      - [2ã€è¢«å›´ç»•çš„åŒºåŸŸ](#2è¢«å›´ç»•çš„åŒºåŸŸ)
      - [3ã€å…‹éš†å›¾](#3å…‹éš†å›¾)
      - [4ã€é™¤æ³•æ±‚å€¼](#4é™¤æ³•æ±‚å€¼)
      - [5ã€è¯¾ç¨‹è¡¨](#5è¯¾ç¨‹è¡¨)
      - [6ã€è¯¾ç¨‹è¡¨â…¡](#6è¯¾ç¨‹è¡¨â…±)
    - [åäºŒã€å›¾çš„å¹¿åº¦ä¼˜å…ˆæœç´¢](#åäºŒå›¾çš„å¹¿åº¦ä¼˜å…ˆæœç´¢)
      - [1ã€è›‡å½¢æ£‹](#1è›‡å½¢æ£‹)
      - [2ã€æœ€å°åŸºå› å˜åŒ–](#2æœ€å°åŸºå› å˜åŒ–)
      - [3ã€å•è¯æ¥é¾™](#3å•è¯æ¥é¾™)
    - [åä¸‰ã€å­—å…¸æ ‘](#åä¸‰å­—å…¸æ ‘)
      - [1ã€å®ç°Trie](#1å®ç°trie)
      - [2ã€æ·»åŠ ä¸æœç´¢å•è¯ - æ•°æ®ç»“æ„è®¾è®¡](#2æ·»åŠ ä¸æœç´¢å•è¯---æ•°æ®ç»“æ„è®¾è®¡)
      - [3ã€å•è¯æœç´¢â…¡](#3å•è¯æœç´¢â…±)
    - [åå››ã€å›æº¯](#åå››å›æº¯)
      - [1ã€ç”µè¯å·ç çš„å­—æ¯ç»„åˆ](#1ç”µè¯å·ç çš„å­—æ¯ç»„åˆ)
      - [2ã€ç»„åˆ](#2ç»„åˆ)
      - [3ã€å…¨æ’åˆ—](#3å…¨æ’åˆ—)
      - [4ã€ç»„åˆæ€»å’Œ](#4ç»„åˆæ€»å’Œ)
      - [5ã€Nçš‡åâ…¡](#5nçš‡åâ…±)
      - [6ã€æ‹¬å·ç”Ÿæˆ](#6æ‹¬å·ç”Ÿæˆ)
      - [7ã€å•è¯æœç´¢](#7å•è¯æœç´¢)
    - [åäº”ã€åˆ†æ²»](#åäº”åˆ†æ²»)
      - [1ã€å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘](#1å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘)
      - [2ã€æ’åºé“¾è¡¨](#2æ’åºé“¾è¡¨)
      - [3ã€ç®€å»ºç«‹å‰æ ‘](#3ç®€å»ºç«‹å‰æ ‘)
      - [4ã€åˆå¹¶kä¸ªå‡åºé˜Ÿåˆ—](#4åˆå¹¶kä¸ªå‡åºé˜Ÿåˆ—)
    - [åå…­ã€kadaneç®—æ³•](#åå…­kadaneç®—æ³•)
      - [1ã€æœ€å¤§å­æ•°ç»„å’Œ](#1æœ€å¤§å­æ•°ç»„å’Œ)
      - [2ã€ç¯å½¢å­æ•°ç»„çš„æœ€å¤§å’Œ](#2ç¯å½¢å­æ•°ç»„çš„æœ€å¤§å’Œ)
    - [åä¸ƒã€äºŒåˆ†æŸ¥æ‰¾](#åä¸ƒäºŒåˆ†æŸ¥æ‰¾)
      - [1ã€æœç´¢æ’å…¥ä½ç½®](#1æœç´¢æ’å…¥ä½ç½®)
      - [2ã€æœç´¢äºŒç»´çŸ©é˜µ](#2æœç´¢äºŒç»´çŸ©é˜µ)
      - [3ã€å¯»æ‰¾å³°å€¼](#3å¯»æ‰¾å³°å€¼)
      - [4ã€æœç´¢æ—‹è½¬æ’åºæ•°ç»„](#4æœç´¢æ—‹è½¬æ’åºæ•°ç»„)
      - [5ã€åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®](#5åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®)
      - [6ã€å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼](#6å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼)
      - [7ã€å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°](#7å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°)
    - [åå…«ã€å †](#åå…«å †)
      - [1ã€æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ ](#1æ•°ç»„ä¸­çš„ç¬¬kä¸ªæœ€å¤§å…ƒç´ )
    - [åä¹ã€ä½è¿ç®—](#åä¹ä½è¿ç®—)
      - [1ã€äºŒè¿›åˆ¶æ±‚å’Œ](#1äºŒè¿›åˆ¶æ±‚å’Œ)
      - [2ã€é¢ å€’äºŒè¿›åˆ¶ä½](#2é¢ å€’äºŒè¿›åˆ¶ä½)
      - [3ã€ä½1çš„ä¸ªæ•°](#3ä½1çš„ä¸ªæ•°)
      - [4ã€åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—](#4åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—)
      - [5ã€åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—â…¡](#5åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—â…±)
      - [6ã€æ•°å­—èŒƒå›´æŒ‰ä½ä¸](#6æ•°å­—èŒƒå›´æŒ‰ä½ä¸)
    - [äºŒåã€æ•°å­¦](#äºŒåæ•°å­¦)
      - [1ã€å›æ–‡æ•°](#1å›æ–‡æ•°)
      - [2ã€åŠ ä¸€](#2åŠ ä¸€)
      - [3ã€é˜¶ä¹˜åçš„é›¶](#3é˜¶ä¹˜åçš„é›¶)
      - [4ã€xçš„å¹³æ–¹æ ¹](#4xçš„å¹³æ–¹æ ¹)
      - [5ã€Pow(x,n)](#5powxn)
      - [6ã€ç›´çº¿ä¸Šæœ€å¤šçš„ç‚¹](#6ç›´çº¿ä¸Šæœ€å¤šçš„ç‚¹)
    - [äºŒåä¸€ã€ä¸€ç»´åŠ¨æ€è§„åˆ’](#äºŒåä¸€ä¸€ç»´åŠ¨æ€è§„åˆ’)
      - [1ã€çˆ¬æ¥¼æ¢¯](#1çˆ¬æ¥¼æ¢¯)
      - [2ã€æ‰“å®¶åŠ«èˆ](#2æ‰“å®¶åŠ«èˆ)
      - [3ã€å•è¯æ‹†åˆ†](#3å•è¯æ‹†åˆ†)
      - [4ã€é›¶é’±å…‘æ¢](#4é›¶é’±å…‘æ¢)
      - [5ã€æœ€é•¿é€’å¢å­åºåˆ—](#5æœ€é•¿é€’å¢å­åºåˆ—)
  - [**æ ¸å¿ƒæ€è·¯ï¼š**](#æ ¸å¿ƒæ€è·¯)

### ä¸€ã€æ•°ç»„/å­—ç¬¦ä¸²

#### 1ã€åˆå¹¶ä¸¤ä¸ªæœ‰åºå…ƒç´ 

**é¢˜ç›®é“¾æ¥**
[LeetCode No.88](https://leetcode.cn/problems/merge-sorted-array/?envType=study-plan-v2&envId=top-interview-150)


**æ ¸å¿ƒä»£ç **ï¼š

```java
while (p1 >= 0 || p2 >= 0) {
    if (p1 == -1) {
        cur = nums2[p2--];
    } else if (p2 == -1) {
        cur = nums1[p1--];
    } else if (nums1[p1] > nums2[p2]) {
        cur = nums1[p1--];
    } else {
        cur = nums2[p2--];
    }
    nums1[tail--] = cur;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ–¹æ³•ä¸€ï¼šæš´åŠ›
- æ–¹æ³•äºŒï¼šæ­£å‘åŒæŒ‡é’ˆ
- æ–¹æ³•ä¸‰ï¼šé€†å‘åŒæŒ‡é’ˆï¼ˆæœ€ä¼˜ï¼‰

#### 2ã€ç§»é™¤å…ƒç´ 

**é¢˜ç›®é“¾æ¥**
[LeetCode No.27](https://leetcode.cn/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150)


**æ ¸å¿ƒä»£ç **ï¼š

```java
int n = nums.length;
int left = 0;
for (int right = 0; right < n; ++ right) {
    if (nums[right] != val) {
        nums[left] = nums[right];
        ++ left;
    }
}
return left;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åŒæŒ‡é’ˆï¼Œå·¦æŒ‡é’ˆæŒ‡å‘å·²ç»ç¡®å®šçš„æ•°ç»„ï¼Œå³æŒ‡é’ˆå»åˆ¤æ–­æ˜¯å¦ç­‰äºval
- å³æŒ‡é’ˆä¸æ–­å‘å‰ï¼Œå·¦æŒ‡é’ˆåªåœ¨æœ‰æ­£ç¡®æ•°å­—çš„æ—¶å€™å‘å‰

#### 3ã€åˆ é™¤æœ‰åºæ•°ç»„çš„é‡å¤é¡¹

**é¢˜ç›®é“¾æ¥**
[LeetCode No.26](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)


**æ ¸å¿ƒä»£ç **ï¼š

```java
int left = 1;
for (int right = 1; right < nums.length; ++ right) {
    if (nums[right] != nums[left-1]) {
        nums[left] = nums[right];
        ++ left;
    }
}
return left;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åŒæŒ‡é’ˆï¼Œå·¦æŒ‡é’ˆæŒ‡å‘å·²ç»ç¡®å®šçš„æ•°ç»„ï¼Œå³æŒ‡é’ˆå»åˆ¤æ–­æ˜¯å¦ç­‰äºå·¦æŒ‡é’ˆå‰ä¸€ä¸ªå€¼
- å³æŒ‡é’ˆä¸æ–­å‘å‰ï¼Œå·¦æŒ‡é’ˆåªåœ¨æœ‰æ­£ç¡®æ•°å­—çš„æ—¶å€™å‘å‰

#### 4ã€åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹2

**é¢˜ç›®é“¾æ¥**
[LeetCode No.80](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150)


**æ ¸å¿ƒä»£ç **ï¼š

```java
int left = 2;
for (int right = 2; right < nums.length; ++ right) {
    if (nums[right] != nums[left-2]) {
        nums[left] = nums[right];
        ++ left;
    }
}
return left;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å’Œä¸Šä¸€é¢˜ç›¸è¿‘ï¼Œä»å‰ä¸€ä¸ªæ•°æ”¹æˆå‰ä¸¤ä¸ªæ•°å°±è¡Œ

#### 5ã€å¤šæ•°å…ƒç´ 

**é¢˜ç›®é“¾æ¥**
[LeetCode No.169](https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&envId=top-interview-150)


**æ ¸å¿ƒä»£ç **ï¼š

```java
int val = nums[0];
int count = 1;
for (int i = 1; i < nums.length; ++ i) {
    if (count == 0) {
        val = nums[i];
        count = 1;
        continue;
    }
    count = nums[i] == val ? count+1 : count-1;
}
return val;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æœ¬é¢˜æ–¹æ³•å¾ˆå¤š
- æ–¹æ³•ä¸€ï¼šç”¨å“ˆå¸Œè¡¨è®¡æ•°
- æ–¹æ³•äºŒï¼šæ’åºåå–ä¸­å€¼
- æ–¹æ³•ä¸‰ï¼šéšæœºæŒ‘é€‰ååˆ¤æ–­æ˜¯å¦ä¸ºä¼—æ•°
- æ–¹æ³•å››ï¼šå°†æ•°ç»„åˆ†æˆä¸¤æ®µï¼Œåˆ†åˆ«æ±‚å‡ºå·¦å³ä¸¤åŠéƒ¨åˆ†çš„ä¼—æ•°ï¼Œå†ä»ä¸­é€‰å‡ºæ­£ç¡®çš„ä¼—æ•°ï¼ˆæŒ‰ç…§æ•°é‡ï¼‰
- æ–¹æ³•äº”ï¼šæŠ•ç¥¨æ³•ï¼ˆæˆ‘è®¤ä¸ºæœ€ä¼˜ï¼‰

#### 6ã€è½®è½¬æ•°ç»„

**é¢˜ç›®é“¾æ¥**
[LeetCode No.189](https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150)


**æ ¸å¿ƒä»£ç **ï¼š

```java
// æ–¹æ³•äºŒä»£ç 
public void rotate(int[] nums, int k) {
    int n = nums.length;
    k = k % n;
    int count = gcd(k, n);
    for (int start = 0; start < count; ++start) {
        int current = start;
        int prev = nums[start];
        do {
            int next = (current + k) % n;
            int temp = nums[next];
            nums[next] = prev;
            prev = temp;
            current = next;
        } while (start != current);
    }
}

public int gcd(int x, int y) {
    return y > 0 ? gcd(y, x % y) : x;
}

// æ–¹æ³•ä¸‰ä»£ç 
public void rotate(int[] nums, int k) {
    k %= nums.length;
    reverse(nums, 0, nums.length - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.length - 1);
}
public void reverse(int[] nums, int start, int end) {
    while (start < end) {
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start += 1;
        end -= 1;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ–¹æ³•ä¸€ï¼šåœ¨å¦ä¸€ä¸ªæ–°æ•°ç»„ä¸Šæ“ä½œ
- æ–¹æ³•äºŒï¼šå¾ªç¯äº¤æ¢ï¼ˆéœ€è¦è®¡ç®—æ€»æ•°å’Œç§»åŠ¨æ•°çš„æœ€å¤§å…¬çº¦æ•°ï¼Œç”¨äºè®¡ç®—äº¤æ¢è½®æ•°ã€‚ï¼‰
- æ–¹æ³•ä¸‰ï¼šäº¤æ¢ä¸‰æ¬¡ï¼ˆè®¨å·§ï¼‰

#### 7ã€ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº

**é¢˜ç›®é“¾æ¥**
[LeetCode No.121](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// æ–¹æ³•ä¸€ï¼šè´ªå¿ƒç®—æ³•
// æ‰¾åˆ°ä¸€ä¸ªæœ€å°çš„è´­å…¥ç‚¹
int low = Integer.MAX_VALUE;
// resä¸æ–­æ›´æ–°ï¼Œç›´åˆ°æ•°ç»„å¾ªç¯å®Œæ¯•
int res = 0;
for(int i = 0; i < prices.length; i++){
    low = Math.min(prices[i], low);
    res = Math.max(prices[i] - low, res);
}
return res;

// æ–¹æ³•äºŒï¼šåŠ¨æ€è§„åˆ’
int[][] dp = new int[length][2];
int result = 0;
dp[0][0] = -prices[0];
dp[0][1] = 0;
for (int i = 1; i < length; i++) {
    dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);
    dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
}

```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä¸¤ç§æ–¹æ³•ï¼Œè´ªå¿ƒç®—æ³•æˆ–åŠ¨æ€è§„åˆ’
- è´ªå¿ƒç®—æ³•çš„æ€æƒ³ä¸»è¦æ˜¯ï¼Œè®°å½•æœ€ä½çš„ä»·æ ¼ï¼Œå¹¶æ¯æ¬¡éƒ½å’Œæœ€ä½å€¼å¯¹æ¯”ï¼Œè·å–ç»“æœæœ€å¤§å€¼
- åŠ¨æ€è§„åˆ’çš„æ€æƒ³æ˜¯ï¼šä½¿ç”¨äºŒç»´dpæ•°ç»„ï¼Œç¬¬ä¸€ç»´æ˜¯ä»·æ ¼æ•°é‡ï¼Œç¬¬äºŒç»´æ˜¯æ˜¯å¦å·²ç»ä¹°å…¥ï¼›åˆ‡è®°æ¯æ¬¡æ›´æ–°æ—¶å¦‚æœæ˜¯ä¹°å…¥çŠ¶æ€è¦ä¸ç»´æŒè¦ä¸ç­‰äºä»·æ ¼çš„è´Ÿæ•°ï¼Œå› ä¸ºæ— æ³•é‡å¤ä¹°å…¥

#### 8ã€ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº2

**é¢˜ç›®é“¾æ¥**
[LeetCode No.122](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java

// æ–¹æ³•ä¸€ï¼ŒåŠ¨æ€è§„åˆ’
int len = prices.length;
int dp[][] = new int[len][2];
dp[0][0] = - prices[0];
dp[0][1] = 0;
for (int i = 1; i < len; ++ i) {
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]-prices[i]);
    dp[i][1] = Math.max(dp[i-1][0]+prices[i], dp[i-1][1]);
}
return Math.max(dp[len-1][0], dp[len-1][1]);

// æ–¹æ³•äºŒï¼Œè´ªå¿ƒç®—æ³•
int result = 0;
for (int i = 1; i < prices.length; ++ i) {
    result += Math.max(prices[i]-prices[i-1], 0);
}
return result;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å’Œä¸Šé¢˜åŸºæœ¬ç›¸åŒï¼Œè´ªå¿ƒç®—æ³•è¦æ³¨æ„æ¯æ¬¡ç´¯åŠ å‰ä¸€æ¬¡çš„ä»·æ ¼å·®ï¼ŒåŠ¨æ€è§„åˆ’æ³¨æ„åœ¨ä¹°å…¥çŠ¶æ€è¦ç»§æ‰¿å…ˆå‰çŠ¶æ€

#### 9ã€è·³è·ƒæ¸¸æˆ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.55](https://leetcode.cn/problems/jump-game/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
int len = nums.length;
if (len == 1) return true;
int cover = nums[0];
for (int i = 1; i <= cover; ++ i) {
    if (cover >= len-1)
        return true;
    cover = Math.max(cover, i+nums[i]);
}
return false;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä¸æ–­æ›´æ–°å³è¾¹ç•Œï¼Œå¹¶å®æ—¶åˆ¤æ–­æ˜¯å¦åŒ…å«äº†é•¿åº¦

#### 10ã€è·³è·ƒæ¸¸æˆ2

**é¢˜ç›®é“¾æ¥**
[LeetCode No.45](https://leetcode.cn/problems/jump-game-ii/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
int result = 0;
// å½“å‰è¦†ç›–çš„æœ€è¿œè·ç¦»ä¸‹æ ‡
int cur = 0;
// ä¸‹ä¸€æ­¥è¦†ç›–çš„æœ€è¿œè·ç¦»ä¸‹æ ‡
int next = 0;
for (int i = 0; i <= cur && cur < nums.length - 1; ++i) {
    next = Math.max(next, i + nums[i]);
    // å¯è¾¾ä½ç½®çš„æ”¹å˜æ¬¡æ•°å°±æ˜¯è·³è·ƒæ¬¡æ•°
    if (i == cur) {
        cur = next;
        result++;
    }
}
return result;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- è¿™é¢˜å¥½ç†è§£ï¼Œä½†å†™çš„é€»è¾‘æ¯”è¾ƒç»•ï¼Œè¦ç‰¢ç‰¢æŠŠæ¡â€œå½“å‰èŒƒå›´â€è¿™ä¸ªæ¦‚å¿µ
- é€šè¿‡ä¸€ä¸ªå½“å‰èŒƒå›´ï¼Œä¸€ä¸ªä¸‹ä¸€æ­¥çš„èŒƒå›´ï¼Œä¸æ–­æ‰©æ•£éå†æ•´ä¸ªæ•°ç»„ï¼Œæ¯æ¬¡ç¦»å¼€å½“å‰èŒƒå›´çš„æ—¶å€™éƒ½æ‰©å±•ä¸‹ä¸€èŒƒå›´ï¼Œå°†åŸå…ˆä¸‹ä¸€èŒƒå›´ç»§æ‰¿ç»™å½“å‰èŒƒå›´
- è¦æ³¨æ„ç»“æŸæ¡ä»¶æ˜¯cur < len-1è€Œä¸æ˜¯cur < lenï¼Œå› ä¸ºå½“curæŠµè¾¾ len-1 è¿™ä¸ªå€¼çš„æ—¶å€™ï¼Œç›´æ¥å°±ä¼šè·³å‡ºå¾ªç¯

#### 11ã€HæŒ‡æ•°

**é¢˜ç›®é“¾æ¥**
[LeetCode No.274](https://leetcode.cn/problems/h-index/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
Arrays.sort(citations);
int len = citations.length;
int hIndex = 0;
for (int i = 0; i < citations.length; ++ i) {
    if ((len - i) <= citations[i])
        hIndex = Math.max(hIndex, len - i);
}
return hIndex;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ’åºåè®¡æ•°åˆ¤æ–­

#### 12ã€O(1)æ—¶é—´æ’å…¥åˆ é™¤å’Œè·å–éšæœºå…ƒç´ 

**é¢˜ç›®é“¾æ¥**
[LeetCode No.380](https://leetcode.cn/problems/insert-delete-getrandom-o1/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// insert
if (indices.containsKey(val))
    return false;
int index = nums.size();
nums.add(val);
indices.put(val, index);
return true;

// delete
if (!indices.containsKey(val))
    return false;
int index = indices.get(val);
int last = nums.get(nums.size()-1);
nums.set(index, last);
indices.put(last, index);
nums.remove(nums.size()-1);
indices.remove(val);
return true;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨HashMapä¸Listç»“åˆï¼Œå®ç°O(1)çš„getå’Œputï¼Œä»¥åŠéšæœºè¯»å–

#### 13ã€é™¤è‡ªèº«ä»¥å¤–æ•°ç»„çš„ä¹˜ç§¯

**é¢˜ç›®é“¾æ¥**
[LeetCode No.238](https://leetcode.cn/problems/product-of-array-except-self/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
left[0] = 1;
for (int i = 1; i < len; ++ i) {
    left[i] = left[i-1] * nums[i-1];
}
right[len-1] = 1;
for (int i = len-2; i >= 0; -- i) {
    right[i] = right[i+1] * nums[i+1];
}
for (int i = 0; i < len; ++ i)
    result[i] = left[i] * right[i];
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ±‚æ‰€æœ‰æ•°çš„å·¦ä¾§æ•°ä¸å³ä¾§æ•°ä¹˜æœºï¼Œæœ€ç»ˆç›¸ä¹˜å¾—åˆ°ç»“æœ

#### 14ã€åŠ æ²¹ç«™

**é¢˜ç›®é“¾æ¥**
[LeetCode No.134](https://leetcode.cn/problems/gas-station/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
for (int i = 0; i < gas.length; ++ i) {
    totalSum += gas[i]-cost[i];
    curSum += gas[i]-cost[i];
    if (curSum < 0) {
        start = i+1;
        curSum = 0;
    }
}
return totalSum >= 0 ? start : -1;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- è´ªå¿ƒç®—æ³•ï¼Œç»´æŠ¤ä¸€ä¸ªtotalSumå’Œä¸€ä¸ªcurSumï¼Œéå†costå’Œgas
- ä¸æ–­ç´¯åŠ totalSumå’ŒcurSumï¼Œè‹¥curSum<0åˆ™è¯æ˜æ— æ³•ä»¥è¿™ä¸ªç‚¹ä½œä¸ºå¼€å§‹ï¼Œåˆ™èµ·å§‹ç‚¹è®¾ä¸ºi+1

#### 15ã€åˆ†å‘ç³–æœ

[LeetCode No.135](https://leetcode.cn/problems/candy/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
Arrays.fill(candy,1);
for (int i = 1; i < len; ++ i) 
    candy[i] = ratings[i] > ratings[i-1] ? candy[i-1]+1 : candy[i];
for (int i = len-2; i >= 0; -- i)
    candy[i] = ratings[i] > ratings[i+1] ? Math.max(candy[i],candy[i+1]+1) : candy[i];
for (int i = 0; i < len; ++ i)
    result += candy[i];
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ‰¾åˆ°ä»å·¦å‘å³æ•°çš„æ­£ç¡®ç³–æœæ•°é‡ï¼Œå†ä»å³åˆ°å·¦è®¡ç®—æ­£ç¡®æ•°é‡ï¼Œå¹¶ä¸å…ˆå‰æ•°æ®å¯¹æ¯”é€‰æ‹©æœ€å¤§çš„

#### 16ã€æ¥é›¨æ°´

**é¢˜ç›®é“¾æ¥**
[LeetCode No.150](https://leetcode.cn/problems/trapping-rain-water/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
left[0] = height[0];
for (int i = 1; i < len; ++ i)
    left[i] = Math.max(left[i-1], height[i])
right[len-1] = height[len-1];
for (int i = len-2; i >= 0; -- i)
    right[i] = Math.max(right[i+1], height[i]);

for (int i = 0; i < len; ++ i)
    result += Math.min(left[i], right[i])-height[i];
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä»å·¦åˆ°å³é€‰æ‹©å’Œå·¦ä¾§æ¯”çš„æœ€å¤§å€¼ï¼Œä»å³åˆ°å·¦é€‰æ‹©å’Œå³ä¾§æ¯”çš„æœ€å¤§å€¼ï¼Œä¸¤è€…æ±‚æœ€å°å€¼åå‡å»height
- ç›¸å½“äºé›¨æ°´çŒæ»¡ç©ºé—´ï¼Œåˆ†åˆ«ç«‹èµ·å·¦ä¾§å’Œå³ä¾§çš„æ¿å­å¹¶ç§¯ç´¯é›¨æ°´ï¼Œæœ€åå°†ä¸¤ä¸ªæ¿å­æŠ½èµ°ï¼Œè·å–è¿˜èƒ½å‰©ä¸‹çš„æ°´é‡

#### 17ã€ç½—é©¬æ•°å­—è½¬æ•´æ•°

**é¢˜ç›®é“¾æ¥**
[LeetCode No.13](https://leetcode.cn/problems/roman-to-integer/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// åˆå§‹åŒ–
Map<Character, Integer> numMap = new HashMap<Character, Integer>() {{
    put('I', 1);
    put('V', 5);
    put('X', 10);
    put('L', 50);
    put('C', 100);
    put('D', 500);
    put('M', 1000);
}};

// éå†
for (int i = 0; i < len; ++ i) {
    int value = numMap.get(s.charAt(i));
    if (i < len-1 && value < numMap.get(s.charAt(i+1)))
        result -= value;
    else
        result += value;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨putåˆå§‹åŒ–map
- éå†mapä¸­ä¿¡æ¯æ—¶ï¼Œè‹¥å½“å‰å­—ç¬¦ä¸²æ‰€æŒ‡ä»£çš„å€¼å°äºåä¸€ä¸ªåˆ™å‡å»è¿™ä¸ªå€¼ï¼Œå¦åˆ™åŠ ä¸Šè¿™ä¸ªå€¼

#### 18ã€æ•´æ•°è½¬ç½—é©¬æ•°å­—

**é¢˜ç›®é“¾æ¥**
[LeetCode No.12](https://leetcode.cn/problems/integer-to-roman/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
int[] values={1000,900,500,400,100,90,50,40,10,9,5,4,1};
String[] rom={"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
StringBuilder sb=new StringBuilder();
for (int i = 0; i < values.length; ++ i) {
    while (num >= values[i]) {
        sb.append(rom[i]);
        num -= values[i];
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åˆ—ä¸¾æ‰€æœ‰ä¼šå‡ºç°çš„å€¼ï¼Œä»å¤§åˆ°å°åˆ¤æ–­å€¼æ˜¯å¦å¤§äºnumï¼Œå¤§äºåˆ™å†™å…¥ç½—é©¬æ•°å­—å¹¶å‡å»è¿™ä¸ªå€¼

#### 19ã€æœ€åä¸€ä¸ªå•è¯çš„é•¿åº¦

**é¢˜ç›®é“¾æ¥**
[LeetCode No.58](https://leetcode.cn/problems/length-of-last-word/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
while (s.charAt(index) == ' ')
    -- index;
while (index >= 0 && s.charAt(index) != ' ') {
    ++ result;
    -- index;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åå‘éå†

#### 20ã€æœ€é•¿å…¬å…±å‰ç¼€

**é¢˜ç›®é“¾æ¥**
[LeetCode No.14](https://leetcode.cn/problems/longest-common-prefix/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
for (int i = 0; i < length; i++) {
    char c = strs[0].charAt(i);
    for (int j = 1; j < count; j++) {
        if (i == strs[j].length() || strs[j].charAt(i) != c) {
            return strs[0].substring(0, i);
        }
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ¨ªå‘æˆ–çºµå‘éå†

#### 21ã€åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯

**é¢˜ç›®é“¾æ¥**
[LeetCode No.151](https://leetcode.cn/problems/reverse-words-in-a-string/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
s = s.trim();
List<String> wordList = Arrays.asList(s.split("\\s+"));
Collections.reverse(wordList);
return String.join(" ", wordList);
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨è¯­è¨€ç‰¹æ€§ï¼Œæ­£åˆ™åŒ¹é…ç©ºæ ¼å¹¶åˆ†å‰²åœ¨æ‹¼æ¥


#### 22ã€Zå­—å½¢å˜æ¢ï¼ˆè¦å†å»çœ‹ï¼‰

**é¢˜ç›®é“¾æ¥**
[LeetCode No.6](https://leetcode.cn/problems/zigzag-conversion/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// ç‰¹æ®Šæƒ…å†µï¼šè¡Œæ•°ä¸º1æ—¶æ— éœ€å˜æ¢
if (numRows == 1) {
    return s;
}

int len = s.length();
int cycle = numRows * 2 - 2; // å‘¨æœŸé•¿åº¦
StringBuilder sb = new StringBuilder();

// æŒ‰è¡Œéå†ï¼ˆæ¯è¡Œå¤„ç†æ‰€æœ‰å‘¨æœŸä¸­å¯¹åº”ä½ç½®çš„å­—ç¬¦ï¼‰
for (int row = 0; row < numRows; row++) {
    // éå†æ¯ä¸ªå‘¨æœŸ
    for (int i = 0; i < len; i += cycle) {
        // 1. å¤„ç†å‘¨æœŸä¸­å‚ç›´å‘ä¸‹çš„å­—ç¬¦ï¼ˆæ¯è¡Œåœ¨å‘¨æœŸä¸­çš„å›ºå®šä½ç½®ï¼‰
        if (i + row < len) {
            sb.append(s.charAt(i + row));
        }
        
        // 2. å¤„ç†å‘¨æœŸä¸­æ–œå‘ä¸Šçš„å­—ç¬¦ï¼ˆé™¤äº†ç¬¬ä¸€è¡Œå’Œæœ€åä¸€è¡Œï¼‰
        if (row != 0 && row != numRows - 1) {
            // æ–œå‘ä¸Šçš„å­—ç¬¦åœ¨å‘¨æœŸä¸­çš„ä½ç½® = i + cycle - row
            int diagonalPos = i + cycle - row;
            if (diagonalPos < len) {
                sb.append(s.charAt(diagonalPos));
            }
        }
    }
}

return sb.toString();
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æŒ‰å‘¨æœŸæ¨¡æ‹Ÿè®¡ç®—


#### 23ã€æ‰¾å‡ºå­—ç¬¦ä¸²ä¸­ç¬¬ä¸€ä¸ªåŒ¹é…çš„ä¸‹æ ‡

**é¢˜ç›®é“¾æ¥**
[LeetCode No.28](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int strStr(String haystack, String needle) {
    if (needle.length() == 0) {
        return 0;
    }
    int[] next = new int[needle.length()];
    getnext(needle, next);
    int i = 0, j = 0;
    while (i < haystack.length()) {
        if (haystack.charAt(i) == needle.charAt(j)) {
            ++ i; ++ j;
        }
        if (j == needle.length()) {
            return i - j;
        } else if (i < haystack.length() && haystack.charAt(i) != needle.charAt(j)) {
            if (j != 0) {
                j = next[j - 1];
            } else {
                ++ i;
            }
        }
    }
    return -1;
}
public void getnext(String s, int[] next) {
    int i = 0;
    next[0] = 0;
    for (int j = 1; j < s.length(); ++ j) {
        while (i > 0 && s.charAt(i) != s.charAt(j)) {
            i = next[i - 1];
        }
        if (s.charAt(i) == s.charAt(j)) {
            ++ i;
            next[j] = i;
        }
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ±‚å¤©æ€çš„nextæ•°ç»„ï¼ˆä¸å¤ªå¥½ç†è§£ï¼‰

#### 24ã€æ–‡æœ¬å·¦å³å¯¹é½

**é¢˜ç›®é“¾æ¥**
[LeetCode No.68](https://leetcode.cn/problems/text-justification/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// æ²¡å•¥ï¼Œçº¯æ¨¡æ‹Ÿï¼Œå¾ˆæ— èŠä½†ä¸å¥½å†™
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ¨¡æ‹Ÿ

### äºŒã€åŒæŒ‡é’ˆ

#### 1ã€éªŒè¯å›æ–‡ä¸²

**é¢˜ç›®é“¾æ¥**
[LeetCode No.125](https://leetcode.cn/problems/valid-palindrome/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// å†™å…¥ååˆ¤æ–­ï¼Œæˆ–ç›´æ¥åœ¨å­—ç¬¦ä¸²ä¸Šåˆ¤æ–­ï¼ˆè¿™ä¸ªæ›´å¿«ï¼‰
for (int i = 0; i < s.length(); ++ i) {
    if ((s.charAt(i) >= 'a' && s.charAt(i) <= 'z') || (s.charAt(i) >= 'A' && s.charAt(i) <= 'Z')) {
        sb.append(Character.toLowerCase(s.charAt(i)));
    }
    if (s.charAt(i) >= '0' && s.charAt(i) <= '9')
        sb.append(s.charAt(i));
}
int left = 0, right = sb.length()-1;
while (left <= right) {
    if (sb.charAt(left) != sb.charAt(right))
        return false;
    ++ left;
    -- right;
}

while (left < right) {
    while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
        ++left;
    }
    while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
        --right;
    }
    if (left < right) {
        if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {
            return false;
        }
        ++left;
        --right;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åŒæŒ‡é’ˆéå†å·¦å³ï¼Œç›´åˆ°æ‰¾åˆ°å„è‡ªæ»¡è¶³æ¡ä»¶çš„æ•°åï¼Œåˆ¤æ–­æ˜¯å¦ç›¸ç­‰

#### 2ã€åˆ¤æ–­å­åºåˆ—

**é¢˜ç›®é“¾æ¥**
[LeetCode No.392](https://leetcode.cn/problems/is-subsequence/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public boolean isSubsequence(String s, String t) {
    int indexs = 0, indext = 0;
    int slen = s.length(), tlen = t.length();
    if (slen > tlen)
        return false;
    while (indexs < slen && indext < tlen) {
        if (s.charAt(indexs) == t.charAt(indext)) {
            ++ indexs;
            ++ indext;
        } else
            ++ indext;
    }
    if (indexs > s.length()-1)
        return true;
    else
        return false;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- så’Œtä¸ŠåŒæŒ‡é’ˆåˆ¤æ–­

#### 3ã€ä¸¤æ•°ä¹‹å’Œâ…¡-è¾“å…¥æœ‰åºæ•°ç»„

**é¢˜ç›®é“¾æ¥**
[LeetCode No.167](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
while (index1 < index2) {
    if (numbers[index1] + numbers[index2] > target)
        -- index2;
    else if (numbers[index1] + numbers[index2] < target)
        ++ index1;
    else 
        return new int[]{index1+1, index2+1};
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åŒæŒ‡é’ˆä¸æ–­é€¼è¿‘target

#### 4ã€ç››æœ€å¤šæ°´çš„å®¹å™¨

**é¢˜ç›®é“¾æ¥**
[LeetCode No.11](https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
while (left < right) {
    result = Math.max(result, (right-left)*Math.min(height[left], height[right]));
    if (height[left] <= height[right])
        ++ left;
    else
        -- right;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ç§»åŠ¨è¾ƒä½çŸ®çš„è¾¹ç•Œï¼Œå¯¹æ¯”æœ€å¤§å€¼

#### 5ã€ä¸‰æ•°ä¹‹å’Œ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.15](https://leetcode.cn/problems/3sum/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
for (int i = 0; i < len-2; ++ i) {
    if (nums[i] > 0) {
        return result;
    }
    if (i != 0 && nums[i] == nums[i-1])
        continue;
    int left = i+1, right = len-1;
    while (left < right) {
        if (nums[i] + nums[left] + nums[right] < 0) {
            ++ left;
        } else if ( nums[i] + nums[left] + nums[right] > 0 ) {
            -- right;
        } else {
            result.add(Arrays.asList(nums[i], nums[left], nums[right]));
            while (right > left && nums[right] == nums[right-1]) -- right;
            while (right > left && nums[left] == nums[left+1]) ++ left;
            -- right; ++ left;
        }
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å…ˆæ’åºï¼Œé€‰å®šä¸€ä¸ªæ•°åä½¿ç”¨åŒæŒ‡é’ˆã€

### ä¸‰ã€æ»‘åŠ¨çª—å£

#### 1ã€é•¿åº¦æœ€å°çš„å­æ•°ç»„

**é¢˜ç›®é“¾æ¥**
[LeetCode No.209](https://leetcode.cn/problems/minimum-size-subarray-sum/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
for (int i = 0, j = 0; j < nums.length; ++ j ) {
    sum += nums[j];
    while (sum >= target) {
        len = j - i + 1;
        result = Math.min(result, len);
        sum -= nums[i++];
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ»‘åŠ¨çª—å£ï¼Œå€¼åœ¨è¦æ±‚èŒƒå›´æ—¶å·¦æŒ‡é’ˆå‘å³ï¼Œå¦åˆ™å³æŒ‡é’ˆå‘å³

#### 2ã€æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²

**é¢˜ç›®é“¾æ¥**
[LeetCode No.3](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
for (int i = 0, j = 0; j < s.length(); ++ j) {
    while (map.containsKey(s.charAt(j))) {
        map.remove(s.charAt(i));
        ++ i;
    }
    map.put(s.charAt(j), 1);
    maxLen = Math.max(maxLen, j - i + 1);
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä¸æ–­ç§»åŠ¨å³æŒ‡é’ˆï¼Œè‹¥å³ä¾§æœ‰ç›¸åŒå…ƒç´ åˆ™å·¦æŒ‡é’ˆä¸æ–­å³ç§»ç›´åˆ°æ²¡æœ‰

#### 3ã€ä¸²è”æ‰€æœ‰å•è¯çš„å­ä¸²

**é¢˜ç›®é“¾æ¥**
[LeetCode No.30](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// æ²¡å•¥
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨differå“ˆå¸Œè¡¨ï¼Œæ ‡è¯†çª—å£ä¸­å•è¯é¢‘æ¬¡å’Œwordsä¸­å•è¯é¢‘æ¬¡ä¹‹å·®ã€‚
- éå†åˆ—è¡¨ï¼Œå¯¹äºæ¯ä¸ªå­—ç¬¦éƒ½ä½¿ç”¨æ»‘åŠ¨çª—å£çš„æ–¹æ³•ï¼Œè·å–å…¶åé¢æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„ç»“æœ

#### 4ã€æœ€å°è¦†ç›–å­ä¸²

**é¢˜ç›®é“¾æ¥**
[LeetCode No.76](https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java

```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ç”¨å³æŒ‡é’ˆæ‰©å¤§çª—å£æ‰¾ â€œæœ‰æ•ˆèŒƒå›´â€ï¼Œç”¨å·¦æŒ‡é’ˆç¼©å°çª—å£æ‰¾ â€œæœ€çŸ­æœ‰æ•ˆèŒƒå›´â€ï¼Œé€šè¿‡å“ˆå¸Œè¡¨è®°å½•å­—ç¬¦æ•°é‡å¹¶åˆ¤æ–­æœ‰æ•ˆæ€§

> ### å››ã€çŸ©é˜µ

#### 1ã€æœ‰æ•ˆçš„æ•°ç‹¬

**é¢˜ç›®é“¾æ¥**
[LeetCode No.36](https://leetcode.cn/problems/valid-sudoku/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
for (int i = 0; i < 9; i++) {
    for (int j = 0; j < 9; j++) {
        char c = board[i][j];
        if (c != '.') {
            int index = c - '0' - 1;
            rows[i][index]++;
            columns[j][index]++;
            subboxes[i / 3][j / 3][index]++;
            if (rows[i][index] > 1 || columns[j][index] > 1 || subboxes[i / 3][j / 3][index] > 1) {
                        return false;
                }
            }
        }
    }
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å£°æ˜å›ºå®šå¤§å°çš„äºŒç»´æ•°ç»„å®ç°ã€

#### 2ã€èºæ—‹çŸ©é˜µ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.54](https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> order = new ArrayList<Integer>();
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return order;
        }

        int rows = matrix.length, columns = matrix[0].length;
        boolean[][] visited = new boolean[rows][columns];
        int total = rows * columns;
        int row = 0, column = 0;
        int[][] directions = { {0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int directionIndex = 0;
        for (int i = 0; i < total; ++ i) {
            order.add(matrix[row][column]);
            visited[row][column] = true;
            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];
            if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn]) {
                directionIndex = (directionIndex + 1) % 4;
            }
            row += directions[directionIndex][0];
            column += directions[directionIndex][1];
        }
        return order;
    }
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ¨¡æ‹Ÿ
- ä¸æ–­æŒ‰ç…§å››ä¸ªæ–¹å‘å˜æ¢ï¼Œè‹¥ç¢°å£å°±æ›´æ”¹æ–¹å‘ï¼Œç›´åˆ°å…¨éƒ¨éå†å®Œ

#### 3ã€æ—‹è½¬å›¾åƒ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.48](https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// ç›´æ¥æ—‹è½¬
public void rotate(int[][] matrix) {
    int n = matrix.length;
    for (int i = 0; i < n / 2; ++i) {
        for (int j = 0; j < (n + 1) / 2; ++j) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][i];
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
            matrix[j][n - i - 1] = temp;
        }
    }
}

// æ°´å¹³ç¿»è½¬+å¯¹è§’ç¿»è½¬
// æ°´å¹³ç¿»è½¬
for (int i = 0; i < n / 2; ++i) {
    for (int j = 0; j < n; ++j) {
        int temp = matrix[i][j];
        matrix[i][j] = matrix[n - i - 1][j];
        matrix[n - i - 1][j] = temp;
    }
}
// ä¸»å¯¹è§’çº¿ç¿»è½¬
for (int i = 0; i < n; ++i) {
    for (int j = 0; j < i; ++j) {
        int temp = matrix[i][j];
        matrix[i][j] = matrix[j][i];
        matrix[j][i] = temp;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ–¹æ³•ä¸€ï¼šæ–°å»ºä¸€ä¸ªmatrixåæ¯è¡Œåšä¸€æ¬¡æ—‹è½¬
- æ–¹æ³•äºŒï¼šåˆ†å‰²æˆå››å—åï¼Œå››å—åˆ†åˆ«æ—‹è½¬
- æ–¹æ³•ä¸‰ï¼šæ°´å¹³ç¿»è½¬ï¼‹å¯¹è§’çº¿ç¿»è½¬

#### 4ã€çŸ©é˜µç½®é›¶

**é¢˜ç›®é“¾æ¥**
[LeetCode No.73](https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
int m = matrix.length, n = matrix[0].length;
boolean[] row = new boolean[m];
boolean[] col = new boolean[n];
for (int i = 0; i < m; i++) {
    for (int j = 0; j < n; j++) {
        if (matrix[i][j] == 0) {
            row[i] = col[j] = true;
        }
    }
}
for (int i = 0; i < m; i++) {
    for (int j = 0; j < n; j++) {
        if (row[i] || col[j]) {
            matrix[i][j] = 0;
        }
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ ‡è®°æ‰€æœ‰åŒ…å«0çš„è¡Œå·å’Œåˆ—å·
- éå†æ—¶ç½®é›¶

#### 5ã€ç”Ÿå‘½æ¸¸æˆ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.289](https://leetcode.cn/problems/game-of-life/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public void gameOfLife(int[][] board) {
Set<int[]> live = new HashSet<int[]>();
Set<int[]> death = new HashSet<int[]>();
for (int i = 0; i < board.length; ++ i)
    for (int j = 0; j < board[0].length; ++ j)
        int res = check(board, i, j);
        if (res == 1)
            live.add(new int[]{i, j});
        else if (res == 2)
            death.add(new int[]{i, j});
    }
for (int[] location : live)
    board[location[0]][location[1]] = 1;
for (int[] location : death)
    board[location[0]][location[1]] = 0;

private int check(int[][] board, int row, int col) {
    int liveSum = 0;
    for (int i = row-1; i <= row+1; ++ i)
        for (int j = col-1; j <= col+1; ++ j)
            if (!(i == row && j == col) && i >= 0 && >=0 && i < board.length && j < board[0].length && board[i][j]  == 1)
                ++ liveSum;
    if (board[row][col] == 1 && (liveSum < 2 || liveSum>    3))
        return 2;
    else if (board[row][col] == 0 && liveSum == 3)
        return 1;
    else
        return 0;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ‰¾åˆ°éœ€è¦æ›´æ–°çš„ä½ç½®å¹¶è®°å½•æ›´æ–°çŠ¶æ€

### å››ã€å“ˆå¸Œè¡¨

#### 1ã€èµé‡‘ä¿¡

**é¢˜ç›®é“¾æ¥**
[LeetCode No.383](https://leetcode.cn/problems/ransom-note/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
int[] check = new int[26];
for (int i = 0; i < magazine.length(); ++ i) {
    ++ check[magazine.charAt(i)-'a'];
}
for (int i = 0; i < ransomNote.length(); ++ i) {
    if (check[ransomNote.charAt(i)-'a'] == 0)
        return false;
    else
        -- check[ransomNote.charAt(i)-'a'];
}
return true;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ•°ç»„ç»Ÿè®¡

#### 2ã€åŒæ„å­—ç¬¦ä¸²

**é¢˜ç›®é“¾æ¥**
[LeetCode No.205](https://leetcode.cn/problems/isomorphic-strings/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
for (int i = 0; i < len; ++i) {
    char x = s.charAt(i), y = t.charAt(i);
    if ((s2t.containsKey(x) && s2t.get(x) != y) || (t2s.containsKey(y) && t2s.get(y) != x)) {
        return false;
    }
    s2t.put(x, y);
    t2s.put(y, x);
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- è®©ä¸¤ç§å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦ç›¸äº’æ˜ å°„

#### 3ã€å•è¯è§„å¾‹

**é¢˜ç›®é“¾æ¥**
[LeetCode No.290](https://leetcode.cn/problems/word-pattern/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
String[] strs = s.trim().split(" ");
if (strs.length != pattern.length())
    return false;
HashMap<String, Character> smap = new HashMa>();
HashMap<Character, String> pmap = new HashMa>();
for (int i = 0; i < strs.length; ++i) {
    char pChar = pattern.charAt(i);
    String str = strs[i];
    if ((smap.containsKey(str) && smap.g(str) != pChar) || 
        (pmap.containsKey(pChar) && !Objects.equals(pmap.get(pChar), str))) {
        return false;
    }
    smap.put(str, pChar);
    pmap.put(pChar, str);
}
return true;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åŒä¸Šï¼Œè¿˜æ˜¯å­˜ä¸¤ç»„å¯¹åº”å…³ç³»
- åœ¨åˆ¤æ–­strç›¸ç­‰çš„æ—¶å€™ç”¨Objects.equals

#### 4ã€æœ‰æ•ˆå­—æ¯çš„å¼‚ä½è¯

**é¢˜ç›®é“¾æ¥**
[LeetCode No.242](https://leetcode.cn/problems/valid-anagram/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    int[] table = new int[26];
    for (int i = 0; i < s.length(); i++) {
        table[s.charAt(i) - 'a']++;
    }
    for (int i = 0; i < t.length(); i++) {
        table[t.charAt(i) - 'a']--;
        if (table[t.charAt(i) - 'a'] < 0) {
            return false;
        }
    }
    return true;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨ä¸€ä¸ªint[26]è®°å½•å­—æ¯ä¸ªæ•°
- è‹¥æ˜¯åŒ…å«éå­—æ¯ï¼Œåˆ™éœ€è¦ä½¿ç”¨Hashtable

#### 5ã€å­—æ¯å¼‚ä½è¯åˆ†ç»„

**é¢˜ç›®é“¾æ¥**
[LeetCode No.49](https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public List<List<String>> groupAnagrams(String[] strs) {
    List<List<String>> result = new ArrayList<>();
    HashMap<String, List<String>> map = new HashMap<>();
    
    for (int i = 0; i < strs.length; ++i) {
        char[] keyChars = strs[i].toCharArray();
        Arrays.sort(keyChars);
        String key = new String(keyChars);
        
        if (map.containsKey(key)) {
            map.get(key).add(strs[i]);
        } else {
            List<String> list = new ArrayList<>();
            list.add(strs[i]);
            map.put(key, list);
        }
    }
    
    for (String key : map.keySet()) {
        result.add(map.get(key));
    }
    
    return result;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ç”¨æ’åºåçš„å­—ç¬¦ä¸²åšé”®

#### 6ã€ä¸¤æ•°ä¹‹å’Œ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.1](https://leetcode.cn/problems/two-sum/submissions/648317067/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int[] twoSum(int[] nums, int target) {
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; ++ i) {
        if (map.containsKey(target - nums[i])) {
            return new int[]{map.get(target - nums[i]), i};
        } else {
            map.put(nums[i], i);
        }
    }
    return new int[0];
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨å“ˆå¸Œè¡¨å­˜æ”¾å·²æœ‰æ•°å€¼ï¼Œæ¯æ¬¡æŸ¥çœ‹å½“å‰æ•°å€¼æ˜¯å¦å’Œå·²æœ‰æ•°å€¼åŒ¹é…

#### 7ã€å¿«ä¹æ•°

**é¢˜ç›®é“¾æ¥**
[LeetCode No.202](https://leetcode.cn/problems/happy-number/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public boolean isHappy(int n) {
    Set<Integer> seen = new HashSet<>();
    while (n != 1 && !seen.contains(n)) {
        seen.add(n);
        n = getNext(n);
    }
    return n == 1;
}
private int getNext(int n) {
    int totalSum = 0;
    while (n > 0) {
        int d = n % 10;
        n = n / 10;
        totalSum += d * d;
    }
    return totalSum;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä¸å­˜åœ¨æ— é™å¤§çš„å¯èƒ½ï¼Œåªèƒ½æ˜¯å¾ªç¯æˆ–è€…æˆä¸º1

#### 8ã€å­˜åœ¨é‡å¤å…ƒç´ â…¡

**é¢˜ç›®é“¾æ¥**
[LeetCode No.219](https://leetcode.cn/problems/contains-duplicate-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < nums.length; ++ i) {
        if (map.containsKey(nums[i]) && i - map.get(nums[i]) <= k)
            return true;
        map.put(nums[i], i);
    }
    return false;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å“ˆå¸Œè¡¨ç»´æŠ¤æœ€æ–°çš„æ•°å€¼ä½ç½®

#### 128ã€æœ€é•¿è¿ç»­åºåˆ—

**é¢˜ç›®é“¾æ¥**
[LeetCode No.128](https://leetcode.cn/problems/longest-consecutive-sequence/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// æ’åº
Arrays.sort(nums);
if (nums.length == 0)
    return 0;
int maxLen = 1;
int result = 1;
for (int i = 1; i < nums.length; ++ i) {
    if (nums[i] == nums[i-1]+1)
        ++ maxLen;
    else if (nums[i] == nums[i-1])
        continue;
    else
        maxLen = 1;
    result = Math.max(result, maxLen);
}
return result;

// ä¸æ’åº
Set<Integer> num_set = new HashSet<Integer>();
for (int num : nums) {
    num_set.add(num);
}
int longestStreak = 0;
for (int num : num_set) {
    if (!num_set.contains(num - 1)) {
        int currentNum = num;
        int currentStreak = 1
        while (num_set.contains(currentNum + 1)) {
            currentNum += 1;
            currentStreak += 1;
        
        longestStreak = Math.max(longestStreak, currentStreak);
    }

return longestStreak;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ’åºæ³•ï¼šå…ˆæ’åºååˆ¤æ–­æ–°è¿›å…¥çš„å€¼æ˜¯å¦ç­‰äºæ—§çš„æ•°+1ï¼Œæ›´æ–°é•¿åº¦
- ä¸æ’åºæ³•ï¼šä½¿ç”¨setå­˜æ”¾æ‰€æœ‰æ•°ï¼Œå¹¶éå†setä¸­çš„å€¼æŸ¥çœ‹æ˜¯å¦æ˜¯è¿ç»­æ•°çš„å¤´ï¼Œè‹¥æ˜¯åˆ™ç»Ÿè®¡æ•°é‡

### äº”ã€åŒºé—´

#### 1ã€æ±‡æ€»åŒºé—´

**é¢˜ç›®é“¾æ¥**
[LeetCode No.228](https://leetcode.cn/problems/summary-ranges/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public List<String> summaryRanges(int[] nums) {
    List<String> result = new ArrayList<>();
    if (nums.length == 0)
        return result;
    List<Integer> cur = new ArrayList<>();
    cur.add(nums[0]);
    
    for (int i = 1; i <= nums.length; ++i) {
        if (i == nums.length || cur.get(cur.size()-1) + 1 != nums[i]) {
            StringBuilder sb = new StringBuilder();
            sb.append(cur.get(0));
            if (cur.size() > 1) {
                sb.append("->");
                sb.append(cur.get(cur.size()-1));
            }
            result.add(sb.toString());
            cur.clear();
            if (i < nums.length) {
                cur.add(nums[i]);
            }
        } else {
            cur.add(nums[i]);
        }
    }
    
    return result;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ç”¨ä¸€ä¸ªlistå­˜å½“å‰è¿ç»­çš„åŒºé—´ä¸­çš„å€¼ï¼Œåœ¨åŒºé—´ç»“æŸååŠ å…¥åˆ°ç»“æ„ä¸­

#### 2ã€åˆå¹¶åŒºé—´

**é¢˜ç›®é“¾æ¥**
[LeetCode No.56](https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int[][] merge(int[][] intervals) {
    int len = intervals.length;
    if (len == 1 || len == 0)
        return intervals;
    List<int[]> regions = new ArrayList<>();
    Arrays.sort(intervals, (a,b) -> a[0] - b[0]);
    for (int i = 0; i < len; ++ i) {
        int start = intervals[i][0], end = intervals[i][1];
        if (regions.size() == 0 || regions.get(regions.size()-1)[1] < s tart)
            regions.add(new int[]{start, end});
        else
            regions.get(regions.size()-1)[1] = Math.max(regions.get(regions.size()-1)[1], end);
    }
    int[][] result = new int[regions.size()][2];
    for (int i = 0; i < regions.size(); ++ i)
        result[i] = regions.get(i);
    return result;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ’åºåå¾ªç¯æ‰€æœ‰åŒºé—´å¹¶æ”¾å…¥listä¸­ï¼Œè‹¥è¦æ›´æ–°èŒƒå›´åˆ™ç›´æ¥åœ¨listä¸­æ›´æ–°èŒƒå›´å³å¯

#### 3ã€æ’å…¥åŒºé—´

**é¢˜ç›®é“¾æ¥**
[LeetCode No.57](https://leetcode.cn/problems/insert-interval/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
while (i < n && intervals[i][1] < newInterval[0]) {
    result.add(intervals[i]);
    i++;
}
while (i < n && intervals[i][0] <= newInterval[1]) {
    // æ‰©å±•æ–°åŒºé—´çš„èŒƒå›´
    newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
    newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
        i++;
    }
// æ·»åŠ åˆå¹¶åçš„æ–°åŒºé—´
result.add(newInterval);
// 3. æ·»åŠ æ‰€æœ‰åœ¨æ–°åŒºé—´ä¹‹åä¸”ä¸é‡å çš„åŒºé—´
while (i < n) {
    result.add(intervals[i]);
    i++;
}
return result.toArray(new int[result.size()][]);

```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åˆ†ä¸ºä¸‰æ®µåˆ†åˆ«éå†ï¼Œæœ€åæ·»åŠ è¿›å…¥intä¸­

#### 4ã€ç”¨æœ€å°‘æ•°é‡çš„ç®­å¼•çˆ†æ°”çƒ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.452](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
int result = 1;
Arrays.sort(points, (a, b) -> Integer.compare(a[0], b[0]));
for (int i = 1; i < points.length; ++ i) {
    if (points[i][0] > points[i-1][1])
        ++ result;
    else 
        points[i][1] = Math.min(points[i-1][1], points[i][1]);
}
return result;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ’åºæ—¶ç”¨Integer.compareï¼Œå¦åˆ™ç¢°åˆ°æå¤§æ•°ä¼šè¶…å‡ºé™åˆ¶å¯¼è‡´æ’åºé”™è¯¯
- éå†æ—¶ç›´æ¥åœ¨pointæ•°ç»„ä¸­å³å¯æ›´æ–°è¾¹ç•Œ

### å…­ã€æ ˆ

#### 1ã€æœ‰æ•ˆçš„æ‹¬å·

**é¢˜ç›®é“¾æ¥**
[LeetCode No.20](https://leetcode.cn/problems/valid-parentheses/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
int n = s.length();
if (n % 2 == 1) {
    return false;

Map<Character, Character> pairs = new HashMap<Character, Character>() {{
    put(')', '(');
    put(']', '[');
    put('}', '{');
}};

Deque<Character> stack = new LinkedList<Character>();
for (int i = 0; i < n; i++) {
    char ch = s.charAt(i);
    if (pairs.containsKey(ch)) {
        if (stack.isEmpty() || stack.peek() != pairs.get(ch))   {
                return false;
            }
            stack.pop();
        } else {
            stack.push(ch);
        }
    }
    return stack.isEmpty();
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨mapå®ç°æ‹¬å·é—´åŒ¹é…ï¼Œä¸è¦ç”¨æ¡ä»¶åˆ¤æ–­ï¼Œæ²¡å¿…è¦
- ä¹Ÿå¯ä»¥ä½¿ç”¨åŸæ•°ç»„ä½œä¸ºæ ˆï¼Œçœå»æ ˆçš„ç©ºé—´

#### 2ã€ç®€åŒ–è·¯å¾„

**é¢˜ç›®é“¾æ¥**
[LeetCode No.71](https://leetcode.cn/problems/simplify-path/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
for (int i = 0; i < files.length; ++ i) {
    String file = files[i];
    if (file == "" || file.equals("."))
        continue;
    else if (file.equals("..")) {
        if (!stack.isEmpty())
            stack.pop();
    } else
        stack.push(file);
}
if (stack.isEmpty())
    return "/";
StringBuilder sb = new StringBuilder();
while (!stack.isEmpty()) {
    sb.append("/");
    sb.append(stack.pollLast());
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å…ˆç”¨splitå°†æ‰€æœ‰çš„è·¯å¾„æå–å‡ºæ¥ï¼Œç”¨æ ˆå®ç°..çš„é€»è¾‘ï¼Œå†ç”¨StringBuilderè½¬ä¸ºå­—ç¬¦ä¸²å³å¯ã€‚

#### 3ã€æœ€å°æ ˆ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.155](https://leetcode.cn/problems/min-stack/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class MinStack {

    Deque<Integer> stack;
    Deque<Integer> minStack;

    public MinStack() {
        stack = new LinkedList<>();
        minStack = new LinkedList<>();
        minStack.push(Integer.MAX_VALUE);
    }
    
    public void push(int val) {
        stack.push(val);
        minStack.push(Math.min(minStack.peek(), val));
    }
    
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨ä¸€ä¸ªminStackå­˜æ”¾æ¯æ¬¡æœ‰æ–°å…ƒç´ è¿›å…¥æ—¶å½“å‰ä¸»æ ˆä¸­æœ€å°çš„å…ƒç´ 

#### 4ã€é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼

**é¢˜ç›®é“¾æ¥**
[LeetCode No.150](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
Deque<String> stack = new LinkedList<>();
for (String str : tokens) {
    if (!str.equals("+") && !str.equals("-") && !str.equals("*") && !str.equals("/"))
        stack.push(str);
    else {
        int num1 = Integer.parseInt(stack.pop()), num2 = Integer.parseInt(stack.pop());
        switch (str) {
            case "+": stack.push(Integer.toString(num2 + num1)); break;
            case "-": stack.push(Integer.toString(num2 - num1)); break;
            case "*": stack.push(Integer.toString(num2 * num1)); break;
            case "/": stack.push(Integer.toString(num2 / num1)); break;
            default: break;
        }
    }
}
return Integer.parseInt(stack.pop());
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä¸­é—´å­—ç¬¦æ ¼å¼ç­‰è½¬æ¢ç›¸å¯¹éº»çƒ¦

#### 5ã€åŸºæœ¬è®¡ç®—å™¨

**é¢˜ç›®é“¾æ¥**
[LeetCode No.224](https://leetcode.cn/problems/basic-calculator/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int calculate(String s) {
        int len = s.length();
        int sign = 1;
        Deque<Integer> stack = new LinkedList<Integer>();
        stack.push(1);
        int i = 0;
        int result = 0;
        while (i < len) {
            if (s.charAt(i) == ' ')
                ++ i;
            else if (s.charAt(i) == '+') {
                sign = stack.peek();
                ++ i;
            } else if (s.charAt(i) == '-') {
                sign = - stack.peek();
                ++ i;
            } else if (s.charAt(i) == '(') {
                stack.push(sign);
                ++ i;
            } else if (s.charAt(i) == ')') {
                stack.pop();
                ++ i;
            } else {
                long num = 0;
                while (i < len && Character.isDigit(s.charAt(i))) {
                    num = 10 * num + s.charAt(i) - '0';
                    ++ i;
                }
                result += sign * num;
            }
        }
        return result;
    }
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- è®°å½•ä¸€ä¸ªç¬¦å·æ ˆï¼Œåœ¨é‡åˆ°æ‹¬å·å’Œå¼¹å‡ºæ‹¬å·æ—¶åŠ å…¥å’Œå¼¹å‡ºé˜”å·å‰çš„ç¬¦å·ï¼Œå¹¶ä¸æ–­ç»´æŠ¤è®¡ç®—ä¸€ä¸ªæœ€ç»ˆçš„result

### ä¸ƒã€é“¾è¡¨

#### 1ã€ç¯å½¢é“¾è¡¨

**é¢˜ç›®é“¾æ¥**
[LeetCode No.141](https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null)
        return false;
    ListNode fast = head.next, slow = head;
    while (slow != fast) {
        if (fast == null || fast.next == null)
            return false;
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å®šä¹‰ä¸€ä¸ªå¿«æŒ‡é’ˆå’Œä¸€ä¸ªæ…¢æŒ‡é’ˆï¼Œå¿«æŒ‡é’ˆæ¯æ¬¡å‘åç§»åŠ¨ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œæ»¡æŒ‡é’ˆæ¯æ¬¡ç§»åŠ¨ä¸€ä¸ªï¼Œè‹¥å¿«æŒ‡é’ˆè¿½ä¸Šæ»¡æŒ‡é’ˆåˆ™è¯´æ˜æœ‰ç¯ï¼Œè‹¥å¿«æŒ‡é’ˆç¢°åˆ°nullå€¼åˆ™æ— ç¯

#### 2ã€ä¸¤æ•°ç›¸åŠ 

**é¢˜ç›®é“¾æ¥**
[LeetCode No.2](https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    int pre = 0;
    ListNode result = new ListNode();
    ListNode cur = result;
    result.next = cur;
    while (l1 != null || l2 != null) {
        int num = 0;
        if (l1 != null && l2 != null)
            num = l1.val + l2.val + pre;
        else if (l1 == null)
            num = l2.val + pre;
        else
            num = l1.val + pre;
        ListNode temp = new ListNode();
        if (num >= 10) {
            temp.val = num % 10;
            pre = num / 10;
        }
        else {
            temp.val = num;
            pre = 0;
        }
        cur.next = temp;
        cur = temp;
        if (l1 != null)
            l1 = l1.next;
        if (l2 != null)
            l2 = l2.next;
    }
    if (pre != 0)
        cur.next = new ListNode(pre);
    return result.next;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- éå†ä¸¤é“¾è¡¨å¹¶ç›¸åŠ æ¯ä¸€ä¸ªæ•°ï¼Œè®°å½•è¿›ä½æ•°å¹¶ä½œç”¨ä¸åç»­çš„è®¡ç®—

#### 3ã€åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

**é¢˜ç›®é“¾æ¥**
[LeetCode No.21](https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// é€’å½’
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) {
        return l2;
    } else if (l2 == null) {
        return l1;
    } else if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}

// è¿­ä»£
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode prehead = new ListNode(-1);
    ListNode prev = prehead;
    while (l1 != null && l2 != null) {
        if (l1.val <= l2.val) {
            prev.next = l1;
            l1 = l1.next;
        } else {
            prev.next = l2;
            l2 = l2.next;
        }
        prev = prev.next;
    }
    // åˆå¹¶å l1 å’Œ l2 æœ€å¤šåªæœ‰ä¸€ä¸ªè¿˜æœªè¢«åˆå¹¶å®Œï¼Œæˆ‘ä»¬ç›´æ¥å°†é“¾è¡¨æœ«å°¾æŒ‡å‘æœªåˆå¹¶å®Œçš„é“¾è¡¨å³å¯
    prev.next = l1 == null ? l2 : l1;
    return prehead.next;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- é€’å½’æˆ–è¿­ä»£éƒ½å¯ä»¥

#### 4ã€éšæœºé“¾è¡¨çš„å¤åˆ¶

**é¢˜ç›®é“¾æ¥**
[LeetCode No.138](https://leetcode.cn/problems/copy-list-with-random-pointer/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public Node copyRandomList(Node head) {
    if (head == null) {
        return null;
    }
    if (!cachedNode.containsKey(head)) {
        Node headNew = new Node(head.val);
        cachedNode.put(head, headNew);
        headNew.next = copyRandomList(head.next);
        headNew.random = copyRandomList(head.random);
    }
    return cachedNode.get(head);
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨ä¸€ä¸ªMapå­˜å‚¨åŸé“¾è¡¨å’Œå·²æ‹·è´é“¾è¡¨èŠ‚ç‚¹çš„å¯¹åº”å…³ç³»ï¼Œå¹¶ä¸æ–­é€’å½’æ±‚å½“å‰èŠ‚ç‚¹çš„nextå’Œrandom

#### 5ã€åè½¬é“¾è¡¨â…¡

**é¢˜ç›®é“¾æ¥**
[LeetCode No.92](https://leetcode.cn/problems/reverse-linked-list-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public ListNode reverseBetween(ListNode head, int left, int right) {
    ListNode dummyNode = new ListNode(-1);
    dummyNode.next = head;
    ListNode pre = dummyNode;
    for (int i = 0; i < left-1; ++ i) {
        pre = pre.next;
    }
    ListNode cur = pre.next;
    ListNode leftHead = pre, rightTail = cur;
    for (int i = 0; i < right - left + 1; ++ i) {
        ListNode temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    leftHead.next = pre;
    rightTail.next = cur;
    return dummyNode.next;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- éå†åˆ°éœ€è¦åè½¬é“¾è¡¨å¤„å¼€å§‹åè½¬ï¼Œå¹¶è®°å½•åè½¬åçš„leftHeadå’ŒrightTailå€¼

#### 6ã€Kä¸ªä¸€ç»„ç¿»è½¬é“¾è¡¨

**é¢˜ç›®é“¾æ¥**
[LeetCode No.25](https://leetcode.cn/problems/reverse-nodes-in-k-group/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode dummyHead = new ListNode(-1, head);
    ListNode cur = head;
    ListNode pre = dummyHead;
    while (cur != null) {
        ListNode temp = pre;
        for (int i = 0; i < k; ++ i) {
            temp = temp.next;
            if (temp == null)
                return dummyHead.next;
        }
        ListNode next = temp.next;
        Reverse(cur, temp);
        pre.next = temp;
        cur.next = next;
        pre = cur;
        cur = next;
    }
    return dummyHead.next;
}

private void Reverse(ListNode left, ListNode right) {
    ListNode pre = new ListNode(-1, left);
    ListNode cur = left;
    while (pre != right) {
        ListNode temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- éå†æ•´ä¸ªé“¾è¡¨å¹¶ä¸æ–­æŸ¥çœ‹å½“å‰æ˜¯å¦æ»¡è¶³é•¿åº¦è¦æ±‚ï¼Œè‹¥æ»¡è¶³åˆ™å°†è¯¥é“¾è¡¨è¿›è¡Œåè½¬åå¹¶å…¥ç»“æœ

#### 7ã€åˆ é™¤é“¾è¡¨å€’æ•°ç¬¬Nå“¥èŠ‚ç‚¹

**é¢˜ç›®é“¾æ¥**
[LeetCode No.19](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
while (cur != null) {
    ++ count;
    cur = cur.next;
}
cur = dummyHead;
int lose = count - n + 1;
while (cur != null) {
    -- lose;
    if (lose == 0) {
        cur.next = cur.next.next;
        return dummyHead.next;
    } else
        cur = cur.next;
}
return dummyHead.next;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å…ˆæ±‚é“¾è¡¨é•¿åº¦ï¼Œè®°å½•è¦åˆ é™¤çš„é“¾è¡¨èŠ‚ç‚¹ä½ç½®åï¼Œåˆ é™¤è¿™ä¸ªèŠ‚ç‚¹ã€‚
- è¦ä½¿ç”¨dummyHead

#### 8ã€åˆ é™¤é“¾è¡¨ä¸­çš„é‡å¤å…ƒç´ 

**é¢˜ç›®é“¾æ¥**
[LeetCode No.82](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
if (head == null) {
    return head;
}

ListNode dummy = new ListNode(0, head)
ListNode cur = dummy;
while (cur.next != null && cur.next.next != null) {
    if (cur.next.val == cur.next.next.val) {
        int x = cur.next.val;
        while (cur.next != null && cur.next.val == x)
            cur.next = cur.next.next;
        }
    } else {
        cur = cur.next;
    }
}

return dummy.next;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨curèŠ‚ç‚¹ä¸æ–­å‘åæ¢æµ‹æ˜¯å¦æœ‰ç›¸åŒèŠ‚ç‚¹å€¼ï¼Œè‹¥æœ‰åˆ™ä¸€ç›´å¾ªç¯ç›´åˆ°æ‰¾åˆ°éç›¸åŒçš„èŠ‚ç‚¹ã€‚

#### 8ã€æ—‹è½¬é“¾è¡¨

**é¢˜ç›®é“¾æ¥**
[LeetCode No.61](https://leetcode.cn/problems/rotate-list/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public ListNode rotateRight(ListNode head, int k) {
    if (k == 0 || head == null || head.next == null) {
        return head;
    }
    int n = 1;
    ListNode iter = head;
    while (iter.next != null) {
        iter = iter.next;
        n++;
    }
    int add = n - k % n;
    if (add == n) {
        return head;
    }
    iter.next = head;
    while (add-- > 0) {
        iter = iter.next;
    }
    ListNode ret = iter.next;
    iter.next = null;
    return ret;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ç¬¬ä¸€æ¬¡éå†ï¼Œè®¡æ•°é¡ºä¾¿å°†æŒ‡é’ˆæ”¾ç½®åœ¨æœ€å
- ç¬¬äºŒæ¬¡éå†ï¼Œè·å–åˆ°n-kå¤„æŒ‡é’ˆï¼Œå†æ‹¼æ¥ä¸ºæ–°çš„æ—‹è½¬é“¾è¡¨

#### 9ã€åˆ†éš”é“¾è¡¨

**é¢˜ç›®é“¾æ¥**
[LeetCode No.86](https://leetcode.cn/problems/partition-list/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
ListNode dummyHead = new ListNode(-1, head);
ListNode cur = dummyHead;
while (cur.next != null && cur.next.val < x) {
    cur = cur.next;
}
ListNode pre = cur;
cur = cur.next;
while (cur != null) {
    if (cur.next != null && cur.next.val < x) {
        ListNode temp = cur.next;
        // æ¥ä¸ŠååŠéƒ¨åˆ†
        cur.next = cur.next.next;
        // å¡å…¥å‰åŠéƒ¨åˆ†ï¼Œå¹¶ç§»åŠ¨å‰åŠéƒ¨åˆ†
        temp.next = pre.next;
        pre.next = temp;
        pre = pre.next;
    } else
        cur = cur.next;
}
return dummyHead.next;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ç”¨ä¸€ä¸ªpreè®°å½•å°äºxçš„éƒ¨åˆ†çš„èŠ‚ç‚¹ä½ç½®ï¼Œç”¨curéå†åç»­èŠ‚ç‚¹ï¼Œè‹¥ä¸ç¬¦åˆåˆ™æ’å…¥preèŠ‚ç‚¹å

#### 10ã€LRUç¼“å­˜

**é¢˜ç›®é“¾æ¥**
[LeetCode No.146](https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class LRUCache {

    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
    private int size;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // ä½¿ç”¨ä¼ªå¤´éƒ¨å’Œä¼ªå°¾éƒ¨èŠ‚ç‚¹
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null)
            return -1;
        moveToHead(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            DLinkedNode newNode = new DLinkedNode(key,value);
            cache.put(key, newNode);
            addToHead(newNode);
            ++ size;
            if (size > capacity) {
                DLinkedNode tail = removeTail();
                cache.remove(tail.key);
                -- size;
            }
        } else {
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }

    private DLinkedNode removeTail() {
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨å“ˆå¸Œè¡¨+åŒå‘é“¾è¡¨å®ç°
- å“ˆå¸Œè¡¨ä¸­å­˜æ”¾åŒå‘é“¾è¡¨ä¸­çš„å…·ä½“èŠ‚ç‚¹
- åœ¨å†™çš„æ—¶å€™ï¼Œå¯ä»¥å…ˆå®ç°addToHead, removeTail, removeNode, moveTOHeadç­‰å­å‡½æ•°

### å…«ã€äºŒå‰æ ‘

#### 1ã€äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

**é¢˜ç›®é“¾æ¥**
[LeetCode No.104](https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
private int travesal(TreeNode node, int level) {
    if (node == null) 
        return level;
    int left = travesal(node.left, level) + 1;
    int right = travesal(node.right, level) + 1;
    return Math.max(left, right);
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä¼ å…¥å½“å‰å±‚çš„ä¸Šå±‚çš„levelï¼Œè®¡ç®—å½“å‰å±‚çš„æœ€å¤§å±‚æ•°

#### 2ã€ç›¸åŒçš„æ ‘

**é¢˜ç›®é“¾æ¥**
[LeetCode No.100](https://leetcode.cn/problems/same-tree/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
private boolean traversal(TreeNode p, TreeNode q) {
    if (p == null && q == null)
        return true;
    else if (p == null || q == null)
        return false;
    else if (p.val != q.val)
        return false;
    boolean left = traversal(p.left, q.left);
    boolean right = traversal(p.right, q.right);
    return left && right;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åˆ¤æ–­pqæ˜¯å¦éƒ½ä¸ºç©ºï¼Œæˆ–è€…ä¸€ä¸ªä¸ºç©ºï¼Œæˆ–éƒ½ä¸ä¸ºç©ºçš„æƒ…å†µçš„å‰æä¸‹ï¼Œå†åˆ¤æ–­æ˜¯å¦ç›¸ç­‰

#### 3ã€ç¿»è½¬äºŒå‰æ ‘

**é¢˜ç›®é“¾æ¥**
[LeetCode No.226](https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
private TreeNode traversal(TreeNode node) {
    if (node == null)
        return node;
    traversal(node.left);
    traversal(node.right);
    TreeNode temp = node.left;
    node.left = node.right;
    node.right = temp;
    return node;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å‰åºæˆ–åç»­éå†å³å¯

#### 4ã€å¯¹ç§°äºŒå‰æ ‘

**é¢˜ç›®é“¾æ¥**
[LeetCode No.101](https://leetcode.cn/problems/symmetric-tree/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
private boolean compare(TreeNode left, TreeNode right) {
    if (left == null && right == null)
        return true;
    else if (left == null || right == null)
        return false;
    else if (left.val != right.val)
        return false;
    return compare(left.left, right.right) && compare(left.right, right.left);
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åŒæ ·æ˜¯å…ˆåˆ¤æ–­ç©ºèŠ‚ç‚¹ï¼Œå†åˆ¤æ–­æœ‰å®æ•°çš„èŠ‚ç‚¹ï¼Œå…ˆåºéå†

#### 5ã€ä»å‰åºéå†ä¸ä¸­åºéå†æ„é€ äºŒå‰æ ‘

**é¢˜ç›®é“¾æ¥**
[LeetCode No.105](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
private TreeNode build(int[] preorder, int[] inorder, int prestart, int preend, int instart, int inend) {
    if (prestart == preend)
        return null;
    
    int rootVal = preorder[prestart];
    TreeNode node = new TreeNode(rootVal);
    int inmiddle = instart;
    while (inmiddle < inend && inorder[inmiddle] != rootVal)
        ++inmiddle;
    
    int leftSize = inmiddle - instart;
    node.left = build(preorder, inorder, prestart + 1, prestart + 1 + leftSize, instart, inmiddle);
    node.right = build(preorder, inorder, prestart + 1 + leftSize, preend, inmiddle + 1, inend);
        
    return node;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- é€’å½’ç”Ÿæˆå­æ ‘ï¼Œè·å–å¹¶æ„å»ºæ ‘çš„æ ¹èŠ‚ç‚¹åï¼Œæ‰¾åˆ°å­æ ‘çš„èŒƒå›´åé€’å½’æ„å»º

#### 6ã€ä»ä¸­åºä¸åç»­éå†åºåˆ—æ„é€ äºŒå‰æ ‘

**é¢˜ç›®é“¾æ¥**
[LeetCode No.106](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
private TreeNode build(int[] inorder, int[] postorder, int instart, int inend, int poststart, int postend) {
    if (instart == inend)
        return null;
    int nodeVal = postorder[postend-1];
    TreeNode node = new TreeNode(nodeVal);  
    int inmiddle = instart;
    while (inmiddle < inend && inorder[inmiddle] != nodeVal)
        ++ inmiddle;
        
    int offset = inmiddle - instart;
    node.left = build(inorder, postorder, instart, inmiddle, poststart, poststart + offset);
    node.right = build(inorder, postorder, inmiddle+1, inend, poststart + offset, postend - 1);
        
    return node;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åŒä¸Šé¢˜

#### 7ã€å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II

**é¢˜ç›®é“¾æ¥**
[LeetCode No.117](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// å±‚æ¬¡éå†
public Node connect(Node root) {
    if (root == null)
        return null;
    Deque<Node> queue = new LinkedList<Node>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int levelSize = queue.size();
        for (int i = 0; i < levelSize; ++ i) {
            Node cur = queue.poll();
            if (i != levelSize - 1)
                cur.next = queue.peek();
            else
                cur.next = null;
            if (cur.left != null)
                queue.offer(cur.left);
            if (cur.right != null)
            queue.offer(cur.right);
        }
    }
    return root;
}

// åœ¨éå†å½“å‰å±‚çš„æ—¶å€™æ‰§è¡Œä¸‹ä¸€å±‚çš„é“¾æ¥
// æˆ‘æ„¿ç§°ä¹‹ä¸ºæƒŠå¤©å¦™æ‰‹
public Node connect(Node root) {
    if (root == null) {
        return null;
    }
    Node head = root; // å½“å‰å±‚çš„å¤´èŠ‚ç‚¹
    // å¾ªç¯éå†æ¯ä¸€å±‚ï¼Œä»ä¸Šè‡³ä¸‹
    while (head != null) {
        Node dummy = new Node(0); //ä¸‹ä¸€å±‚çš„è™šæ‹Ÿå¤´èŠ‚ç‚¹
        Node temp = dummy; //å½“å‰å¤„ç†çš„èŠ‚ç‚¹
        // éå†å½“å‰å±‚ï¼Œè¿æ¥ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹
        for (Node cur = head; cur != null; cur = cur.next) 
            if (cur.left != null) {
                temp.next = cur.left;
                temp = temp.next; //ç§»åŠ¨temp
            }
            if (cur.right != null) {
                temp.next = cur.right;
                temp = temp.next; //ç§»åŠ¨temp
            }
        }
        // ç§»åŠ¨åˆ°ä¸‹ä¸€å±‚çš„å®é™…å¤´èŠ‚ç‚¹å¤„
        head = dummy.next;
    }
    return root;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å¯ä»¥ä½¿ç”¨å±‚æ¬¡éå†ï¼Œè®°ä½åœ¨å†…éƒ¨ä½¿ç”¨ä¸€ä¸ªå¾ªç¯è®°å½•å½“å‰å±‚
- åœ¨æ­¤åŸºç¡€ä¸Šä¼˜åŒ–ï¼Œå¯ä»¥ä¸ç”¨é˜Ÿåˆ—ç›´æ¥åœ¨å½“å‰åˆ—å°†ä¸‹ä¸€åˆ—çš„èŠ‚ç‚¹ç©¿èµ·æ¥ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(1)

#### 8ã€äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

**é¢˜ç›®é“¾æ¥**
[LeetCode No.114](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
private TreeNode traversal(TreeNode node) {
    if (node == null)
        return null;
    TreeNode left = traversal(node.left);
    node.left = null;
    TreeNode temp = node.right;
    if (left == null)
        node.right = traversal(temp);
    else {
        node.right = left;
        while (left.right != null) 
            left = left.right;
        left.right = traversal(temp);
    }
    return node;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å…ˆå¤„ç†å·¦ä¾§ï¼Œå·¦ä¾§å¤„ç†å®Œåè®°å½•å¹¶å°†å·¦ä¾§ç½®ä¸ºç©ºï¼Œå†å¤„ç†å³ä¾§ã€‚è‹¥å·¦ä¾§å¤„ç†ç»“æœä¸ºç©ºåˆ™å°†å³ä¾§ç»“æœæŒ‚åœ¨å³èŠ‚ç‚¹ä¸Šï¼Œå¦åˆ™éå†å·¦ä¾§ç»“æœï¼Œå¹¶å°†å³ä¾§ç»“æœæŒ‚åœ¨å·¦ä¾§ç»“æœçš„åé¢

#### 9ã€è·¯å¾„æ€»å’Œ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.]()

**æ ¸å¿ƒä»£ç **ï¼š

```java
public boolean hasPathSum(TreeNode root, int targetSum) {
    return root == null ? false : traversal(root, targetSum, 0);
}
private boolean traversal(TreeNode node, int targetSum, int curSum) {
    curSum += node.val;
    if (node.left == null && node.right == null && curSum == targetSum)
        return true;
    boolean left = node.left == null ? false : traversal(node.left, targetSum, curSum);
    boolean right = node.right == null ? false : traversal(node.right, targetSum, curSum);
    return left || right;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ç”¨é€’å½’çš„æ–¹æ³•ï¼Œå½“åˆ¤æ–­åˆ°å¶å­èŠ‚ç‚¹ä¸”å½“å‰çš„è·¯å¾„å’Œç­‰äºç›®æ ‡å’Œçš„æ—¶å€™è¿”å›trueï¼Œæœ€ç»ˆç»“æœåªè¦æœ‰ä¸€æ¬¡è¿”å›trueå°±æ˜¯ç¬¦åˆæ¡ä»¶çš„

#### 10ã€æ±‚æ ¹èŠ‚ç‚¹åˆ°å¶èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.129](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
private int sum = 0;

public int sumNumbers(TreeNode root) {
    if (root == null)
        return 0;
    traversal(root, 0);
    return sum;
}
private void traversal(TreeNode root, int curSum) {
    curSum = curSum*10 + root.val;
    if (root.left == null && root.right == null) {
        sum += curSum;
        return;
    }
    if (root.left != null)
        traversal(root.left, curSum);
    if (root.right != null)
    traversal(root.right, curSum);
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ç”¨é€’å½’çš„æ–¹æ³•ï¼Œå­˜ä¸€ä¸ªå…¨å±€çš„sumå€¼ï¼Œè‹¥éå†åˆ°å¶å­èŠ‚ç‚¹åˆ™åœ¨sumçš„åŸºç¡€ä¸ŠåŠ ä¸Šè¿™ä¸ªè·¯å¾„çš„æ•°å€¼ï¼Œè‹¥å¶å­èŠ‚ç‚¹ä¸ºnullåˆ™ä¸ç»§ç»­è®¡ç®—

#### 11ã€äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.124](https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
int maxSum = Integer.MIN_VALUE;

public int maxPathSum(TreeNode root) {
    maxGain(root);
    return maxSum;
}
private int maxGain(TreeNode node) {
    if (node == null)
        return 0;
    
    int leftGain = Math.max(maxGain(node.left), 0);
    int rightGain = Math.max(maxGain(node.right), 0);

    int priceNewpath = node.val + leftGain + rightGain;

    maxSum = Math.max(maxSum, priceNewpath);

    return node.val + Math.max(leftGain, rightGain);
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- é€’å½’è§£å†³ã€‚
- é€’å½’è¿‡ç¨‹ä¸­ä½¿ç”¨åç»­éå†ï¼ˆå·¦å³å­æ ‘çš„æœ€å¤§è·¯å¾„å’Œï¼‰ï¼Œå…ˆè®¡ç®—å‡ºå½“å‰èŠ‚ç‚¹ä¸ºè·¯å¾„ä¸­å¿ƒçš„æœ€å¤§è·¯å¾„å’Œï¼Œå¹¶ä¸å½“å‰maxSumæ¯”è¾ƒã€‚è¿”å›å€¼ä¸ºå½“å‰å€¼ä¸å·¦å³å­æ ‘æ›´å¤§è·¯å¾„å’Œçš„åŠ å’Œã€‚
- å¯ä»¥çœ‹ä½œä¸¤ä¸ªæ­¥éª¤ï¼Œä¸€ä¸ªæ˜¯æ±‚å½“å‰èŠ‚ç‚¹çš„æœ€å¤§è·¯å¾„å’Œï¼Œä¸€ä¸ªæ˜¯ç”¨å½“å‰èŠ‚ç‚¹ä½œä¸ºè·¯å¾„å’Œä¸­å¿ƒçš„è·¯å¾„å’Œ ä¸ å½“å‰æœ€å¤§è·¯å¾„å’Œå¯¹æ¯”è®¡ç®— å¾—å‡ºå½“å‰çœŸæ­£çš„æœ€å¤§è·¯å¾„å’Œ

#### 12ã€äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨

**é¢˜ç›®é“¾æ¥**
[LeetCode No.173](https://leetcode.cn/problems/binary-search-tree-iterator/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
private class ListNode {

    int val;
    ListNode next;
    public ListNode() {}
    public ListNode(int val) {
        this.val = val;
    }
}
ListNode index;
public BSTIterator(TreeNode root) {
    index = new ListNode(-1);
    ListNode head = index;
    traversal(root);
    index = head;
}
private void traversal(TreeNode node) {
    if (node == null)
        return;
    traversal(node.left);
    index.next = new ListNode(node.val);
    index = index.next;
    traversal(node.right);
}

public int next() {
    index = index.next;
    return index.val;
}

public boolean hasNext() {
    return index.next != null;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨é“¾è¡¨å­˜å‚¨ä¸­åºéå†äºŒå‰æ ‘çš„ç»“æœ

#### 13ã€å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°

**é¢˜ç›®é“¾æ¥**
[LeetCode No.222](https://leetcode.cn/problems/count-complete-tree-nodes/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int countNodes(TreeNode root) {
    if (root == null)
        return 0;
    int left = countNodes(root.left);
    int right = countNodes(root.right);
    return 1 + left + right;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- é€’å½’åç»­éå†ï¼Œè¿”å›å·¦å³å­æ ‘çš„èŠ‚ç‚¹æ•°+1ä½œä¸ºå½“å‰èŠ‚ç‚¹çš„ä¸ªæ•°

#### 14ã€äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.236](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q)
        return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if (left != null && right != null) {
        return root;
    }
    if (left != null) {
        return left;
    }
    return right;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- è‹¥å·¦å³èŠ‚ç‚¹è®¡ç®—è¿”å›pæˆ–qï¼Œåˆ™è¿”å›å·¦å³èŠ‚ç‚¹çš„è¿”å›å€¼ã€‚è‹¥å·¦å³èŠ‚ç‚¹åˆ†åˆ«è¿”å›på’Œqï¼Œåˆ™è¿”å›å½“å‰èŠ‚ç‚¹

### ä¹ã€äºŒå‰æ ‘å±‚æ¬¡éå†

#### 1ã€äºŒå‰æ ‘çš„å³è§†å›¾

**é¢˜ç›®é“¾æ¥**
[LeetCode No.199](https://leetcode.cn/problems/binary-tree-right-side-view/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// å±‚åºéå†
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null)
        return result;
    Deque<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; ++ i) {
            TreeNode cur = queue.poll();
            if (i == size - 1)
                result.add(cur.val);
            if (cur.left != null)
                queue.offer(cur.left);
            if (cur.right != null)
                queue.offer(cur.right);
        }
    }
    return result;
}

// dfs
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> ans = new LinkedList<>();
    dfs(root, 1, ans);
    return ans;
}

public void dfs(TreeNode node, int i, List<Integer> ans) {
    if (node == null) {
        return;
    }
    if (i > ans.size()) {
        ans.add(node.val);
    }
    dfs(node.right, i+1, ans);
    dfs(node.left, i+1, ans);
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å±‚åºéå†ï¼šè·å–æ¯è¡Œæœ€åä¸€ä¸ªç‚¹
- æ·±åº¦ä¼˜å…ˆï¼šå¯¹äºæ¯ä¸€è¡Œï¼Œå…ˆéå†å³å­æ ‘å†éå†å·¦å­æ ‘ï¼Œè¿™æ ·å³å­æ ‘çš„æœ€å³ä¾§è‚¯å®šä¼šå…ˆè¢«éå†åˆ°ã€‚æ¯æ¬¡éå†æ—¶æ£€éªŒå½“å‰å±‚çš„ç»“æœListæ˜¯å¦å­˜åœ¨å€¼ï¼Œè‹¥ä¸å­˜åœ¨åˆ™å°†ç¬¬ä¸€ä¸ªéå†åˆ°çš„å€¼å¡«å…¥

#### 2ã€äºŒå‰æ ‘çš„å±‚å¹³å‡å€¼

**é¢˜ç›®é“¾æ¥**
[LeetCode No.637](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
List<Double> result = new ArrayList<>();
if (root == null)
    return result;
Deque<TreeNode> queue = new LinkedList<TreeNode>();
queue.offer(root);
while (!queue.isEmpty()) {
    int size = queue.size();
    double sum = 0.0;
    for (int i = 0; i < size; ++ i) {
        TreeNode cur = queue.poll();
        sum += cur.val;
        if (cur.left != null)
            queue.offer(cur.left);
        if (cur.right != null)
            queue.offer(cur.right);
    }
    result.add(sum / size);
}
return result;
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åŒæ ·ä½¿ç”¨å±‚æ¬¡éå†ç»Ÿè®¡æ¯ä¸€å±‚çš„æ•°å€¼å¹³å‡å€¼å¹¶åŠ å…¥ç»“æœ

#### 3ã€äºŒå‰æ ‘çš„å±‚åºéå†

**é¢˜ç›®é“¾æ¥**
[LeetCode No.102](https://leetcode.cn/problems/binary-tree-level-order-traversal/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null)
        return result;
    Deque<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> levelResult = new ArrayList<>();
        for (int i = 0; i < size; ++ i) {
            TreeNode cur = queue.poll();
            levelResult.add(cur.val);
            if (cur.left != null)
                queue.offer(cur.left);
            if (cur.right != null)
                queue.offer(cur.right);
        }
        result.add(levelResult);
    }
    return result;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å’Œå‰ä¸¤ä¸ªä½¿ç”¨åŒä¸€å¥—ä»£ç 

#### 4ã€äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†

**é¢˜ç›®é“¾æ¥**
[LeetCode No.103](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null)
        return result;
    Deque<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    int order = 1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> levelResult = new ArrayList<>();
        for (int i = 0; i < size; ++ i) {
            TreeNode cur = queue.poll();
            if (order == 1)
                levelResult.add(cur.val);
            else
                levelResult.add(0, cur.val);
            if (cur.left != null)
                queue.offer(cur.left);
            if (cur.right != null)
                queue.offer(cur.right);
        }
        result.add(levelResult);
        order *= -1;
    }
    return result;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨orderåˆ¤æ–­æ’å…¥æ–¹å¼
- æˆ–è€…ä½¿ç”¨Collections.reverse(list)

### åã€äºŒå‰æœç´¢æ ‘


#### 1ã€äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®

**é¢˜ç›®é“¾æ¥**
[LeetCode No.530](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
private int result = Integer.MAX_VALUE;
private int lastValue = -1;
public int getMinimumDifference(TreeNode root) {
    traversal(root);
    return result;
}
private void traversal(TreeNode node) {
    if (node == null)
        return;
    traversal(node.left);
    if (lastValue == -1)
        lastValue = node.val;
    else {
        result = Math.min(result, node.val - lastValue);
        lastValue = node.val;
    }
    traversal(node.right);
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä¸æ–­æ›´æ–°lastValueå’Œresult
- è¦åˆ¤æ–­lastValueæ˜¯å¦ä¸ºåˆå§‹å€¼ï¼Œè‹¥ä¸ºåˆå§‹å€¼åˆ™ä¸åšæ“ä½œ

#### 2ã€äºŒå‰æœç´¢æ ‘ä¸­ç¬¬ K å°çš„å…ƒç´ 

**é¢˜ç›®é“¾æ¥**
[LeetCode No.230](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?envType=study-plan-v2&envId=top-interview-150)


**æ ¸å¿ƒä»£ç **ï¼š

```java
private int count = 0;

private int result = -1;

public int kthSmallest(TreeNode root, int k) {
    traversal(root, k);
    return result;
}

private void traversal(TreeNode node, int k) {
    if (node == null)
        return;
    traversal(node.left, k);
    ++ count;
    if (count == k)
        result = node.val;
    traversal(node.right, k);
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä¸­åºéå†å¹¶è®¡æ•°ï¼Œç›´åˆ°æ•°é‡è¾¾åˆ°kè®°å½•result

#### 3ã€éªŒè¯äºŒå‰æœç´¢æ ‘

**é¢˜ç›®é“¾æ¥**
[LeetCode No.98](https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-interview-150)


**æ ¸å¿ƒä»£ç **ï¼š

```java
private long maxValue = Long.MIN_VALUE;

public boolean isValidBST(TreeNode root) {
    if (root == null)
        return true;
    if (!isValidBST(root.left))
        return false;
    if (root.val <= maxValue)
        return false;
    maxValue = root.val;
    return isValidBST(root.right);
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ¯æ¬¡éå†æ—¶éƒ½è®°å½•å½“å‰çš„nodeçš„å€¼ä¸ºæœ€å¤§å€¼
- åœ¨æ¯æ¬¡éå†è¿‡ç¨‹ä¸­ï¼Œå…ˆåˆ¤æ–­å·¦å­æ ‘æ˜¯å¦ç¬¦åˆæ¡ä»¶ï¼Œååˆ¤æ–­nodeå€¼æ˜¯å¦å¤§äºå·¦èŠ‚ç‚¹ï¼Œå†åˆ¤æ–­å³å­æ ‘æ˜¯å¦ç¬¦åˆæ¡ä»¶

### åä¸€ã€å›¾

#### 1ã€å²›å±¿æ•°é‡

**é¢˜ç›®é“¾æ¥**
[LeetCode No.200](https://leetcode.cn/problems/number-of-islands/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
private int[][] dir = { {0,1},{-1,0},{0,-1},{1,0} };

private void dfs(int x, int y, char[][] grid) {
    for (int i = 0; i < 4; ++ i) {
        int nextx = x + dir[i][0];
        int nexty = y + dir[i][1];
        if (nextx < 0 || nexty <0 || nextx >= grid.length ||nexty >= grid[0].length) 
            continue;
        if (grid[nextx][nexty] =='1') {
            grid[nextx][nexty] = '2';
            dfs(nextx, nexty, grid);
        }
    }
}
public int numIslands(char[][] grid){
    int row = grid.length, col = gri[0].length;
    int result = 0;
    for (int i = 0; i < row; ++ i)
        for (int j = 0; j < col; ++j)
            if (grid[i][j] == '1') {
                ++ result;
                grid[i][j] = '2';
                dfs(i, j, grid);
            }
    return result;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- é’ˆå¯¹æ‰€æœ‰å€¼ä¸º1çš„æ ¼å­è¿›è¡Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œè‹¥è®¿é—®è¿‡åˆ™å°†å€¼è®¾ä¸º2ï¼Œé¿å…é‡å¤è®¿é—®ã€‚

#### 2ã€è¢«å›´ç»•çš„åŒºåŸŸ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.130](https://leetcode.cn/problems/surrounded-regions/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public void solve(char[][] board) {
    int row = board.length, col =board[0].length;
    for (int i = 0; i < row; i++) {
        dfs(board, i, 0);
        dfs(board, i, col - 1);
    }
    for (int i = 1; i < col; i++) {
        dfs(board, 0, i);
        dfs(board, row - 1, i);
    }
    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; ++) {
            if (board[i][j] == 'A') {
                board[i][j] = 'O';
            } else if (board[i][j]== 'O') {
                board[i][j] = 'X';
            }
        }
    }
}
public void dfs(char[][] board, intx, int y) {
    if (x < 0 || x >= boardlength || y < 0 || y >= board[0]length || board[x][y] != 'O')
        return;
    board[x][y] = 'A';
    dfs(board, x + 1, y);
    dfs(board, x - 1, y);
    dfs(board, x, y + 1);
    dfs(board, x, y - 1);
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å¯¹è¾¹ç¼˜æ ¼å­è¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†ï¼Œè‹¥å°†è¾¹ç¼˜ä»¥åŠå»¶ç”³åˆ°å†…éƒ¨çš„å€¼ä¸º'O'çš„æ ¼å­è®¾ç½®å€¼ä¸ºAï¼Œå…¶ä½™ä¸åŠ¨ã€‚åé‡æ–°éå†æ•´ä¸ªç½‘æ ¼ï¼Œå°†å€¼ä¸ºOçš„å…¨éƒ¨æ›¿æ¢æˆXï¼ŒAçš„æ›¿æ¢æˆOï¼Œå³å¯ã€‚

#### 3ã€å…‹éš†å›¾

**é¢˜ç›®é“¾æ¥**
[LeetCode No.133](https://leetcode.cn/problems/clone-graph/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
private HashMap<Node, Node> visited = new HashMap<>();

public Node cloneGraph(Node node) {
    if (node == null)
        return node;
    if (visited.containsKey(node))
        return visited.get(node);
    Node cloneNode = new Node(nodeval, new ArrayList<>());
    visited.put(node, cloneNode);
    for (Node neighbor : nodeneighbors)
        cloneNode.neighbors.ad(cloneGraph(neighbor));
    return cloneNode;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å»ºç«‹ä¸€ä¸ªMapå¯¹åº”å·²æœ‰èŠ‚ç‚¹å’Œæ–°å»ºèŠ‚ç‚¹
- è‹¥visitedä¸­å­˜åœ¨æ–°å»ºèŠ‚ç‚¹åˆ™è¿”å›æ–°å»ºèŠ‚ç‚¹ï¼Œè‹¥ä¸å­˜åœ¨åˆ™æ–°å»ºèŠ‚ç‚¹åå°†å…¶æ”¾å…¥visitedä¸­ï¼Œå¹¶éå†å½“å‰èŠ‚ç‚¹çš„neighbourå¹¶åŒæ­¥æ‰§è¡ŒcloneNodeå‡½æ•°å°†ç»“æœæ”¾å…¥æ–°å»ºèŠ‚ç‚¹çš„neighboursä¸­
- æ·±æ‹·è´çš„é¢˜ç›®ï¼Œç›´æ¥è€ƒè™‘æ„å»ºä¸€ä¸ªMapä½¿åŸæœ‰å…ƒç´ å’Œæ–°å…ƒç´ å¯¹åº”ï¼Œå†é€’å½’åˆ›å»º

#### 4ã€é™¤æ³•æ±‚å€¼

**é¢˜ç›®é“¾æ¥**
[LeetCode No.399](https://leetcode.cn/problems/evaluate-division/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
    int nvars = 0;
    Map<String, Integer> variables =new HashMap<String, Integer>();
    int n = equations.size();
    for (int i = 0; i < n; i++) {
        if (!variables.containsKe(equations.get(i).get(0))) {
            variables.put(equationsget(i).get(0), nvars++);
        }
        if (!variables.containsKe(equations.get(i).get(1))) {
            variables.put(equationsget(i).get(1), nvars++);
        }
    }
    double[][] graph = new doubl[nvars][nvars];
    for (int i = 0; i < nvars; i++) {
        Arrays.fill(graph[i], -1.0);
    }
    for (int i = 0; i < n; i++) {
        int va = variables.ge(equations.get(i).get(0)),vb = variables.get(equationsget(i).get(1));
        graph[va][vb] = values[i];
        graph[vb][va] = 1.0 / value[i];
    }
    for (int k = 0; k < nvars; k++) {
        for (int i = 0; i < nvars; ++) {
            for (int j = 0; j <nvars; j++) {
                if (graph[i][k] >1e-6 && graph[k][j]> 1e-6) {
                    graph[i][j] =graph[i][k] *graph[k][j];
                }
            }
        }
    }
    int queriesCount = queries.siz();
    double[] ret = new doubl[queriesCount];
    for (int i = 0; i <queriesCount; i++) {
        List<String> query = queriesget(i);
        double result = -1.0;
        if (variables.containsKe(query.get(0)) && variablescontainsKey(query.get(1))) {
            int ia = variables.ge(query.get(0)), ib =variables.get(query.ge(1));
            if (graph[ia][ib] > 0) {
                result = graph[ia[ib]];
            }
        }
        ret[i] = result;
    }
    return ret;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å¼—æ´›ä¼Šå¾·ç®—æ³•è§£é¢˜
- å°†æ‰€æœ‰å­—ç¬¦å­˜åœ¨ä¸€ä¸ªMapä¸­ï¼Œå¹¶ä½¿ç”¨ä¸€ä¸ªå›¾å­˜æ”¾æ‰€æœ‰çš„å­—ç¬¦ï¼ˆn*nï¼‰ï¼Œåœ¨å›¾ä¸­å¡«æ»¡-1ï¼Œè‹¥å˜é‡é—´æœ‰é™¤æ³•å…³ç³»åˆ™åœ¨å›¾ä¸­è®°å½•ã€‚
- ä½¿ç”¨å¼—æ´›ä¼Šå¾·ç®—æ³•ï¼Œè®¡ç®—å˜é‡ä¹‹é—´èƒ½å¤Ÿç›¸äº’è®¡ç®—ç»“æœï¼ˆé€šè¿‡ä¸­é—´å€¼ï¼‰çš„æœ€å°è·¯å¾„ï¼Œå¹¶è®°å½•å…¶å€¼ã€‚
- éå†querieså¹¶æ‰¾åˆ°å›¾å†…éƒ¨æ˜¯å¦æœ‰ç›¸å…³çš„è·¯å¾„ï¼Œè‹¥æœ‰åˆ™è®°å½•ï¼Œæ²¡æœ‰åˆ™è®¾ç½®ä¸º-1ã€‚

#### 5ã€è¯¾ç¨‹è¡¨

**é¢˜ç›®é“¾æ¥**
[LeetCode No.207](https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// æ·±æœ
List<List<Integer>> edges;
int[] visited;
boolean valid = true;
public boolean canFinish(intnumCourses, int[][] prerequisites) {
    edges = new ArrayList<List<Integer>>();
    for (int i = 0; i < numCourses;++i) {
        edges.add(new ArrayList<Integer>());
    }
    visited = new int[numCourses];
    for (int[] info : prerequisites){
        edges.get(info[1]).add(info[0]);
    }
    for (int i = 0; i <numCourses && valid; ++ i)
        if (visited[i] == 0)
            dfs(i);
    return valid;
}
private void dfs(int u) {
    visited[u] = 1;
    for (int v : edges.get(u)) {
        if (visited[v] == 0) {
            dfs(v);
            if (!valid) {
                return;
            }
        } else if (visited[v] == 1) {
            valid = false;
            return;
        }
    }
    visited[u] = 2;
}

// å¹¿æœ
List<List<Integer>> edges;
int[] indeg;

public boolean canFinish(intnumCourses, int[][] prerequisites) {
    edges = newArrayList<List<Integer>>();
    for (int i = 0; i < numCourses;++i) {
        edges.add(newArrayList<Integer>());
    }
    indeg = new int[numCourses];
    for (int[] info : prerequisites){
        edges.get(info[1]).add(inf[0]);
        ++indeg[info[0]];
    }
    Queue<Integer> queue = newLinkedList<Integer>();
    for (int i = 0; i < numCourses;++i) {
        if (indeg[i] == 0) {
            queue.offer(i);
        }
    }
    int visited = 0;
    while (!queue.isEmpty()) {
        ++visited;
        int u = queue.poll();
        for (int v: edges.get(u)) {
            --indeg[v];
            if (indeg[v] == 0) {
                queue.offer(v);
            }
        }
    }
    return visited == numCourses;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨æ‹“æ‰‘æ’åºæ–¹æ³•ï¼Œé€šè¿‡ä½¿ç”¨ä¸€ä¸ªvisitæ•°ç»„è®°å½•èŠ‚ç‚¹çš„éå†çŠ¶æ€ï¼ˆ0æœªéå†ï¼Œ1å½“å‰éå†åˆ°ï¼Œ2éå†å®Œæˆï¼‰ï¼Œè‹¥å‡ºç°äº†é‡å¤æœç´¢çš„é—®é¢˜åˆ™ç«‹åˆ»è¿”å›falseè¡¨ç¤ºæ— æ³•å­¦å®Œæ‰€æœ‰è¯¾ç¨‹ï¼Œå…¨éƒ¨æœç´¢å®Œæ¯•ååˆ™è¿”å›true
- æ·±æœï¼šé€†å‘æ€ç»´ï¼Œåœ¨è¯¾ç¨‹çš„æ‰€æœ‰å‰ç½®è¯¾ç¨‹ä¸­æ·±åº¦æœç´¢ï¼Œè‹¥ç¢°åˆ°å¾ªç¯åˆ™è¿”å›false
- å¹¿æœï¼šæ­£å‘æ€ç»´ï¼Œä½¿ç”¨æ•°ç»„å­˜æ”¾æ¯ä¸ªèŠ‚ç‚¹çš„å‰ç½®æ•°é‡ï¼Œå¹¶ä½¿ç”¨é˜Ÿåˆ—ï¼Œè‹¥å‰ç½®èŠ‚ç‚¹æ•°é‡ä¸º0åˆ™å…¥é˜Ÿï¼Œå‡ºé˜Ÿæ—¶è®¡æ•°å¹¶å‡å»æ‰€æœ‰å‰ç½®é˜Ÿåˆ—åŒ…å«å½“å‰å‡ºé˜ŸèŠ‚ç‚¹çš„æ•°é‡ï¼Œè‹¥æœ€ç»ˆè®¡æ•°å€¼ç­‰äºè¯¾ç¨‹æ•°é‡åˆ™è¿”å›trueã€‚

#### 6ã€è¯¾ç¨‹è¡¨â…¡

**é¢˜ç›®é“¾æ¥**
[LeetCode No.210](https://leetcode.cn/problems/course-schedule-ii/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
List<List<Integer>> edges;
int[] visited;
boolean valid = true;
List<Integer> result = newArrayList<>();
public int[] findOrder(intnumCourses, int[][] prerequisites) {
    edges = new ArrayList<>();
    for (int i = 0; i < numCourses++i) {
        edges.add(newArrayList<Integer>());
    }
    visited = new int[numCourses];
    for (int[] info : prerequisites){
        edges.get(info[1]).add(inf[0]);
    }
    for (int i = 0; i <numCourses &&valid; ++ i)
        if (visited[i] == 0)
            dfs(i);
    if (valid == true) {
        Collections.reverse(result);
        return result.stream()mapToInt(Integer::intValue)toArray();
    } else
        return new int[0];
}
private void dfs(int u) {
    visited[u] = 1;
    for (int v : edges.get(u)) {
        if (visited[v] == 0) {
            dfs(v);
            if (!valid) {
                return;
            }
        } else if (visited[v] == 1) {
            valid = false;
            return;
        }
    }
    visited[u] = 2;
    result.add(u);
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åŒä¸Šä¸€é¢˜ï¼Œåªæ˜¯åœ¨éå†å®Œåæ·»åŠ ç»“æœï¼Œæ³¨æ„æ·±æœçš„ç»“æœéœ€è¦å€’åº

### åäºŒã€å›¾çš„å¹¿åº¦ä¼˜å…ˆæœç´¢

#### 1ã€è›‡å½¢æ£‹

**é¢˜ç›®é“¾æ¥**
[LeetCode No.909](https://leetcode.cn/problems/snakes-and-ladders/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int snakesAndLadders(int[][] board) {
    int len = board.length;
    Deque<int[]> queue = newLinkedList<int[]>();
    boolean[] visited = new boolea[len*len+1];
    queue.offer(new int[]{1, 0});
    while (!queue.isEmpty()) {
        int[] cur = queue.poll();
        for (int i = 1; i <= 6; ++i) {
            int value = cur[0] + i;
            if (value > len*len)
                break;
            // if (visited[value] ==true)
            //     continue;
            int[] location =value2location(value,len);
            if (board[location[0]][location[1]] != -1)
                value = boar[location[0]][location[1]];
            if (value == len*len)
                return cur[1]+1;
            if (!visited[value]) {
                visited[value] =true;
                queue.offer(new int[]{value, cur[1]+1});
            }
        }
    }
    return -1;
}
private int[] value2location(intvalue, int len) {
    int row = (value - 1) / len, col= (value - 1) % len;
    if (row % 2 == 1)
        col = len - 1 - col;
    return new int[]{len - 1 - row,col};
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åœ¨é˜Ÿåˆ—ä¸­å­˜æ”¾{x,y}ï¼Œå…¶ä¸­xä»£è¡¨å½“å‰èŠ‚ç‚¹æ‰€åˆ°ä½ç½®ï¼Œyä»£è¡¨åˆ°å½“å‰èŠ‚ç‚¹æ‰€éœ€çš„æ­¥æ•°
- é™¤æ­¤ä¹‹å¤–å†å­˜ä¸€ä¸ªvisitedæ•°ç»„è®°å½•æ˜¯å¦è®¿é—®è¿‡
- åˆ›å»ºä¸€ä¸ªé˜Ÿåˆ—ï¼Œæ¯æ¬¡å®ç°ä¸€ä¸ªé•¿åº¦ä¸º6ï¼ˆéª°å­ç‚¹æ•°ï¼‰çš„å¾ªç¯ï¼Œè‹¥å½“å‰ä¸ºè¢«è®¿é—®åˆ°åˆ™å…¥é˜Ÿï¼Œå¦åˆ™ä¹Ÿä¼šç»§ç»­è®¿é—®
- ç›´åˆ°æ‰¾åˆ°ç¬¬ä¸€ä¸ªè¿”å›åˆ°ç»ˆç‚¹çš„å€¼
- æ³¨æ„è¿™é‡Œä¸èƒ½è¿‡æ—©è®¾ç½®å·²è®¿é—®ï¼Œå› ä¸ºæ¢¯å­éœ€è¦åå¤ä½¿ç”¨ã€‚å‡è®¾valueä¹‹å‰è¢«è®¿é—®è¿‡ï¼Œä½†æ­¤æ—¶valueå­˜åœ¨ä¸€ä¸ªæœªè¢«å¤„ç†è¿‡çš„ã€Œæ¢¯å­ã€å¯ä»¥è·³è½¬åˆ°ä¸€ä¸ªæ–°çš„æœªè®¿é—®ä½ç½®ã€‚ç”±äºæå‰åˆ¤æ–­valueå·²è®¿é—®è€Œè·³è¿‡ï¼Œä¼šé”™å¤±è¿™ä¸ªé€šè¿‡æ¢¯å­åˆ°è¾¾æ–°ä½ç½®çš„æœºä¼šï¼Œå¯¼è‡´ BFS æ¼è§£ã€‚

#### 2ã€æœ€å°åŸºå› å˜åŒ–

**é¢˜ç›®é“¾æ¥**
[LeetCode No.433](https://leetcode.cn/problems/minimum-genetic-mutation/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int minMutation(String startGene, String endGene, String[] bank) {
    Set<String> bankGene = new HashSet<String>();
    Set<String> visited = new HashSet<String>();
    char[] keys = {'A', 'C', 'G', 'T'};
    for (String w : bank)
        bankGene.add(w);
    if (startGene.equals(endGene))
        return 0;
    if (!bankGene.contains(endGene))
        return -1;
    Deque<String> queue = newLinkedList<String>();
    queue.offer(startGene);
    visited.add(startGene);
    int step = 1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; ++i) {
            String cur = queue.pol();
            for (int j = 0; j < 8;++ j) {
                for (int k = 0; k <4; ++ k) {
                    StringBuffer sb= newStringBuffe(cur);
                    sb.setCharAt(j,keys[k]);
                    String next = sb.toString();
                    if (!visited.contains(next) && bankGene.contains(next)) {
                        if (next.equals(endGene))
                            return step;
                        queue.offer(next);
                        visited.add(next);
                    }
                }
            }
        }
        ++ step;
    }
    return -1;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- éå†æ¯ä¸ªå¯èƒ½æ”¹åŠ¨çš„Stringä¸­çš„å­—æ¯ï¼Œè‹¥bankä¸­å­˜åœ¨åˆ™å°†å…¶æ”¾å…¥é˜Ÿåˆ—ï¼Œç›´åˆ°æ‰¾åˆ°åˆç†è§£

#### 3ã€å•è¯æ¥é¾™

**é¢˜ç›®é“¾æ¥**
[LeetCode No.127](https://leetcode.cn/problems/word-ladder/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    Set<String> wordDict = new HashSet<>();
    Set<String> visited = new HashSet<String>();
    Set<Character> charDict = new HashSet<>();
    for (String word : wordList) {
        for (int i = 0; i < word.length(); ++ i)
            charDict.add(word.charAt(i));
        wordDict.add(word);
    }
    if (!wordDict.contains(endWord))
        return 0;
    Deque<String> queue = new LinkedList<String>();
    queue.offer(beginWord);
    visited.add(beginWord);
    int step = 1;
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; ++ i) {
            String word = queue.poll();
            for (int j = 0; j < word.length(); ++ j) {
                for (char ch : charDict) {
                    if (ch == word.charAt(j))
                        continue;
                    StringBuilder sb = new StringBuilder(word);
                    sb.setCharAt(j, ch);
                    String next = sb.toString();
                    if (!visited.contains(next) && wordDict.contains(next)) {
                        if (next.equals(endWord))
                            return step + 1;
                        queue.offer(next);
                        visited.add(next);
                    }
                }
            }
        }
        ++ step;
    }
    return 0; 
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å¯ä»¥ç”¨å’Œä¸Šä¸€é¢˜ç›¸åŒçš„æ€è·¯å®ç°ï¼ŒåŒºåˆ«åœ¨äºéœ€è¦è‡ªå·±ç»Ÿè®¡æ‰€æœ‰å­˜åœ¨çš„å­—æ¯

### åä¸‰ã€å­—å…¸æ ‘

#### 1ã€å®ç°Trie

**é¢˜ç›®é“¾æ¥**
[LeetCode No.208](https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Trie {

    Trie[] children;
    boolean isEnd;

    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }
    
    public void insert(String word) {
        Trie node = this;
        for (int i = 0; i < word.length(); ++ i) {
            char ch = word.charAt(i);
            int index = ch - 'a';
            if (node.children[index] == null)
                node.children[index] = new Trie();
            node = node.children[index];
        }
        node.isEnd = true;
    }
    
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }

    private Trie searchPrefix(String prefix) {
        Trie node = this;
        for (int i = 0; i < prefix.length(); ++ i) {
            char ch = prefix.charAt(i);
            int index = ch - 'a';
            if (node.children[index] == null)
                return null;
            node = node.children[index];
        }
        return node;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- èŠ‚ç‚¹ä¸­å­˜æ”¾æ•°ç»„å’Œæ˜¯å¦ä¸ºå•è¯ç»“å°¾çš„æ ‡è¯†ç¬¦ï¼Œå¦™å“‰

#### 2ã€æ·»åŠ ä¸æœç´¢å•è¯ - æ•°æ®ç»“æ„è®¾è®¡

**é¢˜ç›®é“¾æ¥**
[LeetCode No.211](https://leetcode.cn/problems/design-add-and-search-words-data-structure/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class WordDictionary {

    class Trie {
        private Trie[] children;
        private boolean isEnd;

        public Trie() {
            children = new Trie[26];
            isEnd = false;
        }

        public void insert(String word) {
            Trie node = this;
            for (int i = 0; i < word.length(); ++ i) {
                char ch = word.charAt(i);
                int index = ch - 'a';
                if (node.children[index] == null)
                    node.children[index] = new Trie();
                node = node.children[index];
            }
            node.isEnd = true;
        }

        public Trie[] getChildren() {
            return children;
        }

        public boolean isEnd() {
            return isEnd;
        }
    }

    private Trie root;

    public WordDictionary() {
        root = new Trie();
    }
    
    public void addWord(String word) {
        root.insert(word);
    }
    
    public boolean search(String word) {
        return dfs(word, 0, root);
    }

    private boolean dfs(String word, int index, Trie node) {
        if (index == word.length())
            return node.isEnd();
        char ch = word.charAt(index);
        if (Character.isLetter(ch)) {
            int childIndex = ch - 'a';
            Trie child = node.getChildren()[childIndex];
            if (child != null && dfs(word, index+1, child))
                return true;
        } else {
            for (int i = 0; i < 26; ++ i) {
                Trie child = node.getChildren()[i];
                if (child != null && dfs(word, index + 1, child))
                    return true;
            }
        }
        return false;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åœ¨ä¸Šä¸€é¢˜åŸºç¡€ä¸Šï¼ŒåŠ ä¸Š'.'çš„ä½¿ç”¨ï¼Œå³é‡åˆ°'.'çš„æ—¶å€™æ‰§è¡Œéå†çš„é€»è¾‘ï¼Œé€æ­¥dfsæ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦ç¬¦åˆæ¡ä»¶

#### 3ã€å•è¯æœç´¢â…¡

**é¢˜ç›®é“¾æ¥**
[LeetCode No.212](https://leetcode.cn/problems/word-search-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {
    int[][] dirs = { {1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    public List<String> findWords(char[][] board, String[] words) {
        Trie trie = new Trie();
        for (String word : words) {
            trie.insert(word);
        }

        Set<String> ans = new HashSet<String>();
        for (int i = 0; i < board.length; ++i) {
            for (int j = 0; j < board[0].length; ++j) {
                dfs(board, trie, i, j, ans);
            }
        }

        return new ArrayList<String>(ans);
    }

    public void dfs(char[][] board, Trie now, int i1, int j1, Set<String> ans) {
        if (!now.children.containsKey(board[i1][j1])) {
            return;
        }
        char ch = board[i1][j1];
        Trie nxt = now.children.get(ch);
        if (!"".equals(nxt.word)) {
            ans.add(nxt.word);
            nxt.word = "";
        }

        if (!nxt.children.isEmpty()) {
            board[i1][j1] = '#';
            for (int[] dir : dirs) {
                int i2 = i1 + dir[0], j2 = j1 + dir[1];
                if (i2 >= 0 && i2 < board.length && j2 >= 0 && j2 < board[0].length) {
                    dfs(board, nxt, i2, j2, ans);
                }
            }
            board[i1][j1] = ch;
        }

        if (nxt.children.isEmpty()) {
            now.children.remove(ch);
        }
    }
}

class Trie {
    String word;
    Map<Character, Trie> children;
    boolean isWord;

    public Trie() {
        this.word = "";
        this.children = new HashMap<Character, Trie>();
    }

    public void insert(String word) {
        Trie cur = this;
        for (int i = 0; i < word.length(); ++i) {
            char c = word.charAt(i);
            if (!cur.children.containsKey(c)) {
                cur.children.put(c, new Trie());
            }
            cur = cur.children.get(c);
        }
        cur.word = word;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ„å»ºå­—å…¸æ ‘ï¼Œå…¶ä¸­childrenå¯ä»¥æ˜¯HashMapä¾¿äºåŒ¹é…
- æ·±åº¦ä¼˜å…ˆéå†boardï¼Œç”±äºåŒæ ·çš„è·¯å¾„ä¸­ä¸èƒ½ä½¿ç”¨é‡å¤çš„å•è¯ï¼Œéœ€è¦ç”¨å›æº¯çš„æ–¹å¼å°†å½“å‰æœç´¢è¿‡çš„å•è¯ç½®ä¸º'#'ï¼Œæ·±åº¦æœç´¢åå†å°†å…¶ç½®ä¸ºåŸæ¥å€¼

### åå››ã€å›æº¯

#### 1ã€ç”µè¯å·ç çš„å­—æ¯ç»„åˆ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.17](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {

    HashMap<Character, String> letterMap = new HashMap<>() {{
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }};
    List<String> result = new ArrayList<>();
    
    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0)
            return result;
        StringBuilder sb = new StringBuilder();
        backtracking(digits, 0, sb);
        return result;
    }

    private void backtracking(String digits, int index, StringBuilder sb) {
        if (index == digits.length()) {
            result.add(sb.toString());
            return;
        }
        String letters = letterMap.get(digits.charAt(index));
        for (int i = 0; i < letters.length(); ++ i) {
            sb.append(letters.charAt(i));
            backtracking(digits, index+1, sb);
            sb.deleteCharAt(index);
        }
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å°†æ•°æ®å¡«å…¥HashMapï¼Œæ¯æ¬¡è®°å½•å½“å‰æ‹¼å‡‘å­—ç¬¦ä¸²ä»¥åŠä½ç½®å¹¶è®¡ç®—ç»“æŸåå›æº¯ï¼Œå°†æ•°æ®è®°å½•è¿›å…¥å…¨å±€çš„Listä¸­ï¼Œæœ€åè¿”å›ç»“æœ

#### 2ã€ç»„åˆ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.77](https://leetcode.cn/problems/combinations/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {

    List<List<Integer>> result = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        backtracking(1, n, k, new ArrayList<>());
        return result;
    }

    private void backtracking(int index, int n, int k, List<Integer> cur) {
        if (cur.size() == k) {
            result.add(new ArrayList<>(cur));
            return;
        }
        int size = n - (k - cur.size()) + 1;
        for (int i = index; i <= size; ++ i) {
            cur.add(i);
            backtracking(i+1, n, k, cur);
            cur.remove(cur.size()-1);
        }
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- åœ¨å›æº¯è¿‡ç¨‹ä¸­è®°å½•å½“å‰æ‰€æŠµè¾¾çš„æ•°å€¼ä½ç½®ä»¥åŠå½“å‰è®°å½•ä¸‹æ¥çš„è·¯å¾„ï¼Œå¹¶åœ¨éå†çš„æ—¶å€™é€šè¿‡å½“å‰æ•°é‡ä»¥åŠè¦æ±‚æ•°é‡å‰ªæ

#### 3ã€å…¨æ’åˆ—

**é¢˜ç›®é“¾æ¥**
[LeetCode No.46](https://leetcode.cn/problems/permutations/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {

    List<List<Integer>> result = new ArrayList<>();

    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        boolean[] visited = new boolean[len];
        List<Integer> path = new ArrayList<>();
        backtracking(nums, visited, path);
        return result;
    }

    private void backtracking(int[] nums, boolean[] visited, List<Integer> path) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; ++ i) {
            if (visited[i] == true)
                continue;
            visited[i] = true;
            path.add(nums[i]);
            backtracking(nums, visited, path);
            visited[i] = false;
            path.remove(path.size()-1);
        }
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- è®¾ç½®ä¸€ä¸ªvisitedæ•°ç»„è®°å½•å·²ç»è®¿é—®è¿‡çš„å…ƒç´ ï¼Œå›æº¯æ—¶å›æº¯pathå’Œvisited

#### 4ã€ç»„åˆæ€»å’Œ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.39](https://leetcode.cn/problems/combination-sum/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {

    List<List<Integer>> result = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtracking(candidates, target, 0, new ArrayList<>(), 0);
        return result;
    }

    private void backtracking(int[] candidates, int target, int curSum, List<Integer> cur, int index) {
        if (curSum == target) {
            result.add(new ArrayList<>(cur));
            return;
        }
        for (int i = index; i < candidates.length; ++ i) {
            if (curSum + candidates[i] > target)
                continue;
            cur.add(candidates[i]);
            backtracking(candidates, target, curSum+candidates[i], cur, i);
            cur.remove(cur.size()-1);
        }
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æœç´¢å›æº¯ï¼Œæ¯æ¬¡è®°å½•å›æº¯çš„èµ·å§‹ç´¢å¼•ï¼ˆä¸€å®šè¦åŒ…å«ä¸Šæ¬¡çš„ç´¢å¼•ï¼‰

#### 5ã€Nçš‡åâ…¡

**é¢˜ç›®é“¾æ¥**
[LeetCode No.52](https://leetcode.cn/problems/n-queens-ii/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {

    private int result = 0;

    public int totalNQueens(int n) {
        int[] methods = new int[n];
        backtracking(methods, 0);
        return result;
    }

    private void backtracking(int[] methods, int row) {
        if (row == methods.length) {
            ++ result;
            return;
        }
        int len = methods.length;
        for (int j = 0; j < len; ++ j) {
            if (check(methods, row, j)) {
                methods[row] = j;
                backtracking(methods, row+1);
                methods[row] = 0;
            }
        }
    }

    private boolean check(int[] methods, int row, int col) {
        for (int i = 0; i < row; ++ i) 
            if (methods[i] == col || Math.abs(row-i) == Math.abs(col - methods[i]))
                return false;
        return true;
    }
}

// ä½è¿ç®—æ³•
class Solution {
    // ä¸»æ–¹æ³•ï¼šè®¡ç®—nçš‡åé—®é¢˜çš„è§£çš„æ€»æ•°
    public int totalNQueens(int n) {
        // è°ƒç”¨é€’å½’æ–¹æ³•solveï¼Œåˆå§‹å‚æ•°ï¼š
        // nï¼šæ£‹ç›˜å¤§å°
        // row=0ï¼šä»ç¬¬0è¡Œå¼€å§‹å¤„ç†ï¼ˆè¡Œä»0è®¡æ•°ï¼‰
        // columns=0ï¼šåˆ—å†²çªæ ‡è®°ï¼ˆåˆå§‹æ— å†²çªï¼‰
        // diagonals1=0ï¼šä¸»å¯¹è§’çº¿ï¼ˆå·¦ä¸Šâ†’å³ä¸‹ï¼‰å†²çªæ ‡è®°ï¼ˆåˆå§‹æ— å†²çªï¼‰
        // diagonals2=0ï¼šå‰¯å¯¹è§’çº¿ï¼ˆå³ä¸Šâ†’å·¦ä¸‹ï¼‰å†²çªæ ‡è®°ï¼ˆåˆå§‹æ— å†²çªï¼‰
        return solve(n, 0, 0, 0, 0);
    }

    // é€’å½’æ–¹æ³•ï¼šè®¡ç®—ä»ç¬¬rowè¡Œå¼€å§‹çš„æœ‰æ•ˆå¸ƒå±€æ•°é‡
    // å‚æ•°è¯´æ˜ï¼š
    // nï¼šæ£‹ç›˜å¤§å°
    // rowï¼šå½“å‰å¤„ç†çš„è¡Œï¼ˆä»0åˆ°n-1ï¼‰
    // columnsï¼šäºŒè¿›åˆ¶æ•°ï¼Œç¬¬iä½ä¸º1è¡¨ç¤º"ç¬¬iåˆ—å·²æœ‰çš‡å"ï¼ˆåˆ—å†²çªï¼‰
    // diagonals1ï¼šäºŒè¿›åˆ¶æ•°ï¼Œç¬¬iä½ä¸º1è¡¨ç¤º"ç¬¬iæ¡ä¸»å¯¹è§’çº¿å·²æœ‰çš‡å"ï¼ˆä¸»å¯¹è§’çº¿å†²çªï¼‰
    // diagonals2ï¼šäºŒè¿›åˆ¶æ•°ï¼Œç¬¬iä½ä¸º1è¡¨ç¤º"ç¬¬iæ¡å‰¯å¯¹è§’çº¿å·²æœ‰çš‡å"ï¼ˆå‰¯å¯¹è§’çº¿å†²çªï¼‰
    public int solve(int n, int row, int columns, int diagonals1, int diagonals2) {
        // é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼šå½“å¤„ç†å®Œæ‰€æœ‰è¡Œï¼ˆrow == nï¼‰ï¼Œè¯´æ˜æ‰¾åˆ°ä¸€ä¸ªæœ‰æ•ˆå¸ƒå±€ï¼Œè¿”å›1
        if (row == n) {
            return 1;
        } else {
            int count = 0; // è®°å½•å½“å‰è¡Œå¼€å§‹çš„æœ‰æ•ˆå¸ƒå±€æ•°é‡
            
            // è®¡ç®—å½“å‰è¡Œå¯ç”¨çš„åˆ—ä½ç½®ï¼ˆäºŒè¿›åˆ¶ä½ä¸º1è¡¨ç¤ºå¯ç”¨ï¼‰
            // 1. (columns | diagonals1 | diagonals2)ï¼šåˆå¹¶æ‰€æœ‰å†²çªä½ï¼ˆ1è¡¨ç¤ºä¸å¯ç”¨ï¼‰
            // 2. ~(...)ï¼šå–ååï¼Œ1è¡¨ç¤ºå¯ç”¨ä½ç½®ï¼ˆä½†é«˜ä½å¯èƒ½æœ‰1ï¼Œéœ€è¦è¿‡æ»¤ï¼‰
            // 3. (1 << n) - 1ï¼šç”Ÿæˆä½nä½å…¨ä¸º1çš„æ©ç ï¼ˆä¾‹å¦‚n=4æ—¶ä¸º0b1111ï¼‰ï¼Œç”¨äºè¿‡æ»¤é«˜ä½æ— æ•ˆä½
            // æœ€ç»ˆï¼šavailablePositionsçš„äºŒè¿›åˆ¶ä¸­ï¼Œ1çš„ä½ç½®æ˜¯å½“å‰è¡Œå¯æ”¾çš‡åçš„åˆ—
            int availablePositions = ((1 << n) - 1) & (~(columns | diagonals1 | diagonals2));
            
            // å¾ªç¯å¤„ç†å½“å‰è¡Œçš„æ¯ä¸ªå¯ç”¨ä½ç½®
            while (availablePositions != 0) {
                // æå–availablePositionsä¸­æœ€ä½ä½çš„1ï¼ˆè·å–å½“å‰è¡Œå¯æ”¾ç½®çš‡åçš„ä¸€ä¸ªåˆ—ï¼‰
                // ä¾‹å¦‚availablePositions=0b1010æ—¶ï¼Œposition=0b0010
                int position = availablePositions & (-availablePositions);
                
                // ç§»é™¤availablePositionsä¸­æœ€ä½ä½çš„1ï¼ˆå¤„ç†å®Œä¸€ä¸ªä½ç½®ï¼Œç»§ç»­ä¸‹ä¸€ä¸ªï¼‰
                // ä¾‹å¦‚availablePositions=0b1010 â†’ 0b1000
                availablePositions = availablePositions & (availablePositions - 1);
                
                // é€’å½’å¤„ç†ä¸‹ä¸€è¡Œï¼Œå¹¶ç´¯åŠ è§£çš„æ•°é‡
                // æ›´æ–°å†²çªæ ‡è®°ï¼š
                // 1. columns | positionï¼šå°†å½“å‰åˆ—æ ‡è®°ä¸ºå†²çªï¼ˆåˆ—å†²çªï¼‰
                // 2. (diagonals1 | position) << 1ï¼šä¸»å¯¹è§’çº¿å†²çªæ ‡è®°å·¦ç§»1ä½ï¼ˆä¸‹ä¸€è¡Œçš„ä¸»å¯¹è§’çº¿å†²çªä½ç½®ä¼šå·¦ç§»ï¼‰
                // 3. (diagonals2 | position) >> 1ï¼šå‰¯å¯¹è§’çº¿å†²çªæ ‡è®°å³ç§»1ä½ï¼ˆä¸‹ä¸€è¡Œçš„å‰¯å¯¹è§’çº¿å†²çªä½ç½®ä¼šå³ç§»ï¼‰
                count += solve(n, row + 1, columns | position, (diagonals1 | position) << 1, (diagonals2 | position) >> 1);
            }
            
            return count; // è¿”å›å½“å‰è¡Œå¼€å§‹çš„æœ‰æ•ˆå¸ƒå±€æ€»æ•°
        }
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ç”¨ä¸€ä¸ªmethodsæ•°ç»„è®°å½•æ¯ä¸€è¡Œçš„åˆ—å·
- é’ˆå¯¹æ¯ä¸€è¡Œè¿›è¡Œå›æº¯æ“ä½œ

#### 6ã€æ‹¬å·ç”Ÿæˆ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.22](https://leetcode.cn/problems/generate-parentheses/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {

    List<String> result = new ArrayList<>();

    public List<String> generateParenthesis(int n) {
        int leftNum = n, rightNum = n;
        String cur = "";
        backtracking(leftNum, rightNum, cur);
        return result;
    }

    private void backtracking(int leftNum, int rightNum, String cur) {
        StringBuilder sb = new StringBuilder(cur);
        if (leftNum == 0) {
            while (rightNum != 0) {
                sb.append(")");
                -- rightNum;
            }
            result.add(sb.toString());
            return;
        }
        if (leftNum >= rightNum) {
            sb.append("(");
            backtracking(leftNum-1, rightNum, sb.toString());
        } else {
            sb.append("(");
            backtracking(leftNum-1, rightNum, sb.toString());
            sb.deleteCharAt(sb.length()-1);
            sb.append(")");
            backtracking(leftNum, rightNum-1, sb.toString());
        }
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- è®°å½•å·¦å³æ‹¬å·çš„å‰©ä½™æ•°é‡ï¼Œè‹¥å…¨æ˜¯å³æ‹¬å·åˆ™å…¨éƒ¨åŠ å…¥å¹¶è¾“å‡ºï¼Œå¦åˆ™å›æº¯åŠ å…¥å·¦/å³æ‹¬å·çš„è¿‡ç¨‹

#### 7ã€å•è¯æœç´¢

**é¢˜ç›®é“¾æ¥**
[LeetCode No.79](https://leetcode.cn/problems/word-search/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {

    private boolean valid = false;

    private int[][] dirs = new int[][]{ {0,1},{-1,0},{0,-1},{1,0}};

    public boolean exist(char[][] board, String word) {
        for (int i = 0; i < board.length; ++ i)
            for (int j = 0; j < board[0].length; ++ j) {
                backtracking(board, i, j, word, 0);
                if (valid)
                    return valid;
            }
        return valid;
    }

    private void backtracking(char[][] board, int x, int y, String word, int index) {
        if (index == word.length()) {
            valid = true;
            return;
        }
        if (board.length == 1 && word.length() == 1) {
            valid = board[0][0] == word.charAt(0) ? true : false;
            return;
        }
        for (int i = 0; i < 4; ++ i) {
            int nextx = x + dirs[i][0], nexty = y + dirs[i][1];
            if (nextx >= 0 && nexty >= 0 && nextx < board.length && nexty < board[0].length && board[nextx][nexty] == word.charAt(index)) {
                board[nextx][nexty] = '#';
                backtracking(board, nextx, nexty, word, index+1);
                board[nextx][nexty] = word.charAt(index);
            }
        }
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- éå†æ¯ä¸€ä¸ªå­—æ¯ä½ç½®ï¼Œå¹¶åœ¨æ¯ä¸€ä¸ªå­—æ¯å¤„è¿›è¡Œå›æº¯åˆ¤æ–­æ˜¯å¦èƒ½ç»„æˆå½“å‰å•è¯

### åäº”ã€åˆ†æ²»

#### 1ã€å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘

**é¢˜ç›®é“¾æ¥**
[LeetCode No.108](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        int left = 0, right = nums.length-1;
        return build(nums, left, right);
    }

    private TreeNode build(int[] nums, int left, int right) {
        if (left > right)
            return null;
        int middle = (left + right) / 2;
        TreeNode root = new TreeNode(nums[middle]);
        root.left = build(nums, left, middle-1);
        root.right = build(nums, middle+1, right);
        return root;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ„å»ºçš„æ—¶å€™ä¼ å…¥å½“å‰éœ€è¦æ„å»ºæ•°ç»„çš„å·¦å³ä¾§è¾¹ç•Œä»¥åŠæ•´ä¸ªæ„å»ºæ•°ç»„

#### 2ã€æ’åºé“¾è¡¨

**é¢˜ç›®é“¾æ¥**
[LeetCode No.148](https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {
    public ListNode sortList(ListNode head) {
        return sort(head, null);
    }

    private ListNode sort(ListNode head, ListNode tail) {
        if (head == null)
            return head;
        if (head.next == tail) {
            head.next = null;
            return head;
        }

        ListNode slow = head, fast = head;
        while (fast != tail) {
            slow = slow.next;
            fast = fast.next;
            if (fast != tail)
                fast = fast.next;
        }
        ListNode mid = slow;
        ListNode list1 = sort(head, mid);
        ListNode list2 = sort(mid, tail);
        return merge(list1, list2);
    }

    private ListNode merge(ListNode head1, ListNode head2) {
        ListNode dummyHead = new ListNode(0);
        ListNode temp = dummyHead, temp1 = head1, temp2 = head2;
        while (temp1 != null && temp2 != null) {
            if (temp1.val <= temp2.val) {
                temp.next = temp1;
                temp1 = temp1.next;
            } else {
                temp.next = temp2;
                temp2 = temp2.next;
            }
            temp = temp.next;
        }
        if (temp1 != null) {
            temp.next = temp1;
        } else if (temp2 != null) {
            temp.next = temp2;
        }
        return dummyHead.next;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆå®šä½åˆ°é“¾è¡¨ä¸­é—´ï¼Œå°†é“¾è¡¨åˆ†ä¸ºä¸¤ç«¯ï¼Œå°†ä¸¤ç«¯é“¾è¡¨åˆ†åˆ«è¿›è¡Œå…ˆæ’åºååˆå¹¶ã€‚

#### 3ã€ç®€å»ºç«‹å‰æ ‘

**é¢˜ç›®é“¾æ¥**
[LeetCode No.427](https://leetcode.cn/problems/construct-quad-tree/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {
    public Node construct(int[][] grid) {
        int n = grid.length;
        return build(0, 0, n, n, grid);
    }

    private Node build(int x1, int y1, int x2, int y2, int[][] grid) {
        if (x2 <= x1 && y2 <= y1)
            return null;
        boolean value = grid[x1][y1] == 1 ? true : false;
        if (x1 == x2-1 && y1 == y2-1)
            return new Node(value, true);
        boolean flag = true;
        for (int i = x1; i < x2; ++ i) {
            for (int j = y1; j < y2; ++ j) {
                boolean temp = grid[i][j] == 1 ? true : false;
                if (temp != value) {
                    flag = false;
                    break;
                }
            }
            if (flag == false)
                break;
        }
        if (flag == true)
            return new Node(value, true);
        Node root = new Node(false, false);
        int xmid = x1 + (x2-x1) / 2, ymid = y1 + (y2-y1) / 2;
        root.topLeft = build(x1, y1, xmid, ymid, grid);
        root.topRight = build(x1, ymid, xmid, y2, grid);
        root.bottomLeft = build(xmid, y1, x2, ymid, grid);
        root.bottomRight = build(xmid, ymid, x2, y2, grid);
        return root;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- é€’å½’å®ç°å››ä¸ªèŠ‚ç‚¹çš„è®¡ç®—ï¼Œä½¿ç”¨x1 + (x2 - x1)/2 çš„æ–¹æ³•è®¡ç®—å‡ºå½“å‰xæˆ–yçš„ä¸­é—´å€¼

#### 4ã€åˆå¹¶kä¸ªå‡åºé˜Ÿåˆ—

**é¢˜ç›®é“¾æ¥**
[LeetCode No.23](https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        int len = lists.length;
        return merge(lists, 0, len);
    }

    private ListNode merge(ListNode[] lists, int left, int right) {
        if (left >= right)
            return null;
        else if (left == right-1)
            return lists[left];
        int mid = (left + right) / 2;
        ListNode leftHead = merge(lists, left, mid);
        ListNode rightHead = merge(lists, mid, right);
        ListNode dummy = new ListNode(-1), temp = dummy;
        while (leftHead != null && rightHead != null) {
            if (leftHead.val <= rightHead.val) {
                temp.next = leftHead;
                leftHead = leftHead.next;
            } else {
                temp.next = rightHead;
                rightHead = rightHead.next;
            }
            temp = temp.next;
        }
        if (leftHead == null)
            temp.next = rightHead;
        if (rightHead == null)
            temp.next = leftHead;
        return dummy.next;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å°†é“¾è¡¨liståˆ†ä¸ºå·¦ä¾§å’Œå³ä¾§ä¸¤éƒ¨åˆ†ï¼Œé€’å½’åˆå¹¶æ“ä½œï¼Œç§’äº†

### åå…­ã€kadaneç®—æ³•

#### 1ã€æœ€å¤§å­æ•°ç»„å’Œ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.53](https://leetcode.cn/problems/maximum-subarray/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int maxSubArray(int[] nums) {
    int sum = 0, max = IntegerMIN_VALUE;
    for (int i = 0; i < nums.length;++ i) {
        sum += nums[i];
        max = Math.max(max, sum);
        if (sum < 0)
            sum = 0;
    }
    return max;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä¸æ–­æ›´æ–°sumå¹¶åŒæ—¶è®°å½•æœ€å¤§å€¼maxï¼Œè‹¥sumä¸ºè´Ÿæ•°åˆ™é‡æ–°å¼€å§‹è®°å½•sum

#### 2ã€ç¯å½¢å­æ•°ç»„çš„æœ€å¤§å’Œ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.918](https://leetcode.cn/problems/maximum-sum-circular-subarray/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int maxSubarraySumCircular(int[] nums) {
    int n = nums.length;
    int[] leftMax = new int[n];
    leftMax[0] = nums[0];
    int leftSum = nums[0];
    int pre = nums[0];
    int res = nums[0];
    for (int i = 1; i < n; i++) {
        pre = Math.max(pre + nums[i], nums[i]);
        res = Math.max(res, pre);
        leftSum += nums[i];
        leftMax[i] = Math.max(leftMax[i - 1], leftSum);
    }
    int rightSum = 0;
    for (int i = n - 1; i > 0; i--) {
        rightSum += nums[i];
        res = Math.max(res, rightSum + leftMax[i - 1]);
    }
    return res;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æœ¬é¢˜åˆ†ä¸¤ç§æƒ…å†µï¼Œ1æ˜¯ä»å¤´åˆ°å°¾çš„æœ€å¤§å€¼ï¼Œ2æ˜¯ä»ä¸­é—´è·¨è¿‡å°¾å†åˆ°å¤´çš„æœ€å¤§å€¼
- éå†ä¸¤æ¬¡ï¼Œç¬¬ä¸€æ¬¡è®¡ç®—æƒ…å†µ1çš„æœ€å¤§å€¼ ä¸ æƒ…å†µ2ä¸­ååŠéƒ¨åˆ†çš„æœ€å¤§å€¼æ•°ç»„ï¼›ç¬¬äºŒæ¬¡éå†è®¡ç®—æƒ…å†µ2ä¸­å‰åŠéƒ¨åˆ†çš„æœ€å¤§å€¼æ•°ç»„ï¼Œå¹¶æ¯æ¬¡éƒ½ä¸ç¬¬ä¸€æ¬¡éå†è®¡ç®—çš„ç»“æœç›¸å¯¹æ¯”

### åä¸ƒã€äºŒåˆ†æŸ¥æ‰¾

#### 1ã€æœç´¢æ’å…¥ä½ç½®

**é¢˜ç›®é“¾æ¥**
[LeetCode No.35](https://leetcode.cn/problems/search-insert-position/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int middle = (left + right) / 2;
            if (nums[middle] < target) {
                left = middle + 1;
            } else if (nums[middle] > target) {
                right = middle - 1;
            } else
                return middle;
        }
        return left;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨é—­åŒºé—´å®ç°äºŒåˆ†æŸ¥æ‰¾ï¼Œå˜æ›´è¾¹ç•Œçš„æ—¶å€™ä¸åŒ…å«åŸæœ‰è¾¹ç•Œ

#### 2ã€æœç´¢äºŒç»´çŸ©é˜µ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.74](https://leetcode.cn/problems/search-a-2d-matrix/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public boolean searchMatrix(int[][] matrix, int target) {
    int row = matrix.length, col = matrix[0].length;
    int up = 0, down = row-1, left = 0, right = col-1;
    int rowNum = 0;
    while (up <= down) {
        int mid = (up + down) >> 1;
        if (matrix[mid][0] > target)
            down = mid -1;
        else if (matrix[mid][col-1] < target)
            up = mid + 1;
        else {
            rowNum = mid;
            break;
        }
    }
    while (left <= right) {
        int mid = (left + right) >> 1;
        if (matrix[rowNum][mid] > target)
            right = mid - 1;
        else if (matrix[rowNum][mid] < target)
            left = mid + 1;
        else
            return true;
    }
    return false;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä¸¤æ¬¡äºŒåˆ†æŸ¥æ‰¾ï¼Œç¬¬ä¸€æ¬¡æŸ¥æ‰¾å¯¹åº”è¡Œï¼Œç¬¬äºŒæ¬¡æŸ¥æ‰¾å¯¹åº”åˆ—

#### 3ã€å¯»æ‰¾å³°å€¼

**é¢˜ç›®é“¾æ¥**
[LeetCode No.162](https://leetcode.cn/problems/find-peak-element/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int left=0,right=nums.length-1;
        while(left<right){
            int mid = (left+right)/2;
            if(nums[mid]>nums[mid+1]){  
//è¯´æ˜æ­¤æ—¶midä¸ºä¸‹å¡è·¯ï¼Œé‚£ä¹ˆæœ‰å¯èƒ½è‡ªå·±æœ¬èº«å°±æ˜¯å±±å³°ï¼Œæˆ–è€…åœ¨ä¸‹å±±çš„è¿‡ç¨‹ä¸­ï¼Œæ‰€ä»¥right=midè€Œä¸èƒ½ç­‰äºmid-1
                right = mid;
            }else{
                left = mid+1; 
//åä¹‹è¯´æ˜æ­¤æ—¶midä¸ºä¸Šå¡è·¯ï¼Œæ—¢ç„¶æ˜¯ä¸Šå¡ï¼Œé‚£ä¹ˆmidè‚¯å®šä¸æ˜¯å±±å³°ï¼Œæ‰€ä»¥left=mid+1ï¼ˆé¢˜ç›®è¦æ±‚nums[i]!=nums[i+1]ï¼Œæ‰€ä»¥ä¸å¯èƒ½å­˜åœ¨â€œå¹³å³°â€çš„æƒ…å†µï¼‰
            }
        }
        return left;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>**
- ä¸€ç›´å¾€é«˜å‡ºèµ°å°±èƒ½æ‰¾åˆ°å±±å³°ï¼Œå› ä¸ºnums[-1] = nums[n] = -âˆã€‚
- äºŒåˆ†æŸ¥æ‰¾ï¼Œä¸æ–­å¯¹æ¯”ä¸­å€¼ä¸å³ä¾§çš„å¤§å°ï¼Œæœ‰ä¸¤ç§å¯èƒ½æ€§â€”â€”å¯èƒ½æ€§1ï¼šè‹¥å½“å‰midæ¯”å³ä¾§å°ï¼Œåˆ™å³ä¾§ä¸€å®šä¼šæœ‰å±±å³°ä½†ä¸å¯èƒ½æ˜¯midï¼Œå› æ­¤å°†leftæ›´æ–°ä¸ºmid+1ï¼›å¯èƒ½æ€§2ï¼šè‹¥å½“å‰midæ¯”å³ä¾§å¤§ï¼Œåˆ™å·¦ä¾§åŒ…æ‹¬midè‡ªå·±éƒ½æœ‰å¯èƒ½æ˜¯å±±å³°ï¼Œå› æ­¤å°†rightæ›´æ–°ä¸ºmidã€‚è¿™æ ·èŒƒå›´ç¼©å°åˆ°æœ€åä¸€ä¸ªçš„æ—¶å€™è‚¯å®šæ˜¯å±±å³°äº†

#### 4ã€æœç´¢æ—‹è½¬æ’åºæ•°ç»„

**é¢˜ç›®é“¾æ¥**
[LeetCode No.33](https://leetcode.cn/problems/search-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {
    public int search(int[] nums, int target) {
        int len = nums.length;
        if (len == 0)
            return -1;
        if (len == 1)
            return nums[0] == target ? 0 : -1;
        int left = 0, right = len - 1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (nums[mid] == target)
                return mid;
            if (nums[0] <= nums[mid]) {
                // å·¦ä¾§å±€éƒ¨æœ‰åº
                if (nums[0] <= target && target < nums[mid])
                    right = mid - 1;
                else
                    left = mid + 1;

            } else {
                // å³ä¾§å±€éƒ¨æœ‰åº
                if (nums[mid] < target && target <= nums[len-1])
                    left = mid + 1;
                else
                    right = mid - 1;
            }
        }
        return -1;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä»ä¸­é—´åˆ†å¼€æ•°ç»„çš„æ—¶å€™ï¼Œä¸€å®šæœ‰ä¸€éƒ¨åˆ†æ•°ç»„æ˜¯æœ‰åºçš„ï¼Œå¯èƒ½æ˜¯å·¦ä¾§ä¹Ÿå¯èƒ½æ˜¯å³ä¾§
- å› æ­¤ï¼Œè¿™ä¹Ÿæœ‰ä¸¤ç§å¯èƒ½ï¼š1 å·¦ä¾§å±€éƒ¨æœ‰åºï¼Œæ­¤æ—¶åˆ¤æ–­nums[mid]æ˜¯å¦åœ¨å·¦ä¾§åŒºé—´å†…ï¼Œè‹¥åœ¨åˆ™å°†å³è¾¹ç•Œæ”¾åˆ°mid-1å¤„ï¼Œè‹¥ä¸åœ¨åˆ™å°†å·¦è¾¹ç•Œæ”¾åˆ°mid+1å¤„ã€‚2 å·¦ä¾§å±€éƒ¨æ— åºåˆ™å³ä¾§å±€éƒ¨æœ‰åºï¼Œæ­¤æ—¶åˆ¤æ–­nums[mid]æ˜¯å¦åœ¨å³ä¾§åŒºé—´å†…ï¼Œç­‰ç­‰åˆ¤æ–­é€»è¾‘ã€‚

#### 5ã€åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®

**é¢˜ç›®é“¾æ¥**
[LeetCode No.34](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int[] searchRange(int[] nums, int target) {
    int left = 0, right = nums.length-1;
    int loc = -1;
    while (left <= right) {
        int mid = (left + right) >> 1;
        if (nums[mid] < target)
            left = mid + 1;
        else if (nums[mid] > target)
            right = mid - 1;
        else {
            loc = mid;
            break;
        }
    }
    if (loc == -1)
        return new int[]{-1, -1};
    int leftLoc = loc, rightLoc = loc;
    while (leftLoc >= 0 && nums[leftLoc] == target)
        -- leftLoc;
    while (rightLoc < nums.length && nums[rightLoc] == target)
        ++ rightLoc;
    return new int[]{leftLoc+1, rightLoc-1};
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å…ˆç”¨äºŒåˆ†æ³•æ‰¾åˆ°å€¼ä¸ºtargetçš„ä½ç½®ï¼Œå†å‘å·¦å³æ‰©å±•å¯»æ‰¾èŒƒå›´

#### 6ã€å¯»æ‰¾æ—‹è½¬æ’åºæ•°ç»„ä¸­çš„æœ€å°å€¼

**é¢˜ç›®é“¾æ¥**
[LeetCode No.153](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int findMin(int[] nums) {
    int len = nums.length;
    int left = 0, right = len-1;
    while (left < right) {
        int mid = (left + right) >> 1;
        if (nums[mid] < nums[right])
            right = mid;
        else
            left = mid + 1;
    }
    return nums[left];
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- äºŒåˆ†æŸ¥æ‰¾ï¼Œæ‰¾åˆ°å·¦å³ä¸¤éƒ¨åˆ†ä¸­éé¡ºåºçš„éƒ¨åˆ†å¹¶ç»§ç»­äºŒåˆ†æŸ¥æ‰¾ã€‚
- è‹¥midå€¼å°äºrightåˆ™å³ä¾§æ­£å¸¸ï¼Œå³ä¾§è¾¹ç•Œå‘å·¦ç§»åŠ¨è‡³midå¤„
- è‹¥midå€¼å¤§äºç­‰äºrightåˆ™å·¦ä¾§æ­£å¸¸ä½†ä¸åŒ…æ‹¬midï¼Œå·¦ä¾§è¾¹ç•Œå‘å³ç§»åŠ¨è‡³mid+1å¤„
- æœ€ç»ˆleftå’Œrightä¼šé‡åˆ

#### 7ã€å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°

**é¢˜ç›®é“¾æ¥**
[LeetCode No.4](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        if (totalLength % 2 == 1) {
            int midIndex = totalLength / 2;
            double median = getKthElement(nums1, nums2, midIndex + 1);
            return median;
        } else {
            int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
            double median = (getKthElement(nums1, nums2, midIndex1 + 1) + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
            return median;
        }
    }

    private int getKthElement(int[] nums1, int[] nums2, int k) {
        int length1 = nums1.length, length2 = nums2.length;
        int index1 = 0, index2 = 0;
        int kthElement = 0;

        while (true) {
            if (index1 == length1)
                return nums2[index2+k-1];
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }

            int half = k/2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int bound1 = nums1[newIndex1], bound2 = nums2[newIndex2];
            if (bound1 <= bound2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2+ 1);
                index2 = newIndex2 + 1;
            }
        }
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ±‚å¾—ä¸­ä½æ•°å‰çš„ä½æ•°kï¼Œæ¯æ¬¡å°†nums1å’Œnums2çš„æŒ‡é’ˆå‘å‰ç§»åŠ¨k/2ä¸ªä½ç½®ï¼Œå¹¶æ¯”è¾ƒä¸¤æŒ‡é’ˆçš„æ•°å€¼å¤§å°ã€‚å°†å°çš„é‚£éƒ¨åˆ†å‰é¢çš„å€¼å…¨éƒ¨èˆå¼ƒï¼Œå¹¶åœ¨kçš„åŸºç¡€ä¸Šå‡å»k/2ï¼Œå¹¶ç»§ç»­è®¡ç®—ã€‚ç›´åˆ°æœ‰ä¸€ä¾§çš„æ•°ç»„è¾¹ç•Œåˆ°é¡¶ï¼ˆä¸­ä½æ•°ä¸ºå¦ä¸€ä¾§æ•°ç»„çš„å½“å‰æŒ‡é’ˆå€¼ï¼‰æˆ–kå€¼ä¸º1ï¼ˆä¸­ä½æ•°ä¸ºä¸¤ä¾§æ•°ç»„æŒ‡é’ˆå‡ºå€¼çš„è¾ƒå°è€…ï¼‰

### åå…«ã€å †

#### 1ã€æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ 

**é¢˜ç›®é“¾æ¥**
[LeetCode No.](https://leetcode.cn/problems/kth-largest-element-in-an-array/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// ä½¿ç”¨PriorityQueue
public int findKthLargest(int[] nums, int k) {
    // å°é¡¶å †ï¼Œä»…ä¿ç•™å‰kå¤§çš„å…ƒç´ ï¼Œå †é¡¶å³ä¸ºç¬¬kå¤§
    PriorityQueue<Integer> heap = new PriorityQueue<>(k);
    for (int num : nums) {
        heap.add(num);
        if (heap.size() > k) {
            heap.poll(); // è¶…è¿‡kä¸ªå…ƒç´ æ—¶ï¼Œç§»é™¤æœ€å°çš„ï¼ˆå †é¡¶ï¼‰
        }
    }
    return heap.peek();
}

// ä½¿ç”¨streamæµ
public int findKthLargest(int[] nums, int k) {
    return Arrays.stream(nums)
    .boxed()
    .sorted((a,b) -> Integer.compare(b,a))
    .skip(k-1)
    .findFirst()
    .get();
}

// ä½¿ç”¨TreeMap
public int findKthLargest(int[] nums, int k) {
    // TreeMapé»˜è®¤æŒ‰é”®å‡åºæ’åº
    TreeMap<Integer, Integer> countMap = new TreeMap<>();
    // ç»Ÿè®¡æ¯ä¸ªå…ƒç´ çš„å‡ºç°æ¬¡æ•°
    for (int num : nums) {
        countMap.put(num, countMap.getOrDefault(num, 0) + 1);
    }
    
    int count = 0;
    // é€†åºéå†é”®ï¼ˆä»å¤§åˆ°å°ï¼‰
    Set<Integer> descendingKeys = countMap.descendingKeySet();
    for (int key : descendingKeys) {
        count += countMap.get(key);
        // ç´¯è®¡æ¬¡æ•°è¾¾åˆ°kæ—¶ï¼Œå½“å‰é”®å³ä¸ºç¬¬kä¸ªæœ€å¤§å…ƒç´ 
        if (count >= k) {
            return key;
        }
    }
    
    return -1; // ç†è®ºä¸Šä¸ä¼šæ‰§è¡Œåˆ°æ­¤å¤„ï¼ˆè¾“å…¥åˆæ³•æ—¶ï¼‰
}

// å¿«é€Ÿæ’åº
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickSelect(nums, 0, nums.length-1, k-1);
    }

    private int quickSelect(int[] nums, int left, int right, int k) {
        int leftBorder = left, rightBorder = right;
        int pivot = nums[left];
        while (left < right) {
            while (left < right && nums[right] <= pivot)
                -- right;
            nums[left] = nums[right];
            while (left < right && nums[left] >= pivot)
                ++ left;
            nums[right] = nums[left];
        }
        nums[left] = pivot;
        if (left == k)
            return nums[left];
        else if (k < left)
            return quickSelect(nums, leftBorder, left-1, k);
        else
            return quickSelect(nums, left+1, rightBorder, k);
    }
}

// å †æ’åº
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize = nums.length;
        buildMaxHeap(nums, heapSize);
        for (int i = nums.length - 1; i >= nums.length - k + 1; --i) {
            swap(nums, 0, i);
            --heapSize;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }

    public void buildMaxHeap(int[] a, int heapSize) {
        for (int i = heapSize / 2 - 1; i >= 0; --i) {
            maxHeapify(a, i, heapSize);
        } 
    }

    public void maxHeapify(int[] a, int i, int heapSize) {
        int l = i * 2 + 1, r = i * 2 + 2, largest = i;
        if (l < heapSize && a[l] > a[largest]) {
            largest = l;
        } 
        if (r < heapSize && a[r] > a[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(a, i, largest);
            maxHeapify(a, largest, heapSize);
        }
    }

    public void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ç»å…¸é¢˜ç›®ï¼Œå¯ä»¥ç”¨å¤šç§æ–¹æ³•å®ç°

### åä¹ã€ä½è¿ç®—

#### 1ã€äºŒè¿›åˆ¶æ±‚å’Œ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.67](https://leetcode.cn/problems/add-binary/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder sb = new StringBuilder();
        int ca = 0;
        for (int i = a.length()-1, j = b.length()-1; i >= 0 || j >= 0; --i, --j) {
            int sum = ca;
            sum += i >= 0 ? a.charAt(i) - '0' : 0;
            sum += j >= 0 ? b.charAt(j) - '0' : 0;
            sb.append(sum % 2);
            ca = sum / 2;
        }
        sb.append(ca == 1 ? ca : "");
        return sb.reverse().toString();
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å€’å™éå†ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œæœ€åreverseå¾—åˆ°ç»“æœ
- åœ¨reverseä¹‹å‰è‹¥å·¦åè¿›ä½>0åˆ™å†æ·»åŠ ä¸ºæœ€åä¸€ä½æ•°

#### 2ã€é¢ å€’äºŒè¿›åˆ¶ä½

**é¢˜ç›®é“¾æ¥**
[LeetCode No.190](https://leetcode.cn/problems/reverse-bits/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int reverseBits(int n) {
    int rev = 0;
    for (int i = 0; i < 32 && n != 0; ++ i) {
        rev |= (n & 1) << (31 - i);
        n >>>= 1;
    }
    return rev;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨äºŒè¿›åˆ¶ä½è¿ç®—çš„æ–¹æ³•ï¼Œå°†nä¸1å–ä½™è·å–æœ€ä½ä½çš„å€¼ï¼Œå°†è¿™ä¸ªå€¼å‘å·¦ä¾§ç§»åŠ¨åˆ°å¯¹åº”ä½ç½®åï¼Œå°†å€¼æ›´æ–°åˆ°revä¸­ï¼Œæœ€åå°†nå‘å³ä½¿ç”¨æ— ç¬¦å·çš„å³ç§»

#### 3ã€ä½1çš„ä¸ªæ•°

**é¢˜ç›®é“¾æ¥**
[LeetCode No.191](https://leetcode.cn/problems/number-of-1-bits/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// ç›´æ¥è½¬æ¢ä¸ºäºŒè¿›åˆ¶å­—ç¬¦ä¸²
public int hammingWeight(int n) {
    String binaryStr = Integer.toBinaryString(n);
    int count = 0;
    for (int i = 0; i < binaryStr.length(); ++ i)
        if (binaryStr.charAt(i) == '1')
            ++ count;
    return count;
}

// ä½è¿ç®—
public int hammingWeight(int n) {
    int ret = 0;
    for (int i = 0; i < 32; ++ i)
        if ((n & (1 << i)) != 0)
            ++ ret;
    return ret;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä»ç¬¬ä¸€ä½æ•°ä¸€ç›´åˆ°æœ€åä¸€ä½æ•°åš&æ“ä½œåˆ¤æ–­æ˜¯å¦ä¸º1ï¼Œè‹¥æ˜¯1åˆ™ç´¯åŠ æ•°é‡

#### 4ã€åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—

**é¢˜ç›®é“¾æ¥**
[LeetCode No.136](https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int singleNumber(int[] nums) {
    int single = 0;
    for (int num : nums)
        single ^= num;
    return single;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨å¼‚æˆ–è¿ç®—ï¼Œå› ä¸ºå¼‚æˆ–è¿ç®—å­˜åœ¨äº¤æ¢å¾‹å’Œç»“åˆå¾‹ï¼Œä¸¤ä¸¤ç›¸ç­‰çš„æ•°æœ€ç»ˆä¼šæˆä¸º0ï¼Œè€Œä»»ä½•æ•°ä¸0åšå¼‚æˆ–è¿ç®—éƒ½ä¼šå¾—åˆ°åŸæ¥çš„æ•°

#### 5ã€åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—â…¡

**é¢˜ç›®é“¾æ¥**
[LeetCode No.137](https://leetcode.cn/problems/single-number-ii/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int singleNumber(int[] nums) {
    int res = 0;
    for (int i = 0; i < 32; ++ i) {
        int total = 0;
        for (int num : nums)
            total += ((num >> i) & 1);
        if (total % 3 != 0)
            res |= (1 << i);
    }
    return res;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ç»Ÿè®¡32ä½ä¸­æ¯ä¸€ä½ä¸­åœ¨æ‰€æœ‰æ•°å€¼é‡Œ1çš„æ•°é‡ï¼Œå¦‚æœæ•°é‡èƒ½è¢«3æ•´é™¤ï¼Œåˆ™å”¯ä¸€å€¼åœ¨è¿™ä¸ªä½æ•°æ˜¯0ï¼Œä¸åšæ“ä½œã€‚è‹¥æ•°é‡ä¸èƒ½è¢«3æ•´é™¤ï¼Œåˆ™å”¯ä¸€å€¼åœ¨è¿™ä¸ªä½æ•°æ˜¯1ï¼Œå°†å…¶å†™å…¥ã€‚

#### 6ã€æ•°å­—èŒƒå›´æŒ‰ä½ä¸

**é¢˜ç›®é“¾æ¥**
[LeetCode No.201](https://leetcode.cn/problems/bitwise-and-of-numbers-range/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int rangeBitwiseAnd(int left, int right) {
    int shift = 0;
    while (left < right) {
        left >>= 1;
        right >>= 1;
        ++ shift;
    }
    return left << shift;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å°†å¤´å°¾ä¸¤æ•°åŒæ—¶å‘å³ç§»åŠ¨ç›´åˆ°ä¸¤æ•°ç›¸ç­‰ï¼Œè®°å½•ç§»åŠ¨æ¬¡æ•°ï¼ˆå¯ä»¥ç†è§£æˆleftå’Œrightåˆ†åˆ«å‘ä¸­é—´é€¼è¿‘ç›´åˆ°ç›¸é‡ï¼‰
- ä¸¤æ•°ç›¸ç­‰åå†åŒæ—¶å‘å·¦ç§»åŠ¨

### äºŒåã€æ•°å­¦

#### 1ã€å›æ–‡æ•°

**é¢˜ç›®é“¾æ¥**
[LeetCode No.9](https://leetcode.cn/problems/palindrome-number/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// ä½¿ç”¨å­—ç¬¦ä¸²
public boolean isPalindrome(int x) {
    String num = String.valueOf(x);
    int left = 0, right = num.length()-1;
    while (left <= right) {
        if (num.charAt(left) != num.charAt(right))
            return false;
        ++ left;
        -- right;
    }
    return true;
}

// ä½¿ç”¨reverseæ•°
public boolean isPalindrome(int x) {
    if (x % 10 == 0 && x != 0)
        return false;
    int reverse = 0;
    while (reverse < x) {
        reverse = reverse*10 + x%10;
        x /= 10;
    }
    return reverse == x || reverse/10 == x;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ„é€ ä¸€ä¸ªåå‘æ•°ç»„æˆ–ç›´æ¥ä½¿ç”¨å­—ç¬¦ä¸²

#### 2ã€åŠ ä¸€

**é¢˜ç›®é“¾æ¥**
[LeetCode No.66](https://leetcode.cn/problems/plus-one/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int[] plusOne(int[] digits) {
    int len = digits.length;
    for (int i = len-1; i >= 0; -- i) {
        if (digits[i] != 9) {
            ++ digits[i];
            for (int j = i+1; j < len; ++ j)
                digits[j] = 0;
            return digits;
        }
    }
    int[] res = new int[len+1];
    res[0] = 1;
    return res;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- è‹¥ç¢°åˆ°è¿ç»­çš„9åˆ™å°†åé¢æ‰€æœ‰çš„æ•°éƒ½ç½®0ï¼Œå¦åˆ™åŠ ä¸€åç›´æ¥è¿”å›
- è‹¥å€¼ä¸º99...9ï¼Œåˆ™æ–°å»ºä¸€ä¸ªæ•°ç»„å¹¶å°†0ä½ç½®ç½®ä¸º1

#### 3ã€é˜¶ä¹˜åçš„é›¶

**é¢˜ç›®é“¾æ¥**
[LeetCode No.172](https://leetcode.cn/problems/factorial-trailing-zeroes/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// æ±‚5çš„æ•°é‡
public int trailingZeroes(int n) {
    int count5 = 0;
    for (int i = 1; i <= n; ++ i)
        if (i % 5 == 0) {
            int num = i;
            while (num % 5 == 0 && num != 0) {
                ++ count5;
                num /= 5;
            }
        }
    return count5;
}

// ä¼˜åŒ–
public int trailingZeroes(int n) {
    int ans = 0;
    while (n > 0) {
        // å¾ªç¯ k æ¬¡åï¼Œn å˜æˆäº† floor(n/5^k)
        n /= 5;
        ans += n;
    }
    return ans;
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ç´¯åŠ 5çš„å„æ¬¡å¹‚çš„å€æ•°æ•°é‡

#### 4ã€xçš„å¹³æ–¹æ ¹

**é¢˜ç›®é“¾æ¥**
[LeetCode No.69](https://leetcode.cn/problems/sqrtx/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// è®¡ç®—å™¨æ–¹æ³•
public int mySqrt(int x) {
    if (x == 0) {
        return 0;
    }
    int ans = (int) Math.exp(0.5 * Math.log(x));
    return (long) (ans + 1) * (ans + 1) <= x ? ans + 1 : ans;
}

// äºŒåˆ†æŸ¥æ‰¾æ³•
public int mySqrt(int x) {
    int l = 0, r = x, ans = -1;
    while (l <= r) {
        int mid = (l+r) / 2;
        if ((long) mid * mid <= x) {
            ans = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return ans;
}

```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- æ ¹å·å¯ä»¥é€šè¿‡lnåŒ–è§£ï¼Œæ¨¡æ‹Ÿè®¡ç®—å™¨ç›´æ¥å®ç°
- å¯ä»¥é€šè¿‡äºŒåˆ†æŸ¥æ‰¾çš„æ–¹å¼ï¼Œä¸æ–­æ‰¾åˆ°ä¸­ä½æ•°å¹¶æ¯”è¾ƒä¸­ä½æ•°çš„å¹³æ–¹å’Œxå€¼çš„å¤§å°å¹¶ä¸æ–­æ›´æ–°åŒºé—´

#### 5ã€Pow(x,n)

**é¢˜ç›®é“¾æ¥**
[LeetCode No.50](https://leetcode.cn/problems/powx-n/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {
    public double myPow(double x, int n) {
        long N = n;
        return N >= 0 ? quickMi(x, N) : 1.0 / quickMi(x, -N);
    }

    private double quickMi(double x, long N) {
        if (N == 0)
            return 1.0;
        double y = quickMi(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å¿«é€Ÿå¹‚ï¼Œä½¿ç”¨äºŒåˆ†æ³•å°†ä¹˜ç§¯é€’å½’æ‰§è¡Œ

#### 6ã€ç›´çº¿ä¸Šæœ€å¤šçš„ç‚¹

**é¢˜ç›®é“¾æ¥**
[LeetCode No.149](https://leetcode.cn/problems/max-points-on-a-line/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
class Solution {
    public int maxPoints(int[][] points) {
        int n = points.length;
        if (n <= 2) {
            return n;
        }
        int ret = 0;
        for (int i = 0; i < n; i++) {
            if (ret >= n - i || ret > n / 2) {
                break;
            }
            Map<Integer, Integer> map = new HashMap<Integer, Integer>();
            for (int j = i + 1; j < n; j++) {
                int x = points[i][0] - points[j][0];
                int y = points[i][1] - points[j][1];
                if (x == 0) {
                    y = 1;
                } else if (y == 0) {
                    x = 1;
                } else {
                    if (y < 0) {
                        x = -x;
                        y = -y;
                    }
                    int gcdXY = gcd(Math.abs(x), Math.abs(y));
                    x /= gcdXY;
                    y /= gcdXY;
                }
                int key = y + x * 20001;
                map.put(key, map.getOrDefault(key, 0) + 1);
            }
            int maxn = 0;
            for (Map.Entry<Integer, Integer> entry: map.entrySet()) {
                int num = entry.getValue();
                maxn = Math.max(maxn, num + 1);
            }
            ret = Math.max(ret, maxn);
        }
        return ret;
    }

    public int gcd(int a, int b) {
        return b != 0 ? gcd(b, a % b) : a;
    }
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- ä½¿ç”¨ä¸€ä¸ªMapå­˜å‚¨æ‰€æœ‰å¯èƒ½ç»“æœä»¥åŠå…¶ä¸­ç‚¹çš„ä¸ªæ•°ï¼Œå¹¶æœ€ç»ˆå°†è¿”å›æœ€å¤§çš„ä¸ªæ•°å€¼

### äºŒåä¸€ã€ä¸€ç»´åŠ¨æ€è§„åˆ’

#### 1ã€çˆ¬æ¥¼æ¢¯

**é¢˜ç›®é“¾æ¥**
[LeetCode No.70](https://leetcode.cn/problems/climbing-stairs/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int climbStairs(int n) {
    if ( n <=2 )
        return n;
    int[] dp = new int[n+1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i < n+1; ++ i)
        dp[i] = dp[i-1] + dp[i-2];
    return dp[n];
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- dp[i]è¡¨ç¤ºçˆ¬åˆ°ç¬¬iå±‚çš„æ–¹æ³•æ•°
- dp[i] = dp[i-1] + dp[i-2]

#### 2ã€æ‰“å®¶åŠ«èˆ

**é¢˜ç›®é“¾æ¥**
[LeetCode No.198](https://leetcode.cn/problems/house-robber/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
// äºŒç»´æ•°ç»„ç‰ˆæœ¬
public int rob(int[] nums) {
    int len = nums.length;
    int[][] dp = new int[len][2]; // [0]è¡¨ç¤ºæ‰“ï¼Œ[1]è¡¨ç¤ºä¸æ‰“
    dp[0][0] = 0;
    dp[0][1] = nums[0];
    for (int i = 1; i < len; ++ i) {
        dp[i][0] = dp[i-1][1];
        dp[i][1] = Math.max(dp[i-1][0]+nums[i], dp[i-1][1]);
    }
    return Math.max(dp[len-1][0], dp[len-1][1]);
}

//ä¸€ç»´æ•°ç»„ç‰ˆæœ¬
public int rob(int[] nums) {
    int len = nums.length;
    int[] dp = new int[len];
    dp[0] = nums[0];
    if (len > 1)
        dp[1] = Math.max(nums[0], nums[1]);
    else
        return dp[0];
    for (int i = 2; i < len; ++ i)
        dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
    return dp[len-1];
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- dp[i]ä»£è¡¨ç»è¿‡äº†ç¬¬iå®¶äººåæ‰‹é‡Œæœ€å¤šçš„è´¢å¯Œ
- dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i])

#### 3ã€å•è¯æ‹†åˆ†

**é¢˜ç›®é“¾æ¥**
[LeetCode No.](https://leetcode.cn/problems/word-break/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public boolean wordBreak(String s, List<String> wordDict) {
    boolean[] dp = new boolean[s.length()+1];
    dp[0] = true;
    for (int i = 1; i <= s.length(); ++ i)
        for (String word : wordDict) {
            int len = word.length();
            if (i >= len && dp[i-len] && word.equals(s.substring(i-len, i))) {
                dp[i] = true;
                break;
            }
        }
    return dp[s.length()];
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- dp[i]æ˜¯å‰iä¸ªå­—ç¬¦æ˜¯å¦å¯ä»¥è¢«wordDictç»„æˆ
- éå†æ‰€æœ‰å­—ç¬¦ï¼Œæ¯æ¬¡éƒ½éå†ä¸€éwordDickï¼Œåˆ¤æ–­å½“å‰éå†åˆ°çš„å’Œå…ˆå‰ä¸ºtrueçš„å­—ç¬¦ä¹‹é—´ç»„æˆçš„å•è¯æ˜¯å¦å­˜åœ¨äºwordDictä¸­ï¼Œè‹¥å­˜åœ¨åˆ™å½“å‰éå†åˆ°çš„ä½ç½®ä¸ºtrue

#### 4ã€é›¶é’±å…‘æ¢

**é¢˜ç›®é“¾æ¥**
[LeetCode No.322](https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java
public int coinChange(int[] coins,int amount) {
    int[] dp = new int[amount+1];
    Arrays.fill(dp, Integer.MAX_VALUE);
    dp[0] = 0;
    for (int i = 0; i < coins.length; ++ i)
        for (int j = coins[i]; j <= amount; ++ j)
            if (dp[j - coins[i]] != Integer.MAX_VALUE)
                dp[j] = Math.min(dp[j], dp[j-coins[i]]+1);
    return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
}
```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- å®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œé›¶é’±ä»·å€¼ä¸ºç‰©å“ï¼Œæ€»ä»·å€¼ä¸ºèƒŒåŒ…å¤§å°ã€‚
- å…ˆéå†é›¶é’±ï¼ˆç‰©å“ï¼‰ï¼Œåœ¨ä»å½“å‰ä»·å€¼çš„æœ€å°å€¼å¤„å¼€å§‹éå†èƒŒåŒ…ï¼Œåœ¨å½“å‰d[i-coins[j]]æœ‰å€¼çš„æ—¶å€™ï¼Œdp[j] = min(dp[j-coins[i]]-1, dp[j])

#### 5ã€æœ€é•¿é€’å¢å­åºåˆ—

**é¢˜ç›®é“¾æ¥**
[LeetCode No.300](https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-interview-150)

**æ ¸å¿ƒä»£ç **ï¼š

```java

```

**<font color=red>æ ¸å¿ƒæ€è·¯ï¼š</font>** 
- 