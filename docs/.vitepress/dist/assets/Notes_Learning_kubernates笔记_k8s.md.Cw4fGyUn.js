import{_ as l,c as i,a2 as r,o as t}from"./chunks/framework.BLg0S_rR.js";const a="/assets/framework.CkauR-f1.png",k=JSON.parse('{"title":"K8S","description":"","frontmatter":{},"headers":[],"relativePath":"Notes/Learning/kubernates笔记/k8s.md","filePath":"Notes/Learning/kubernates笔记/k8s.md","lastUpdated":1735027682000}'),o={name:"Notes/Learning/kubernates笔记/k8s.md"};function n(s,e,u,d,c,p){return t(),i("div",null,e[0]||(e[0]=[r('<h1 id="k8s" tabindex="-1">K8S <a class="header-anchor" href="#k8s" aria-label="Permalink to &quot;K8S&quot;">​</a></h1><h2 id="_1-概念" tabindex="-1">1. 概念 <a class="header-anchor" href="#_1-概念" aria-label="Permalink to &quot;1. 概念&quot;">​</a></h2><ul><li><p><strong>Container</strong>：轻量级的系统虚拟化技术，使用namespace隔离环境。</p></li><li><p><strong>Pod</strong>：<strong>K8S</strong> 的调度的基本单位，<strong>Pod</strong>是一组紧密关联的容器集合，内部的容器共享PID、IPC、Network和UTS namespace。可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。</p></li><li><p>Node: 是Pod运行的主机，可以为物理机，也可以为虚拟机。每个Node上要运行container runtime （docker或者rkt）、kubelet和kube-proxy服务</p></li><li><p>Service: 一个Pod只是一个运行服务的实例，可能在一个节点上停止，在另一个节点以一个新的IP启动一个新的Pod。在K8S集群中，客户端需要访问的服务就是Service对象。每个Service会对应一个集群内部有效的虚拟IP，集群内部通过虚拟IP访问一个服务。</p></li><li><p>Kubelet: 每个Node的任务和资源管理</p></li><li><p>Kube-proxy: 负责每个节点的硬件负载均衡</p></li></ul><h2 id="_2-组件" tabindex="-1">2. 组件 <a class="header-anchor" href="#_2-组件" aria-label="Permalink to &quot;2. 组件&quot;">​</a></h2><ul><li>Node: 可运行多个Pod</li><li>Pod: Container的抽象</li><li>Ingress: 集群外部的 HTTP 和 HTTPS 路由公开给集群内的 <strong>Service</strong></li><li>Service: Pod间的通信</li><li>ConfigMap: 配置文件，如路径</li><li>Secret: 安全配置，如密码</li><li>Volume: 持久化数据卷</li><li>Deployment: Pod的抽象，创建并管理ReplicaSet <ul><li>ReplicaSet: 一组Pod的副本</li></ul></li><li>StatefulSet: 管理一组Pod， 适用于需要持久化存储（数据库）或稳定、唯一网络标识的应用（一般数据库在K8S以外部署，以避免使用statefull）</li></ul><h2 id="_3-结构" tabindex="-1">3. 结构 <a class="header-anchor" href="#_3-结构" aria-label="Permalink to &quot;3. 结构&quot;">​</a></h2><p><img src="'+a+'" alt="image-20241220165517405"></p><ul><li>node（每个Node都需要安装以下三个process） <ul><li>container runtime(docker)</li><li>Kubelet: 与Container和Node都能交互，创建Pod，分配Node的资源给Pod</li><li>KubeProxy: 转发请求，从Service转发到Pod</li></ul></li><li>cluster（ <ul><li>master node <ul><li>API Server <ul><li>cluster gateway（集群的门户，用户交互）</li><li>gatekeeper (网关)</li></ul></li><li>Scheduler（调度器） <ul><li>启动Pod</li><li>分配Pod至合适的worker node中运行（负载均衡）</li></ul></li><li>Controller manager <ul><li>detect cluster state change(when pod dies / when Kubelet restart new pods)</li><li>reschedule pods</li></ul></li><li>etcd <ul><li>cluster brain</li><li>store cluster changes in the key value store</li></ul></li></ul></li><li>slave node / worker node</li><li>附加组件 <ul><li>kube-dns</li><li>ingress-controller 外部网络访问</li><li>Heapster, Prometheus 资源监控</li><li>Dashboard 控制台界面</li><li>Federation 跨可用区集群</li><li>Fluentd-elasticsearch 集群日志采集存储与查询</li></ul></li></ul></li></ul><p><strong>Note</strong></p><ul><li>cluster由多个master node组成</li><li>API Server是负载均衡的</li><li>etcd形成分布式存储</li><li>master比worker占用的资源少</li><li>可通过UI, API, CLI共3种方式与Api Server交互</li></ul><h2 id="_4-minikube" tabindex="-1">4. minikube <a class="header-anchor" href="#_4-minikube" aria-label="Permalink to &quot;4.  minikube&quot;">​</a></h2><ul><li>测试 / 本地集群设置 —— master and worker processes run on <strong>one</strong> machine</li><li>创建virtual box，因此需要Hypervisor（虚拟机管理程序）</li></ul><h2 id="_5-kubectl" tabindex="-1">5. kubectl <a class="header-anchor" href="#_5-kubectl" aria-label="Permalink to &quot;5. kubectl&quot;">​</a></h2><ul><li>Command line tool for K8s cluster</li></ul>',14)]))}const m=l(o,[["render",n]]);export{k as __pageData,m as default};
